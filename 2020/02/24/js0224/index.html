<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1.타입 변환개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.var x &#x3D; 10; &#x2F;&#x2F; 명시적 타입 변환&#x2F;&#x2F; 숫자를 문자열로 타입 캐스팅한다.var str &#x3D; x.toString();console.log(typeof str, str); &#x2F;&#x2F; string 10 &#x2F;&#x2F; 변수 x의 값이 변경된 것은 아니다.console.">
<meta property="og:type" content="article">
<meta property="og:title" content="자바스크립트 25일 예습.">
<meta property="og:url" content="https://pkt0831.github.io/2020/02/24/js0224/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="1.타입 변환개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.var x &#x3D; 10; &#x2F;&#x2F; 명시적 타입 변환&#x2F;&#x2F; 숫자를 문자열로 타입 캐스팅한다.var str &#x3D; x.toString();console.log(typeof str, str); &#x2F;&#x2F; string 10 &#x2F;&#x2F; 변수 x의 값이 변경된 것은 아니다.console.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-24T12:35:30.000Z">
<meta property="article:modified_time" content="2020-02-24T12:13:28.152Z">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/2020/02/24/js0224/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>자바스크립트 25일 예습. | pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/24/js0224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          자바스크립트 25일 예습.
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-24 21:35:30 / Modified: 21:13:28" itemprop="dateCreated datePublished" datetime="2020-02-24T21:35:30+09:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>1.타입 변환<br>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.<br>var x = 10;</p>
<p>// 명시적 타입 변환<br>// 숫자를 문자열로 타입 캐스팅한다.<br>var str = x.toString();<br>console.log(typeof str, str); // string 10</p>
<p>// 변수 x의 값이 변경된 것은 아니다.<br>console.log(typeof x, x); // number 10</p>
<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다.</p>
<p>var x = 10;</p>
<p>// 암묵적 타입 변환<br>// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.<br>var str = x + ‘’;<br>console.log(typeof str, str); // string 10</p>
<p>// 변수 x의 값이 변경된 것은 아니다.<br>console.log(typeof x, x); // number 10</p>
<p>명시적,암묵적 타입 변환이 기존 원시값을 변경하는건 아니다.타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.<br>// 원시값 1이 ‘1’로 직접 변경되는 것이 아니다.<br>// 1을 사용해 타입이 다른 ‘1’을 새롭게 생성하여 ‘1’ + ‘’을 평가한다.<br>1 + ‘’ // ‘1’</p>
<p>암묵적 타입 변환은 재할당이 아니라 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.<br>위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘’을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘’를 평가한다. 이때 자동 생성된 문자열 ‘10’은 변수 x에 할당되는 것이 아니다. 따라서 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다.</p>
<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다</p>
<p>2.암묵적 타입 변환<br>자바스크립트 엔진은 표현식을 평가할때 개발자의 의도 상관없이 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.<br>// 피연산자가 모두 문자열 타입이여야 하는 문맥<br>‘10’ + 2  // ‘102’</p>
<p>// 피연산자가 모두 숫자 타입이여야 하는 문맥<br>5 * ‘10’  // 50</p>
<p>// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥<br>!0 // true<br>if (1) { }</p>
<p>2.1 문자열 타입으로 변환</p>
<p>1 + ‘2’ // “12”</p>
<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다.</li>
</ul>
<p>템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.</p>
<p>console.log(<code>1 + 1 = ${1 + 1}</code>); // “1 + 1 = 2”</p>
<p>문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변호나 수행할때의 예.</p>
<p>// 숫자 타입<br>0 + ‘’              // “0”<br>-0 + ‘’             // “0”<br>1 + ‘’              // “1”<br>-1 + ‘’             // “-1”<br>NaN + ‘’            // “NaN”<br>Infinity + ‘’       // “Infinity”<br>-Infinity + ‘’      // “-Infinity”</p>
<p>// 불리언 타입<br>true + ‘’           // “true”<br>false + ‘’          // “false”</p>
<p>// null 타입<br>null + ‘’           // “null”</p>
<p>// undefined 타입<br>undefined + ‘’      // “undefined”</p>
<p>// 심볼 타입<br>(Symbol()) + ‘’     // TypeError: Cannot convert a Symbol value to a string</p>
<p>// 객체 타입<br>({}) + ‘’           // “[object Object]”<br>Math + ‘’           // “[object Math]”<br>[] + ‘’             // “”<br>[10, 20] + ‘’       // “10,20”<br>(function(){}) + ‘’ // “function(){}”<br>Array + ‘’          // “function Array() { [native code] }”</p>
<p>2.2숫자 타입으로 변환</p>
<p>1 - ‘1’    // 0<br>1 * ‘10’   // 10<br>1 / ‘one’  // NaN</p>
<p>산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다.산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>
<p>‘1’ &gt; 0   // true</p>
<p>비교연산자는 불리언 값을 만드는 것이다. 때문에 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>
<p>엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다.+ 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다.</p>
<p>// 문자열 타입<br>+’’             // 0<br>+’0’            // 0<br>+’1’            // 1<br>+’string’       // NaN</p>
<p>// 불리언 타입<br>+true           // 1<br>+false          // 0</p>
<p>// null 타입<br>+null           // 0</p>
<p>// undefined 타입<br>+undefined      // NaN</p>
<p>// 심볼 타입<br>+Symbol()       // TypeError: Cannot convert a Symbol value to a number</p>
<p>// 객체 타입<br>+{}             // NaN<br>+[]             // 0<br>+[10, 20]       // NaN<br>+(function(){}) // NaN</p>
<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다</p>
<p>2.3. 불리언 타입으로 변환</p>
<p>if (‘’) console.log(x);</p>
<p>if,for같은 제어문,삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다. 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>
<p>if (‘’)    console.log(‘1’);<br>if (true)  console.log(‘2’);<br>if (0)     console.log(‘3’);<br>if (‘str’) console.log(‘4’);<br>if (null)  console.log(‘5’);</p>
<p>// 2 4</p>
<p>자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.</p>
<p>false로 평가되는 Falsy 값들.<br>false<br>undefined<br>null<br>0, -0<br>NaN<br>’’ (빈문자열)</p>
<p>// 아래의 조건문은 모두 코드 블록을 실행한다.<br>if (!false)     console.log(false + ‘ is falsy value’);<br>if (!undefined) console.log(undefined + ‘ is falsy value’);<br>if (!null)      console.log(null + ‘ is falsy value’);<br>if (!0)         console.log(0 + ‘ is falsy value’);<br>if (!NaN)       console.log(NaN + ‘ is falsy value’);<br>if (!’’)        console.log(‘’ + ‘ is falsy value’);</p>
<p>Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<p>// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.<br>function isFalsy(v) {<br>  return !v;<br>}</p>
<p>// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.<br>function isTruthy(v) {<br>  return !!v;<br>}</p>
<p>// 모두 true를 반환한다.<br>console.log(isFalsy(false));<br>console.log(isFalsy(undefined));<br>console.log(isFalsy(null));<br>console.log(isFalsy(0));<br>console.log(isFalsy(NaN));<br>console.log(isFalsy(‘’));</p>
<p>// 모두 true를 반환한다.<br>console.log(isTruthy(true));<br>// 빈 문자열이 아닌 문자열은 Truthy 값이다.<br>console.log(isTruthy(‘0’));<br>console.log(isTruthy({}));<br>console.log(isTruthy([]));</p>
<ol start="3">
<li>명시적 타입 변환<br>개발자 의되에 의해 명시적으로 타입 변경 하는 3가지 방법.</li>
<li>표준 빌트인 생성자 함수를 new 연산자 없이 호출</li>
<li>js에서 제공하는 빌트인 메소드를 사용.</li>
<li>암묵적 변환을 이용하는 방법.</li>
</ol>
<p>3.1. 문자열 타입으로 변환<br>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 3가지 방법</p>
<p>// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법<br>// 숫자 타입 =&gt; 문자열 타입<br>console.log(String(1));        // “1”<br>console.log(String(NaN));      // “NaN”<br>console.log(String(Infinity)); // “Infinity”<br>// 불리언 타입 =&gt; 문자열 타입<br>console.log(String(true));     // “true”<br>console.log(String(false));    // “false”</p>
<p>// 2. Object.prototype.toString 메소드를 사용하는 방법<br>// 숫자 타입 =&gt; 문자열 타입<br>console.log((1).toString());        // “1”<br>console.log((NaN).toString());      // “NaN”<br>console.log((Infinity).toString()); // “Infinity”<br>// 불리언 타입 =&gt; 문자열 타입<br>console.log((true).toString());     // “true”<br>console.log((false).toString());    // “false”</p>
<p>// 3. 문자열 연결 연산자를 이용하는 방법<br>// 숫자 타입 =&gt; 문자열 타입<br>console.log(1 + ‘’);        // “1”<br>console.log(NaN + ‘’);      // “NaN”<br>console.log(Infinity + ‘’); // “Infinity”<br>// 불리언 타입 =&gt; 문자열 타입<br>console.log(true + ‘’);     // “true”<br>console.log(false + ‘’);    // “false”</p>
<p>3.2. 숫자 타입으로 변환</p>
<p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 4가지 방법.</p>
<p>// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법<br>// 문자열 타입 =&gt; 숫자 타입<br>console.log(Number(‘0’));     // 0<br>console.log(Number(‘-1’));    // -1<br>console.log(Number(‘10.53’)); // 10.53<br>// 불리언 타입 =&gt; 숫자 타입<br>console.log(Number(true));    // 1<br>console.log(Number(false));   // 0</p>
<p>// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)<br>// 문자열 타입 =&gt; 숫자 타입<br>console.log(parseInt(‘0’));       // 0<br>console.log(parseInt(‘-1’));      // -1<br>console.log(parseFloat(‘10.53’)); // 10.53</p>
<p>// 3. + 단항 산술 연산자를 이용하는 방법<br>// 문자열 타입 =&gt; 숫자 타입<br>console.log(+’0’);     // 0<br>console.log(+’-1’);    // -1<br>console.log(+’10.53’); // 10.53<br>// 불리언 타입 =&gt; 숫자 타입<br>console.log(+true);    // 1<br>console.log(+false);   // 0</p>
<p>// 4. * 산술 연산자를 이용하는 방법<br>// 문자열 타입 =&gt; 숫자 타입<br>console.log(‘0’ * 1);     // 0<br>console.log(‘-1’ * 1);    // -1<br>console.log(‘10.53’ * 1); // 10.53<br>// 불리언 타입 =&gt; 숫자 타입<br>console.log(true * 1);    // 1<br>console.log(false * 1);   // 0</p>
<p>3.3. 불리언 타입으로 변환</p>
<p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 2가지 방법</p>
<p>// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법<br>// 문자열 타입 =&gt; 불리언 타입<br>console.log(Boolean(‘x’));       // true<br>console.log(Boolean(‘’));        // false<br>console.log(Boolean(‘false’));   // true<br>// 숫자 타입 =&gt; 불리언 타입<br>console.log(Boolean(0));         // false<br>console.log(Boolean(1));         // true<br>console.log(Boolean(NaN));       // false<br>console.log(Boolean(Infinity));  // true<br>// null 타입 =&gt; 불리언 타입<br>console.log(Boolean(null));      // false<br>// undefined 타입 =&gt; 불리언 타 입<br>console.log(Boolean(undefined)); // false<br>// 객체 타입 =&gt; 불리언 타입<br>console.log(Boolean({}));        // true<br>console.log(Boolean([]));        // true</p>
<p>// 2. ! 부정 논리 연산자를 두번 사용하는 방법<br>// 문자열 타입 =&gt; 불리언 타입<br>console.log(!!’x’);       // true<br>console.log(!!’’);        // false<br>console.log(!!’false’);   // true<br>// 숫자 타입 =&gt; 불리언 타입<br>console.log(!!0);         // false<br>console.log(!!1);         // true<br>console.log(!!NaN);       // false<br>console.log(!!Infinity);  // true<br>// null 타입 =&gt; 불리언 타입<br>console.log(!!null);      // false<br>// undefined 타입 =&gt; 불리언 타입<br>console.log(!!undefined); // false<br>// 객체 타입 =&gt; 불리언 타입<br>console.log(!!{});        // true<br>console.log(!![]);        // true</p>
<p>4.단축 평가</p>
<p>논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.”</p>
<p>‘Cat’ &amp;&amp; ‘Dog’ // ‘Dog’</p>
<p>논리곱(&amp;&amp;) 연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다.첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다.두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 논리곱 연산자는 논리 연산의 결과를 결정한 두번째 피연산자 즉, 문자열 ‘Dog’를 그대로 반환한다.<br>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>
<p>‘Cat’ || ‘Dog’ // ‘Cat’</p>
<p>논리합(||) 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.<br>첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가.논리합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉, 문자열 ‘Cat’를 그대로 반환한다.논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이와 같이 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다.축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행한다.</p>
<p>단축 평가 규칙.<br>단축 평가 표현식.    평가 결과<br>true || anything      true<br>false || anything      anything<br>true &amp;&amp; anything      anything<br>false &amp;&amp; anything      false</p>
<p>// 논리합(||) 연산자<br>‘Cat’ || ‘Dog’  // ‘Cat’<br>false || ‘Dog’  // ‘Dog’<br>‘Cat’ || false  // ‘Cat’</p>
<p>// 논리곱(&amp;&amp;) 연산자<br>‘Cat’ &amp;&amp; ‘Dog’  // Dog<br>false &amp;&amp; ‘Dog’  // false<br>‘Cat’ &amp;&amp; false  // false</p>
<p>단축 평가를 사용하면 if문을 대체할 수 있다. 주어진 조건이 Truthy 값(참으로 평가되는 값)일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// 주어진 조건이 true일 때<br>if (done) message = ‘완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done &amp;&amp; ‘완료’;<br>console.log(message); // 완료</p>
<p>주어진 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야 한다면 논리합(||) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = false;<br>var message = ‘’;</p>
<p>// 주어진 조건이 false일 때<br>if (!done) message = ‘미완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done || ‘미완료’;<br>console.log(message); // 미완료</p>
<p>삼항 조건 연산자는 if..else문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// if…else문<br>if (done) message = ‘완료’;<br>else      message = ‘미완료’;<br>console.log(message); // 완료</p>
<p>// if..else문은 삼항 조건 연산자로 대체 가능하다.<br>message = done ? ‘완료’ : ‘미완료’;<br>console.log(message); // 완료</p>
<p>-단축 평가는 아래와 같은 상황에서 유용하게 사용된다.</p>
<p>객체가 null인지 확인하고 프로퍼티를 참조할 때<br>var elem = null;</p>
<p>console.log(elem.value); // TypeError: Cannot read property ‘value’ of null<br>console.log(elem &amp;&amp; elem.value); // null</p>
<p>객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다.</p>
<p>함수 매개변수에 기본값을 설정할 때</p>
<p>// 단축 평가를 사용한 매개변수의 기본값 설정<br>function getStringLength(str) {<br>  str = str || ‘’;<br>  return str.length;<br>}</p>
<p>getStringLength();     // 0<br>getStringLength(‘hi’); // 2</p>
<p>// ES6의 매개변수의 기본값 설정<br>function getStringLength(str = ‘’) {<br>  return str.length;<br>}</p>
<p>getStringLength();     // 0<br>getStringLength(‘hi’); // 2</p>
<p>함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/22/js2022/" rel="prev" title="자바스크립트 24일 예습.">
      <i class="fa fa-chevron-left"></i> 자바스크립트 24일 예습.
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

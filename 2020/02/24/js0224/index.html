<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1.타입 변환개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.var x &#x3D; 10; &#x2F;&#x2F; 명시적 타입 변환&#x2F;&#x2F; 숫자를 문자열로 타입 캐스팅한다. 12345var str &#x3D; x.toString();console.log(typeof str, str); &#x2F;&#x2F; string 10&#x2F;&#x2F; 변수 x의 값이 변경된 것은 아니다.con">
<meta property="og:type" content="article">
<meta property="og:title" content="타입 변환(explicit coercion)">
<meta property="og:url" content="https://pkt0831.github.io/2020/02/24/js0224/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="1.타입 변환개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.var x &#x3D; 10; &#x2F;&#x2F; 명시적 타입 변환&#x2F;&#x2F; 숫자를 문자열로 타입 캐스팅한다. 12345var str &#x3D; x.toString();console.log(typeof str, str); &#x2F;&#x2F; string 10&#x2F;&#x2F; 변수 x의 값이 변경된 것은 아니다.con">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-24T12:35:30.000Z">
<meta property="article:modified_time" content="2020-05-04T12:34:34.863Z">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/2020/02/24/js0224/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>타입 변환(explicit coercion) | pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/24/js0224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          타입 변환(explicit coercion)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 21:35:30" itemprop="dateCreated datePublished" datetime="2020-02-24T21:35:30+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-04 21:34:34" itemprop="dateModified" datetime="2020-05-04T21:34:34+09:00">2020-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>1.타입 변환<br>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.<br>var x = 10;</p>
<p>// 명시적 타입 변환<br>// 숫자를 문자열로 타입 캐스팅한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 x의 값이 변경된 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>
<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="number">10.</span>tostring ()벗기면 소수로 판별하기때문에 에러가남. <span class="number">10</span> + <span class="string">''</span>써야한다.</span><br></pre></td></tr></table></figure>

<p>// 암묵적 타입 변환<br>// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = x + <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 x의 값이 변경된 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>
<p>명시적,암묵적 타입 변환이 기존 원시값을 변경하는건 아니다.타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.<br>// 원시값 1이 ‘1’로 직접 변경되는 것이 아니다.<br>// 1을 사용해 타입이 다른 ‘1’을 새롭게 생성하여 ‘1’ + ‘’을 평가한다.<br>1 + ‘’ // ‘1’</p>
<p>암묵적 타입 변환은 재할당이 아니라 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.<br>위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘’을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘’를 평가한다. 이때 자동 생성된 문자열 ‘10’은 변수 x에 할당되는 것이 아니다. 따라서 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다.</p>
<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다</p>
<p>2.암묵적 타입 변환<br>자바스크립트 엔진은 표현식을 평가할때 개발자의 의도 상관없이 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.<br>// 피연산자가 모두 문자열 타입이여야 하는 문맥<br>‘10’ + 2  // ‘102’</p>
<p>// 피연산자가 모두 숫자 타입이여야 하는 문맥<br>5 * ‘10’  // 50</p>
<p>// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥<br>!0 // true<br>if (1) { }</p>
<p>2.1 문자열 타입으로 변환</p>
<p>1 + ‘2’ // “12”</p>
<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다.</li>
</ul>
<p>템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.</p>
<p>console.log(<code>1 + 1 = ${1 + 1}</code>); // “1 + 1 = 2”<br>$(1+1) 1+1을 먼저 연산하고 그다음에 타입변환된다.</p>
<p>문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변호나 수행할때의 예.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입</span></span><br><span class="line"><span class="number">0</span> + <span class="string">''</span>              <span class="comment">// "0"</span></span><br><span class="line"><span class="number">-0</span> + <span class="string">''</span>             <span class="comment">// "0"</span></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span>              <span class="comment">// "1"</span></span><br><span class="line"><span class="number">-1</span> + <span class="string">''</span>             <span class="comment">// "-1"</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span>            <span class="comment">// "NaN"</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="string">''</span>       <span class="comment">// "Infinity"</span></span><br><span class="line">-<span class="literal">Infinity</span> + <span class="string">''</span>      <span class="comment">// "-Infinity"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span>           <span class="comment">// "true"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">''</span>          <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span>           <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span>      <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">(<span class="built_in">Symbol</span>()) + <span class="string">''</span>     <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">(&#123;&#125;) + <span class="string">''</span>           <span class="comment">// "[object Object]"       (&#123;&#125;)는 객체 리터럴.</span></span><br><span class="line"><span class="built_in">Math</span> + <span class="string">''</span>           <span class="comment">// "[object Math]"</span></span><br><span class="line">[] + <span class="string">''</span>             <span class="comment">// ""</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>] + <span class="string">''</span>       <span class="comment">// "10,20"</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) + <span class="string">''</span> <span class="comment">// "function()&#123;&#125;"</span></span><br><span class="line"><span class="built_in">Array</span> + <span class="string">''</span>          <span class="comment">// "function Array() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>
<p>2.2숫자 타입으로 변환</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span>    <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span>   <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span>  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다.산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>
<p>‘1’ &gt; 0   // true</p>
<p>비교연산자는 불리언 값을 만드는 것이다. 때문에 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>
<p>엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다.+ 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다.</p>
<p>// 문자열 타입<br>+’’             // 0<br>+’0’            // 0<br>+’1’            // 1<br>+’string’       // NaN</p>
<p>// 불리언 타입<br>+true           // 1<br>+false          // 0</p>
<p>// null 타입<br>+null           // 0</p>
<p>// undefined 타입<br>+undefined      // NaN</p>
<p>// 심볼 타입<br>+Symbol()       // TypeError: Cannot convert a Symbol value to a number</p>
<p>// 객체 타입<br>+{}             // NaN<br>+[]             // 0<br>+[10, 20]       // NaN<br>+(function(){}) // NaN</p>
<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다</p>
<p>2.3. 불리언 타입으로 변환</p>
<p>if (‘’) console.log(x);</p>
<p>if,for같은 제어문,삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다. 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>
<p>if (‘’)    console.log(‘1’);<br>if (true)  console.log(‘2’);<br>if (0)     console.log(‘3’);<br>if (‘str’) console.log(‘4’);<br>if (null)  console.log(‘5’);</p>
<p>// 2 4</p>
<p>자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.</p>
<p>false로 평가되는 Falsy 값들.<br>false<br>undefined<br>null<br>0, -0<br>NaN<br>’’ (빈문자열)</p>
<p>// 아래의 조건문은 모두 코드 블록을 실행한다.<br>if (!false)     console.log(false + ‘ is falsy value’);<br>if (!undefined) console.log(undefined + ‘ is falsy value’);<br>if (!null)      console.log(null + ‘ is falsy value’);<br>if (!0)         console.log(0 + ‘ is falsy value’);<br>if (!NaN)       console.log(NaN + ‘ is falsy value’);<br>if (!’’)        console.log(‘’ + ‘ is falsy value’);</p>
<p>Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<p>// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.<br>function isFalsy(v) {<br>  return !v;<br>}</p>
<p>// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.<br>function isTruthy(v) {<br>  return !!v;<br>}</p>
<p>// 모두 true를 반환한다.<br>console.log(isFalsy(false));<br>console.log(isFalsy(undefined));<br>console.log(isFalsy(null));<br>console.log(isFalsy(0));<br>console.log(isFalsy(NaN));<br>console.log(isFalsy(‘’));</p>
<p>// 모두 true를 반환한다.<br>console.log(isTruthy(true));<br>// 빈 문자열이 아닌 문자열은 Truthy 값이다.<br>console.log(isTruthy(‘0’));<br>console.log(isTruthy({}));<br>console.log(isTruthy([]));</p>
<ol start="3">
<li>명시적 타입 변환<br>문자열은 원시값이다. 문자열 객체는 (‘Hello’).touppercase()<br>개발자 의도에 의해 명시적으로 타입 변경 하는 3가지 방법.</li>
<li>표준 빌트인 생성자 함수를 new 연산자 없이 호출</li>
<li>js에서 제공하는 빌트인 메소드를 사용.</li>
<li>암묵적 변환을 이용하는 방법.(제일 많이 쓰인다.)</li>
</ol>
<p>3.1. 문자열 타입으로 변환<br>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 3가지 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법(잘 쓰이지 않는다.)</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>));        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>));      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">Infinity</span>)); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>));     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">false</span>));    <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).toString());        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">NaN</span>).toString());      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">Infinity</span>).toString()); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).toString());     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span>).toString());    <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법(제일 많이 쓰인다.)</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">''</span>);        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">''</span>);      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> + <span class="string">''</span>); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">''</span>);     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">''</span>);    <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure>

<p>3.2. 숫자 타입으로 변환</p>
<p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 4가지 방법.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'0'</span>));     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'-1'</span>));    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'0'</span>));       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'-1'</span>));      <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'0'</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'-1'</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'10.53'</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">false</span>);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> * <span class="number">1</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-1'</span> * <span class="number">1</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10.53'</span> * <span class="number">1</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> * <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * <span class="number">1</span>);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>3.3. 불리언 타입으로 변환</p>
<p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 2가지 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'x'</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>));        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'false'</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">Infinity</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타 입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([]));        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'x'</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">''</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'false'</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">1</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">Infinity</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!&#123;&#125;);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!![]);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>4.단축 평가</p>
<p>논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.”</p>
<p>‘Cat’ &amp;&amp; ‘Dog’ // ‘Dog’</p>
<p>논리곱(&amp;&amp;) 연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다.첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다.두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 논리곱 연산자는 논리 연산의 결과를 결정한 두번째 피연산자 즉, 문자열 ‘Dog’를 그대로 반환한다.<br>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>
<p>‘Cat’ || ‘Dog’ // ‘Cat’</p>
<p>논리합(||) 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.<br>첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가.논리합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉, 문자열 ‘Cat’를 그대로 반환한다.논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이와 같이 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다.축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행한다.</p>
<p>단축 평가 규칙.<br>단축 평가 표현식.    평가 결과<br>true || anything      true<br>false || anything      anything<br>true &amp;&amp; anything      anything<br>false &amp;&amp; anything      false</p>
<p>// 논리합(||) 연산자<br>‘Cat’ || ‘Dog’  // ‘Cat’<br>false || ‘Dog’  // ‘Dog’<br>‘Cat’ || false  // ‘Cat’</p>
<p>// 논리곱(&amp;&amp;) 연산자<br>‘Cat’ &amp;&amp; ‘Dog’  // Dog<br>false &amp;&amp; ‘Dog’  // false<br>‘Cat’ &amp;&amp; false  // false</p>
<p>단축 평가를 사용하면 if문을 대체할 수 있다. 주어진 조건이 Truthy 값(참으로 평가되는 값)일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// 주어진 조건이 true일 때<br>if (done) message = ‘완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done &amp;&amp; ‘완료’;<br>console.log(message); // 완료</p>
<p>주어진 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야 한다면 논리합(||) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = false;<br>var message = ‘’;</p>
<p>// 주어진 조건이 false일 때<br>if (!done) message = ‘미완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done || ‘미완료’;<br>console.log(message); // 미완료</p>
<p>삼항 조건 연산자는 if..else문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// if…else문<br>if (done) message = ‘완료’;<br>else      message = ‘미완료’;<br>console.log(message); // 완료</p>
<p>// if..else문은 삼항 조건 연산자로 대체 가능하다.<br>message = done ? ‘완료’ : ‘미완료’;<br>console.log(message); // 완료</p>
<p>-단축 평가는 아래와 같은 상황에서 유용하게 사용된다.</p>
<p>객체가 null인지 확인하고 프로퍼티를 참조할 때<br>var elem = null;</p>
<p>console.log(elem.value); // TypeError: Cannot read property ‘value’ of null<br>console.log(elem &amp;&amp; elem.value); // null</p>
<p>객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다.</p>
<p>함수 매개변수에 기본값을 설정할 때</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.</p>
<p>10.객체 리터럴</p>
<p>1.객체란?<br>자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.<br>원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 키(Key) = 값을 찾아오는 단서.</p>
<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다.<br>-프로퍼티: 객체의 상태를 나타내는 값(data)<br>-메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</p>
<p>객체와 함수<br>자바스크립트의 객체는 함수와 밀접한 관계를 갖는다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다. 즉, 객체를 이해해야 함수를 제대로 이해할 수 있고 반대로 함수를 이해해야 객체를 정확히 이해할 수 있다.</p>
<p>2.객체 리터럴에 의한 객체 생성<br>블록문이 아니기 대문에 {}; ;세미콜론 붙인다.<br>인스턴스<br>인스턴스(instance)란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다.</p>
<p>자바스크립트는 프로토타입 기반 객체향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다.</p>
<p>-객체 리터럴<br>-Object 생성자 함수<br>-생성자 함수<br>-Object.create 메소드<br>-클래스 (ES6)</p>
<p>가장 일바적인 방법은 객체 리터럴을 사용하는 방법이다. 객체 리터럴은 객체를 생성하는 표기법이다.<br>객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee", sayHello: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> empty = &#123;&#125;; <span class="comment">// 빈 객체</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> empty); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>객체 리터럴의 중괄호는 코드 블록 의미 x , 코드 블록의 닫는 중괄호 뒤에는 세미 콜론 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이기에 닫는 중괄호 뒤에는 세미 콜론을 붙인다.</p>
<p>3.프로퍼티<br>-객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성.<br>-프로퍼티 나열할 때는 쉼표(,)로 구분.<br>-마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 name, 프로퍼티 값은 'Lee'</span></span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 age, 프로퍼티 값은 20</span></span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값.<br>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값.<br>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다.프로퍼티 키를 나누는 이유는 식별자는 스코프에서 찾고 키는 프로타입 체인에서 찾는데 그걸 구별하기 위해서.<br>symbol 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다.<br>이때 프로퍼티 키는 문자열이므로 따옴표(‘…’ 또는 “…”)로 묶어야 하지만 유효한 이름인 경우,따옴표를 생략할 수 있다.식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Ung-mo'</span>, <span class="comment">// 유효한 이름</span></span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>   <span class="comment">// 유효하지 않은 이름</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;firstName: "Ung-mo", last-name: "Lee"&#125;</span></span><br></pre></td></tr></table></figure>
<p>빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지는 않는다.하지만 키로서의 의미를 갖지 못한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="string">''</span>: <span class="string">''</span>  <span class="comment">// 빈문자열도 프로퍼티 키로 사용할 수 있다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123;"": ""&#125;</span></span><br></pre></td></tr></table></figure>
<p>-프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.<br>-var, function과 같은 예약어(Reserved word)를 프로퍼티 키로 사용해도 에러가 발생하지 않는다.<br>-이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.</p>
<p>4.메소드</p>
<p>자바 스크립트에서 사용할 수 있는 모든 값 = 프로퍼티 값으로 사용 가능= 객체 = 함수. 따라서 함수는 값으로 취급 가능하고 프로퍼티의 값이 될 수 있다.</p>
<p>프로퍼티 값이 함수일 경우, 일반 함수와 구분하기위해 메소드라 부른다.메소드= 객체에 제한되어 있는 함수를 의미.메소드도 결국은 프로퍼티다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  radius: <span class="number">5</span>, <span class="comment">// ← 프로퍼티</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 원의 지름</span></span><br><span class="line">  getDiameter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// ← 메소드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius; <span class="comment">// this는 circle를 가리킨다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>는 객체(프로퍼티)를 가리킨다.</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>5.프로퍼티 접근<br>-name이라는 전역 객체가 있다.<br>-프로퍼티 값에 접근하려면 마침표(.)를 사용하는 마침표 표기법(Dot notation) 또는 대괄호([…])를 사용하는 대괄호 표기법(Bracket notation)을 사용한다.<br>-프로퍼티 키가 js에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용 가능.<br>-마침표 또는 대괄호의 좌측에는 표현식 기술. 우측 또는 대괄호 내부에는 프로퍼티 키를 지정.<br>식별자 규칙을 지키면 ‘ ‘ 안붙여도 엔진이 자동으로 문자열로 해석함.안지키면 ‘’해줘야함.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마침표 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>]); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>
<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다.</p>
<p>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값<br>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</p>
<p>대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. </p>
<p>-객체에 존재하지 않는 프로퍼티에 접근하면 ReferenceError가 아닌 undefined를 반환한다.<br>-프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법을 사용해야 한다.<br>-대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.</p>
<p>6.프로퍼티 값 갱신<br>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.</span></span><br><span class="line">person.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123;name: "Kim"&#125;</span></span><br></pre></td></tr></table></figure>
<p>7.프로퍼티 동적 생성</p>
<p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.있으면 덮어쓴다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;                        &#123;&#125;는 할당 직전에 생성됨.없는걸 지우면 무시한다.</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 객체에는 age 프로퍼티가 존재하지 않는다.</span></span><br><span class="line"><span class="comment">// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee", age: 20&#125;</span></span><br></pre></td></tr></table></figure>
<p>8.프로퍼티 삭제<br>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다.</p>
<ol start="9">
<li>ES6에서 추가된 객체 리터럴의 확장 기능</li>
</ol>
<p>9.1. 프로퍼티 축약 표현</p>
<p>-객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.<br>// ES5<br>var x = 1, y = 2;</p>
<p>var obj = {<br>  x: x,                      x: x (이자리는 표현식이 와야하는 자리)<br>  y: y<br>};</p>
<p>console.log(obj); // {x: 1, y: 2}</p>
<p>-ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략(Property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.<br>9.2. 프로퍼티 키 동적 생성</p>
<p>-문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능.<br>-프로퍼티 키로 사용할 표현식을 대괄호([…])로 묶어야 한다. 이를 계산된 프로퍼티 이름(Computed property name)이라 한다.<br>-ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.</p>
<p>9.3. 메소드 축약 표현</p>
<p>-ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다.<br>-ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.<br>-S6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다. </p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/22/js2022/" rel="prev" title="연산자(operator)">
      <i class="fa fa-chevron-left"></i> 연산자(operator)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/25/js0225/" rel="next" title="원시 값과 객체의 비교">
      원시 값과 객체의 비교 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

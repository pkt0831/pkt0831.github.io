{"meta":{"title":"pkt0831's Blog","subtitle":"","description":"My Blog","author":"Ki Tae Park","url":"https://pkt0831.github.io","root":"/"},"pages":[],"posts":[{"title":"Deno JS","slug":"DenoJS","date":"2020-08-27T14:07:30.000Z","updated":"2020-08-07T19:03:42.950Z","comments":true,"path":"2020/08/27/DenoJS/","link":"","permalink":"https://pkt0831.github.io/2020/08/27/DenoJS/","excerpt":"","text":"Deno란 무엇인가?Deno란 용어는 Node를 거꾸로 재조합하여 만든 용어로서, Node의 단점을 보완하고 대체하기 위하여 만든 Javascript와 Typescript를 실행하기 위한 새로운 Command-line Runtime입니다. Deno를 공부하게 된 이유는? 프론트엔드를 공부하면서 자연스럽게 Node JS에 관심이 갔고, 최신 트렌드를 찾아보다가 Node JS 제작자인 Ryan Dahl이 Node의 단점을 보완한 새로운 라이브러리를 개발 했다고 해서 알게 되었다. Node가 점점 밀려나는 추세라는것을 알고 있었고 Deno를 공부 할수록 가까운 시일내에 Node를 대체할것이라는 확신을 가지게 되었다. 나온지 얼마 되지 않아 대체 되는데 시간이 걸리겠지만 Node를 공부하기전에 Deno를 체험해보며 차이점을 느껴보고 싶었다. Ryan Dahl이 Deno를 만들게된 이유 최근 Go 언어같은 빠르고 안정적인 언어들이 생겨나면서 Node를 대체하게 됨. Node를 개발하면서 IO부분만 너무 신경쓴 나머지 다른 환경들은 도외시한채 설계하게됨. 그에 따라 많은 시간이 지날수록 많은 단점을 가진 프로그램이 되었음. 이에따라 Node에서 바꾸려고 했지만 이미 Node를 적용한 회사와 소프트웨어들이 많아지면서 손댈수 없게됨. 기반 기술 V8 Javascript Runtime. Rust (Node는 C++) Tokio(event loop 제어) TypeScript Ryan Dahl이 느낀 Node를 만든 후 후회하는 점과 Deno에서 달라진점. index.js.웹 표준에 index.html이 있었기 때문에 그걸 따라 index.js를 만들면 귀여워 보여서 만들었는데 불필요한 도입이였다고 한다.이로 인해 불필요하게 모듈 로딩 시스템을 복잡하게 만들었으며, package.json에 종속적이 되어 더욱 불필요한 방식이 되었다고 후회했다 Promise 제거.Promise를 만들었다가 제거했는데, 그로 인해 비동기 처리에 어려움을 겪었고 async/await 보급화를 좀 더 빨리 당길 수 있는것을 늦췄다. 보안 취약.모든 시스템 호출에 접근 할 수 있어 취약점이 노출되는 보안 문제가 있다.그에 따라 보안 강화를 위해 Node JS는 C++로 만들어져 있으나 Rust로 대체.따라서 Deno의 코드는 샌드박스를 통해 실행된다. Node의 경우엔 파일 시스템에 손쉽게 접근 할 수 있지만 Deno는 명시적 복잡한 명령어를 통해 허용해야만 접근 가능하게 만들어 보안을 강화 시켰다. package.json 문제.Javascript 프로그램에서 어떤 프로그램을 require 할때는 이 프로그램이 뭔지 모르기 때문에 package.json에 명시되어야 합니다. 이전에는 디렉터리 모듈 개념이 존재하지 않았기 때문에 웹에서 Javascript를 script 태그로 여기저기에 포함시켰어야 했습니다.그에 따라서 탄생한게 NPM 모듈 패키지 입니다. 하지만 NPM같은 모듈 패키지도 단지 라이브러리를 연결 하고 싶은 것인데 회계장부 작성하듯이 작성하는것에 회의를 느끼게 되었습니다.그리고 갈수록 node_Module이 커지는 큰 단점이 있었습니다. 로컬 프로젝트 폴더에 모듈이 설치되기 때문에 프로젝트가 많아질수록 모듈 관리 문제와 용량 증가로인한 무거움, 한 폴더에 모든 Module을 때려박는게 시멘틱에도 알맞지 않다고 생각.때문에 Deno에선 생산적이고 안전한 스크립팅 환경을 위해 NPM 패키지 대신 ULR 또는 파일 경로를 참조해 모듈을 불러오는 시스템으로 변화했습니다. 그 외에도 Node.js 경우 포착되지 않은 오류 이후에도 실행을 계속 허용하여 예측 할 수 없는 결과를 발생시키지만 디노는 오류 발생시 항상 죽어버리게 설계해서 버그이지만 동작하는 상황이 없게 만듦. 기본적으로 TypeScript가 내장되어있어서 노드때처럼 모듈 다운받고 설정할 필요 X. Node처럼 require를 사용하는게 아니라 url로 import를 한다.network acces 권한을 요구하고 있다.async await을 쓰는 코드.top level await는 aync가 생략 가능해서 aync를 제거해도 코드가 실행된다.","categories":[],"tags":[]},{"title":"JWT","slug":"JWT","date":"2020-06-28T08:55:30.000Z","updated":"2020-08-07T17:46:53.261Z","comments":true,"path":"2020/06/28/JWT/","link":"","permalink":"https://pkt0831.github.io/2020/06/28/JWT/","excerpt":"","text":"1.인증방식(JWT)토큰 기반 인증 시스템 중 하나. 과거 Statefull 서버 상태에선 유저의 수가 늘어날수록 서버나 DB에 요청하기 때문에과부하가 걸리는 단점이 있었는데 이 점을 보완하고자 Stateless 토큰 기반 시스템을 만들게 되었다.구현 방법은 유저가 로그인 -&gt; 서버측에서 계정정보 검증 -&gt; 정확하다면 서버측에서 signed 토큰 발급. -&gt; 전달받은 토큰 저장 서버에 요청할때마다 토큰 서버에 전달 -&gt; 서버는 토큰 검증 후 요청 응답.2.reducer 구현방식useState는 간단한 상태를, reducer는 복잡한 상태관리를 체계적으로 관리하기위해서 사용.Reducer를 쓰게되면 상태 업데이트 로직을 컴포넌트 밖으로 분리 가능.Action 객체를 통해 상태를 업데이트함.맨처음 reducer 함수에 (state,action) state는 초기값, action은 실행하는 파라미터. switch문으로 action.type 작성.그리고 해당 컴포넌트 이동후 const[현재의 상태, dispatch(액션을 발생시키는 함수)] = useReducer(reducer, 0(초기값))컴포넌트 안 동작할 const로 이동후 dispatch 작성해서 실행. 3.Styled-components태그 탬플릿 리터럴로 구현, props를 활용하여 스타일링 가능. &amp; 문자를 사용하여 자기 자신 선택하여 추가기능 구현 가능.","categories":[],"tags":[]},{"title":"자바스크립트 개념.","slug":"mibi","date":"2020-05-07T20:55:30.000Z","updated":"2020-06-24T12:08:59.298Z","comments":true,"path":"2020/05/08/mibi/","link":"","permalink":"https://pkt0831.github.io/2020/05/08/mibi/","excerpt":"","text":"비동기 처리란?현재 실행중인 태스크가 종료되지 않은 상태라 하더라도 다음 태스크를 곧바로 실행하는 방식을 비동기식 처리 모델이이라고 하고, 현재 실행중인 태스크가 종료할 때까지 다음 실행될 태스크가 대기하는 방식을 동기식 처리 모델이라고 한다.자바스크립트의 타이머 함수,HTTP요청이 비동기식 처리 모델이다. ES6에서 새로 생긴 기능들은?let, const, class, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, Symbol, Promise, Map/Set, iterator, for…of, generator, Proxy, module import/export Ajax란?자바스크립트를 이용해서 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신 기능. JavaScript와 ECMAScript 란?ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 표준 빌트인 객체(standard built-in object) 등 핵심 문법(core syntax)을 규정한다자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다. 자바스크립트의 특징.자바스크립트는 웹 브라우저에서 동작하기위해 탄생한 프로그래밍 언어로써, 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다. 또한, 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 프로토타입 기반의 객체지향 언어이다. 변수란?변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.변수에 값을 저장하는 것을 할당, 읽어들이는 것을 참조라고한다. 식별자란?어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다.또한, 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 변수 호이스팅이란?변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)이라 한다. 값이 할당되는 시점은?변수 선언은 런타임 이전에 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 런타임에 실행된다. 값이란?값(value)은 식(표현식, expression)이 평가(evaluate)되어 생성된 결과를 말한다. 리터럴리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식(notaion)을 말한다. 표현식표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다.12-1. 프로토 타입 이란?객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용되는것으로써, 어떤 객체의 상위 객체의 역할을 하는 객체로 다른 객체에 공유 프로퍼티를 제공하는것을 프로토타입이라고 한다. 문문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 토큰토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 객체란?속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조 프로퍼티,메소드란?프로퍼티란 객체의 상태를 나타내는 값, 메소드는 프로퍼티를 참조하고 조작할 수 있는 동작. 객체를 생성하는 방법은?객체 리터럴,Object 생성자 함수,Object.create 메소드,클래스,생성자 함수 값에 의한 전달이란?변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 자바스크립트는 값에 의한 전달만이 존재한다. 참조에 의한 전달객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)라 한다. 얕은복사와 깊은 복사얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다. 함수란?함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것으로써,코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수호이스팅이란?함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라 한다. 콜백함수란?함수의 매개변수를 통해 전달되는 함수를 콜백 함수(callback function)라고 한다. 고차함수란?콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수라고 한다. 스코프란?식별자가 유효한 범위를 말한다. 스코프체인이란?스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 부른다. 블록레벨 스코프와 함수 레벨 스코프함수 몸체 만이 아니라 모든 코드 블록이 지역스코프를 만드는것을 블록레벨스코프, var 키워드같이 오로지 함수의 코드 블록 만을 지역 스코프로 인정하는것을 함수 레벨 스코프라고한다. 동적 스코프와 렉시컬 스코프(정적 스코프)란?함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하는것을 동적 스코프라하고, 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는것을 렉시컬 스코프라한다. 전역 변수의 문제점모든 코드가 전역 변수를 참조하고 변경할수있는 암묵적 결합과 생명 주기가 길기 때문에 메모리 리소스 관리에 비효율 적이다.또한, 스코프 체인 상 종점에 존재해 검색 속도가 느리고 파일이 분리되어있어도 하나의 전역 스코프를 공유하기때문에 네임 스페이스 오염을 가져올 수 있다. 일급 객체무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.함수의 매개 변수에게 전달할 수 있다.함수의 결과값으로 반환할 수 있다. 객체지향 프로그래밍절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다. 프로토타입 체인이란?자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. thisthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. 렉시컬 환경식별자와 식별자에 바인딩된 값 그리고 상위 스코프에 대한 참조를 기록하는 환경 클래스와 생성자 함수의 차이점. 클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발행한다. 하지만 생성자 함수는 new 연산자를 사용하지 않고 호출하면 일반 함수로서 호출된다. 2.클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 extends와 super 키워드를 지원하지 않는다. 3.클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다. 4.클래스 내의 모든 코드에는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 하지만 생성자 함수는 암묵적으로 strict 모드가 지정되지 않는다. 5.클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시 말해, 열거되지 않는다.36. 화살표 함수와 일반 함수의 차이점.화살표 함수는 함수 자체의 this 바인딩이 없다. 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 참조한다.37. 디스트럭처리 할당이란?구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.38. Promise콜백헬과 에러처리의 한계때문에 생긴 비동기 처리에 사용되는 객체.39. 제너레이터란?ES6에서 도입된 제너레이터(Generator) 함수는 이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다.40. 클로저 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.41. 프로토타입이란?객체 간 상속을 구현하기 위해 사용되는것으로써,다른 객체에 공유 프로퍼티를 제공하는 역할을 한다.42. 리액트를 쓰는 이유는?","categories":[],"tags":[]},{"title":"DataBase","slug":"DataBase","date":"2020-05-04T12:18:57.802Z","updated":"2020-05-04T12:22:40.810Z","comments":true,"path":"2020/05/04/DataBase/","link":"","permalink":"https://pkt0831.github.io/2020/05/04/DataBase/","excerpt":"","text":"country 테이블에서 중복을 제거한 Continent를 조회하세요.select DISTINCT(continent) as continentfrom world.country; 한국 도시중에 인구가 100만이 넘는 도시를 조회하여 인구순으로 내림차순하세요.select *from citywhere countrycode = “kor” and population &gt; 1000000ORDER BY population DESC; city 테이블에서 population이 800만 ~ 1000만 사이인 도시 데이터를 인구수순으로 내림차순하세요.select *from citywhere population between 800000 and 10000000order by population desc; country 테이블에서 1940 ~ 1950년도 사이에 독립한 국가들을 조회하고 독립한 년도 순으로 오름차순하세요.select *from countrywhere indepyear between 1940 and 1950order by indepyear asc; contrylanguage 테이블에서 스페인어, 한국어, 영어를 95% 이상 사용하는 국가 코드를 Percentage로 내림차순하여 아래와 같이 조회하세요.select *from countrylanguagewhere language in(“english”,”korean”,”spanish”) and percentage &gt; 95order by percentage desc; country 테이블에서 Code가 A로 시작하고 GovernmentForm에 Republic이 포함되는 데이터를 아래와같이 조회하세요.select *from countrywhere governmentform like “%republic”order by code asc","categories":[],"tags":[]},{"title":"Module","slug":"Module(04.15)","date":"2020-04-15T00:55:30.000Z","updated":"2020-04-16T02:07:28.781Z","comments":true,"path":"2020/04/15/Module(04.15)/","link":"","permalink":"https://pkt0831.github.io/2020/04/15/Module(04.15)/","excerpt":"","text":"모듈이란?모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.script 태그에 type=”module” 어튜리뷰트를 추가하면 모둘로서 동작한다.다만, 여러가지 이유로인해 ES6 모듈보단 Webpack 등의 모듈 번들러를 사용한다. 모듈 스코프모듈 기능을 사용하지 않으면 독자적인 스코프를 갖지 않고 하나의 전역을 공유하는 문제점이있다.따라서 ES6 모듈을 사용함으로써 독자적인 모듈 스코프를 갖게된다. export 키워드모듈 안에 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할수있게 해주는 키워드.하나의 객체로 모아서 선언할 수도 있다.ex) export { pi, Person}; inport 키워드모듈에서 공개한 대상을 로드하기위해 사용되는 키워드.","categories":[],"tags":[]},{"title":"Promise","slug":"Promise(04.08)","date":"2020-04-08T00:55:30.000Z","updated":"2020-04-08T12:35:58.708Z","comments":true,"path":"2020/04/08/Promise(04.08)/","link":"","permalink":"https://pkt0831.github.io/2020/04/08/Promise(04.08)/","excerpt":"","text":"프로미스란?자바스크립트는 비동기 처리를 위해 콜백 함수를 사용하는데 에러의 예외 처리가 곤란한 단점을 보완하기위해 비동기 처리를 위한 다른 패턴인 프로미스가 생기게 되었다. 이로인해 비동기 처리 시점이 명확하게 표현할수있게되었다. 콜백 패턴의 단점. 1.콜백 헬.비동기 처리를 위해 콜백 패턴을 사용하면 여러개의 콜백 함수가 정칩되어 복잡도가 높아지는 현상.이러한 현상이 생기는 원인은 비동기 처리 모델은 실행 완료를 기다리지 않고 즉시 다음 태스크를 실행하기 때문에 기대한 대로 동작하지않게 된다.2.에러 처리의 한계.비동기 처리 함수의 콜백 함수 실행 순서는.1.이벤트 발생 -&gt; 태스트 큐 이동 -&gt; 호출 스택이 비어졌을때 호출 스택으로 이동후 실행. 프로미스의 생성.프로미스는 Promise 생성자 함수를 통해 인스턴스화하고 resolve와 reject 함수를 인자로 전달받는다.Promise는 비동기 처리가 성공(fulfilled)하였는지 또는 실패(rejected)하였는지 등의 상태(state) 정보를 갖는다.fullfilled (성공), rejected(실패), settled(성공 또는 실패), pending(수행 안됨). 프로미스의 후속 처리 메소드Promise로 구현된 비동기 함수는 Promise 객체를 반환한다. Promise 객체의 후속 처리 메소드(then, catch)를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다.then: 두 개의 콜백 함수를 인자로 전달 받는다. 첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 두 번째 함수는 실패.then 메소드는 Promise를 반환.catch: 예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출. 프로미스의 에러 처리.catch 메소드는 비동기 처리에서 발생한 에러뿐만 아니라 then메소드 내부에서 발생한 에러도 캐치한다. 에러처리는 catch메소드를 사용하는 편이 효율적이다. 프로미스 체이닝프로미스는 후속 처리 메소드를 체이닝하여 여러 개의 프로미스를 연결하여 사용하여 콜백 헬을 해결한다. 프로미스의 정적 메소드.4가지 정적 메소드를 제공한다. Promise.resolve/Promise.rejectPromise.resolve 메소드는 인자로 전달된 값을 resolve하는 Promise를 생성.Promise.reject 인자로 전달된 값을 reject하는 프로미스를 생성. Promise.all프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. Promise.racePromise.all처럼 배열,이터러블을 인자로 전달 받지만 차이점은 병렬로 처리하는것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 반환한다.","categories":[],"tags":[]},{"title":"TIL","slug":"TIL","date":"2020-04-04T14:54:36.232Z","updated":"2020-08-04T14:25:39.873Z","comments":true,"path":"2020/04/04/TIL/","link":"","permalink":"https://pkt0831.github.io/2020/04/04/TIL/","excerpt":"","text":"04.07todo 리스트를 JSON을 이용해서 가상의 백엔드 서버를 설정하고 서버 호출 실습. 04.08todo 리스트 미비한거 공부 및 Promise 예습. 비동기 처리의 어려움을 느낌. 04.09Promise 실습 및 이력서 보완점 고침. Todo 리스트 반복 학습. 04.11Todo 리스트 실습 및 다음 수업 예제들 예습. 04 13Ajax,Promise 등 통신 수업 및 복습. 04.14StopWatch 등 각종 예제 풀이. 04.15ajax통신 복습 및 stopWatch 보완. 04.18프로젝트 기능구현 공부. 04.20~24프로젝트 기간. 04.26json서버,Promise 등 통신 미비된 부분 복습. 04.27데이타 베이스 설정 및 각종 명령어 실습. 04.28데이터 베이스 문제풀이 04.29데이터 베이스 mysql,mongodb. 04.30mongodb, 데이터 베이스 문제풀이. 05.04React porps,조건부 렌더링. 05.11React Props 및 로그인 실습. 05.12React Recycle 및 실습. 네트워크 운영체제 기초 이론. 05.13React Hook useEffect, useMemo, useCallback, React.memo. 05.14React Use Reducer 05.15React use Reducer 전화번호부. 05.18Rest Api 연동. 05.19React Router. 05.21React Code Splite. 05.23React Todo,Tic 다시 만들어보기. 05.25API를 이용한 연동. 05.28React Redux. 05.31React 복습. 06.01운영체제/네트워크, React Reducer. 06.02React Redux Saga. 06.03React UseReducer 복습. 06.04알고리즘 기본개념. 프로그래머스 1레벨. 06React 복습. 06.07React 복습. 06.08React 총 복습. 06.09React Movie, TypeScript. 06.10Node J.s 06.15알고리즘. 06.16 HTTP,HTTPS 등 네트워크,운영체제. 06.18알고리즘 트리,큐 06.20React 총복습. 06.22프로젝트 계획. 06.23최종 프로젝트 디렉터리 구조, 컴포넌트 네이밍. 06.25최종 프로젝트 기능별 정리,reducer 설계. 06.26최종 프로젝트 기획 발표 자료 준비 (코딩 컨벤션) 06.27최종 프로젝트 준비.(Reducer,Redux 복습). 06.28인증방식(JWT), Styled-components. 07.03최종 프로젝트 Main Header. 07.25알고리즘, React Saga. 07.28React Redux. 07.29React Redux Middle Ware. 07.30Javascript Algorithm. 07.31react State. 08.03Javascript Promise. 08.04Javascript 실행 컨텍스트, Algoritm.","categories":[],"tags":[]},{"title":"수학 상수와 함수를 위한 Math 객체","slug":"js0326","date":"2020-03-25T20:55:30.000Z","updated":"2020-03-30T12:46:04.112Z","comments":true,"path":"2020/03/26/js0326/","link":"","permalink":"https://pkt0831.github.io/2020/03/26/js0326/","excerpt":"","text":"Math Property1.Math.PiPi값 = 3.14… 반환. Math Method1.Math.abs(x: number): number인수의 절댓값 반환. 반드시 0또는 양수이어야 한다. 1234Math.abs(-1); // 1Math.abs('-1'); // 1Math.abs(null); // 0Math.abs(undefined);// NaN 2 Math.round(x: number): number 인수의 소수점 이하를 반올림한 정수 반환. 3 Math.ceil(x: number): number인수의 소수점 이하를 올림한 정수를 반환. 4 Math.floor(x: number): number인수의 소수점 이하를 내림한 정수 반환. 양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환 음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환. 5 Math.sqrt(x: number): number인수의 제곱근 반환. 12Math.sqrt(9); // 3Math.sqrt(-9); // NaN 6 Math.random(): number임의의 부동 소수점 0 ~ 1 미만 반환. 7 Math.pow(x: number, y: number): number첫번째 인수 밑, 두번째 인수를 지수로하여 거듭제곱. 123Math.pow(2, 8); // 256Math.pow(2, -1); // 0.5Math.pow(2); // NaN 8 Math.max(…values: number[]): number인수 중에서 가장 큰 수 반환. 9 Math.min(…values: number[]): number인수 중에서 가장 작은 수 반환. 10.","categories":[],"tags":[]},{"title":"디스트럭처링 할당(Destructuring assignment)","slug":"js0323","date":"2020-03-23T02:55:30.000Z","updated":"2020-03-23T10:40:15.503Z","comments":true,"path":"2020/03/23/js0323/","link":"","permalink":"https://pkt0831.github.io/2020/03/23/js0323/","excerpt":"","text":"디스트럭처링 할당이란? 구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다. 할당 기준은 배열의 인덱스이다. 배열에서 필요한 요소만 추출하여 변수에 할당하고싶을때 유용하다. 객체 디스트럭처링 할당 ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용. ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.","categories":[],"tags":[]},{"title":"스프레드 문법(Spread syntax)","slug":"js0322","date":"2020-03-22T02:55:30.000Z","updated":"2020-03-25T10:02:50.218Z","comments":true,"path":"2020/03/22/js0322/","link":"","permalink":"https://pkt0831.github.io/2020/03/22/js0322/","excerpt":"","text":"스프레드 문법(Spread syntax)이란? 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개, 분산하여, spread) 개별적인 값들의 목록으로 만드는것. 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), Arguments와 같이 for…of 문으로 순회할 수 있는 이터러블에 한정된다. 스프레드 문법 사용 3가지. 함수 호출문의 인수 목록 요소값들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우 배열 리터럴 내부에서 사용 concat:배열 요소들을 새로운 배열의 일부로 만들고 싶은 경우, 배열 리터럴 만으로 해결할 수 없고 concat 메소드를 사용해야 한다. push: 12345678// ES6const arr1 = [1, 2];const arr2 = [3, 4];// arr1.push(3, 4)와 같다.arr1.push(...arr2);console.log(arr1); // [1, 2, 3, 4] splice : 기존의 배열에 다른 배열의 요소들을 삽입. slice: 기존의 배열을 복사. 유사 배열 객체를 배열로 변환 : slice 메소드를 apply 함수로 호출한다.123456789// ES6function sum() &#123; // 유사 배열 객체인 arguments를 배열로 변환 const args = [...arguments]; return args.reduce((pre, cur) =&gt; pre + cur, 0);&#125;console.log(sum(1, 2, 3)); // 6 3.객체 리터럴 내부에서 사용","categories":[],"tags":[]},{"title":"배열(array)","slug":"js0320","date":"2020-03-20T02:55:30.000Z","updated":"2020-03-25T10:03:35.897Z","comments":true,"path":"2020/03/20/js0320/","link":"","permalink":"https://pkt0831.github.io/2020/03/20/js0320/","excerpt":"","text":"배열이란? 배열은 여러 개의 값을 순차적으로 나열한 자료 구조이다. 요소에 접근할 때는 대괄호 표기법을 사용한다. 배열은 타입이 아니라 객체이다. 배열은 배열 리터럴 또는 Array 생성자 함수로 생성할 수 있다. 일반 객체와 배열(객체)의 차이점. 일반 객체는 값의 순서,length 프로퍼티가 없지만 배열은 가지고 있다. 따라서 배열은 반복문을 통해 순차적으로 값을 접근하기 적합한 자료구조이다. 자바스크립트의 배열은 일반적인 배열처럼 밀집 배열이 아니라 배열의 요소가 연속적으로 이어져 있지 않는 희소 배열이다. 일반적인 배열과 자바스크립트 배열의 장단점. 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열보다 느리지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다. length 프로퍼티와 희소 배열. length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 정수를 값으로 갖는다. 배열에는 요소를 최대 232 – 1(4,294,967,295)개가질수있다.12// 희소 배열: 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 배열을 희소 배열이라 한다.(만들지 않는게 좋다.)const sparse = [, 2, , 4]; 배열생성하는방법 4가지.1.배열 리터럴. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호([])로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 이름이 없고 값만이 존재한다.12345678const arr = [1, 2, 3];console.log(arr.length); // 3const arr = []; //length 프로퍼티 값이 0인 빈 배열,const arr = [1, , 3]; // 희소 배열// 희소 배열은 length는 배열의 실제 요소 개수보다 언제나 크다.console.log(arr.length); // 3 Array 생성자 함수 1const arr = new Array(10); Array.of 1234 Array.of 메소드는 전달된 인수를 요소로 갖는 배열을 생성// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.const arr1 = Array.of(1);console.log(arr1); // [1] Array.fromArray.from 메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 변환하여 새로운 배열을 생성한다.유사 배열 객체:배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.이터러블 객체: Symbol.iterator 메소드를 구현하여 for…of 문으로 순회할 수 있으며 스프레드 문법의 대상으로 사용할 수 있는 객체를 말한다. 배열 요소의 참조. 배열 요소를 참조할 때에는 대괄호([]) 표기법을 사용한다. 존재하지 않는 요소에 접근하면 undefined가 반환된다.(희소 배열도 마찬가지) 배열 요소의 삭제. 배열 삭제는 delete 연산자로 한다. 희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메소드를 사용한다. 배열 메소드.배열 메소드의 결과물을 반환하는 패턴 2가지.1.원본 배열(배열 메소드를 호출한 배열, 즉 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method).2. 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method). Array.prototype가 제공하는 메소드 중에서 사용 빈도가 높은 메소드들. Array.isArrayArray.isArray는 Array 생성자 함수의 정적 메소드이다.주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다. Array.prototype.indexOf원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다. 중복되는 요소가 있는 경우, 첫번째 인덱스를 반환한다. 해당하는 요소가 없는 경우, -1을 반환한다. 배열에 요소가 있는지 확인할때 쓰인다. Array.prototype.push 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다. Array.prototype.pop 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 빈 배열이면 undefined를 반환한다. Array.prototype.unshift 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다. Array.prototype.shift shift 메소드는 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다. Array.prototype.concat 인수로 전달된 값들(배열 또는 값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. Array.prototype.splice 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는데 쓰인다. Array.prototype.slice 인수로 전달된 범위의 요소들을 복사하여 반환한다. 원본 배열은 변경되지 않는다. Array.prototype.join 원본 배열의 모든 요소를 문자열로 변환한 후, 구분자(separator)로 연결한 문자열을 반환한다.1234const arr = [1, 2, 3, 4];// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환result = arr.join(':');console.log(result); // '1:2:3:4' Array.prototype.reverse 원본 배열의 요소 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다. Array.prototype.fill 인수로 전달 받은 값을 요소로 배열의 처음부터 끝까지 채운다. 이때 원본 배열이 변경된다. Array.prototype.includes 배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다. Array.prototype.flat 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.1console.log([1, [2, 3, 4, 5]].flat()); // [1, 2, 3, 4, 5] 배열 고차 함수. 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다. Array.prototype.sort 배열의 요소를 적절하게(오름차순) 정렬한다. 내림차순으로 바꾸고 싶으면 reverse 메소드 사용. Array.prototype.forEach 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.(for문을 대체하는 함수.) 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다. forEach 메소드 내부에서 this로 사용될 객체를 전달할 수 있다. Array.prototype.map 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.그리고 콜백 함수의 반환값들이 요소로서 추가된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다. map 메소드가 생성하여 반환하는 새로운 배열의 length는 반드시 this의 length와 일치(맵핑)한다. Array.prototype.filter 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다. 콜백 함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다. filter 메소드가 생성하여 반환하는 새로운 배열의 length는 filter 메소드를 호출한 배열, 즉 this의 length와 같거나 작다. Array.prototype.reduce 배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 하나의 결과값을 반환한다. 이때 원본 배열은 변경되지 않는다. 첫번째 인수로 콜백 함수, 두번째 인수로 초기값을 전달 reduce 메소드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, 요소값, 인덱스, reduce 메소드를 호출한 배열, 즉 this가 전달된다. reduce 메소드는 하나의 결과값을 반환한다. Array.prototype.some 배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 하나라도 참이라면 true, 모두 거짓이라면 false를 반환한다. Array.prototype.every 배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 모두 참이라면 true, 하나라도 거짓이라면 false를 반환한다. Array.prototype.find 배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. 참인 요소가 존재하지 않는다면 undefined를 반환한다. Array.prototype.findIndex 배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. 참인 요소가 존재하지 않는다면 -1를 반환한다. Array.prototype.flatMap map을 통해 생성된 새로운 배열을 평탄화한다. 즉, map 메소드와 flat 메소드를 순차적으로 실행한다. 평탄화 깊이를 지정할 수는 없고 1단계만 평탄화한다.","categories":[],"tags":[]},{"title":"실행 컨텍스트(Execution context)","slug":"js0316","date":"2020-03-16T02:55:30.000Z","updated":"2020-05-04T12:33:25.772Z","comments":true,"path":"2020/03/16/js0316/","link":"","permalink":"https://pkt0831.github.io/2020/03/16/js0316/","excerpt":"","text":"1.소스 코드의 타입.4가지 타입으로 구분하는데 이유는 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.1.전역 코드: 전역에 존재하는 소스 코드. 전역에 정의된 함수,클래스 등의 내부 코드는 포함되지 않는다. 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야한다.var 키워드로 선언된 전역 변수, 함수 선언문으로 정의돈 전역 함수 전역 객체의 프로퍼티와 메소드로 바인딩하고 참조하기 위해 전여 객체와 연결되어야한다.전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.2.함수 코드:함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.함수 코드는 지역 스코프를 생성하고 지역 변수와 매개 변수를 관리.생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.eval 코드:빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드.엄격 모드(strict mode)에서 자신만의 독자적인 스코프를 생성하고, eval 코드가 평가되면 eval 실행 컨텍스트가 생성.모듈 코드: 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.모듈 별로 독립적인 스코프를 생성.모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성.2. 소스 코드의 평가와 실행소스 코드를 2개의 과정, 즉 소스 코드의 평가와 소스 코드의 실행.소스 코드 평과 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문 만을 먼저 실행 생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.평가 과정이 끝나면 비로소 선언문을 제외한 소스 코드가 순차적으로 실행.소스 코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득.변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.-소스코드1- 실행 컨텍스트의 역할 전역 코드 평가1-1.전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드 실행을 위한 준비.1-2. 평가 과정에서는 선언문 만을 먼저 실행1-3. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록1-4. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 전역 객체의 프로퍼티와 메소드가 된다. 전역 코드 실행2-1. 평가가 끝나면 전역 코드가 순차적으로 실행.2-2. 전역 변수에 값이 할당되고 함수가 호출2-3. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다. 함수 코드 평가3-1. 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정, 함수 코드 실행을 위한 준비3-2.매개 변수와 지역 변수 선언문이 먼저 실행되고 그 결과 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록3-3.함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록. 함수 코드 실행4-1.함수 코드의 평가가 끝나면 함수 코드가 순차적으로 실행.이때 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다.4-2.console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색.함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다.식별자 console은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재.전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프에서 검색 가능해야 한다는 것을 의미.4-3. log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색.4-4. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가4-5. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가.4-6. console.log 메소드의 실행이 종료되면 함수 코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다. 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.함수 호출이 종료하면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리.이처럼 코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. 1.선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.2.스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.3.현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다. -실행 컨텍스트(Execution context)는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. -실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.-식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다 실행 컨텍스트 스택.12345678910111213const x = 1;function foo () &#123; const y = 2; function bar () &#123; const z = 3; console.log(x + y + z); &#125; bar();&#125;foo(); // 6 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 이를 실행 컨텍스트 스택(Execution context stack)라고 부른다.실행 컨텍스트 스택을 콜 스택(Call stack)이라고 부르기도 한다.","categories":[],"tags":[]},{"title":"this","slug":"js0315-2","date":"2020-03-15T02:55:30.000Z","updated":"2020-03-15T16:11:05.017Z","comments":true,"path":"2020/03/15/js0315-2/","link":"","permalink":"https://pkt0831.github.io/2020/03/15/js0315-2/","excerpt":"","text":"this 키워드객체는 상태를 나타내느 프로퍼티와 동작을 나타내는 메소드를 하나의 논리적인 단위로 묶은것인데, this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다.this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 코드 어디에서든지 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 함수 호출 방식과 this 바인딩this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. this에 바인딩될 객체는 함수 호출 시점에 결정된다. 함수를 호출하는 4가지 방식.1.일반 함수 호출2.메소드 호출3.생성자 함수 호출4.Function.prototype.apply/call/bind 메소드에 의한 간접 호출 123456789101112131415161718192021222324252627282930// this에 바인딩될 객체는 함수 호출 방식에 따라 동적으로 결정된다.const foo = function () &#123; console.dir(this);&#125;;// 동일한 함수도 다양한 방식으로 호출할 수 있다.// 1. 일반 함수 호출// foo 함수를 일반적인 방식으로 호출// this는 전역 객체 window를 가리킨다.foo(); // window// 2. 메소드 호출// foo 함수를 프로퍼티의 값으로 할당하여 호출// this는 메소드를 호출한 객체 obj를 가리킨다.const obj = &#123; foo &#125;;obj.foo(); // obj// 3. 생성자 함수 호출// foo 함수를 new 연산자와 함께 생성자 함수로 호출// this는 생성자 함수가 생성한 인스턴스를 가리킨다.new foo(); // foo &#123;&#125;// 4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출// this는 인수에 의해 결정된다.const bar = &#123; name: 'bar' &#125;;foo.call(bar); // barfoo.apply(bar); // barfoo.bind(bar)(); // bar 2.1. 일반 함수 호출기본적으로 this에는 전역 객체(Global object)가 바인딩된다. 123456789function foo() &#123; console.log(\"foo's this: \", this); // window function bar() &#123; console.log(\"bar's this: \", this); // window &#125; bar();&#125;foo();전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다. 1234567891011객체를 생성하지 않는 일반 함수에서 this는 의미가 없기 때문에 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.function foo() &#123; 'use strict'; console.log(\"foo's this: \", this); // undefined function bar() &#123; console.log(\"bar's this: \", this); // undefined &#125; bar();&#125;foo(); 12345678910111213141516171819202122// var 키워드로 선언한 변수 value는 전역 객체의 프로퍼티이다.var value = 1;// const 키워드로 선언한 변수 value는 전역 객체의 프로퍼티가 아니다.// const value = 1;const obj = &#123; value: 100, foo() &#123; console.log(\"foo's this: \", this); // &#123;value: 100, foo: ƒ&#125; console.log(\"foo's this.value: \", this.value); // 100 // 메소드 내에서 정의한 중첩 함수 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 &#125; // 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 // 중첩 함수 내부의 this에는 전역 객체가 바인딩된다. bar(); &#125;&#125;; 12345678910111213141516콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다.var value = 1;const obj = &#123; value: 100, foo() &#123; console.log(\"foo's this: \", this); // &#123;value: 100, foo: ƒ&#125; // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다. setTimeout(function () &#123; console.log(\"callback's this: \", this); // window console.log(\"callback's this.value: \", this.value); // 1 &#125;, 100); &#125;&#125;;obj.foo(); 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 2.2. 메소드 호출메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체에 바인딩된다. 12345678910const person = &#123; name: 'Lee', getName() &#123; // 메소드의 this는 메소드를 호출한 객체에 바인딩된다. return this.name; &#125;&#125;;// 메소드 getName을 호출한 객체는 person이다.console.log(person.getName()); 1234567891011메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다.const person = &#123; name: 'Lee', getName() &#123; // 메소드의 this는 메소드를 호출한 객체에 바인딩된다. return this.name; &#125;&#125;;// 메소드 getName을 호출한 객체는 person이다.console.log(person.getName()); // Lee 2.3. 생성자 함수 호출생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다. 1234567891011121314151617// 생성자 함수function Circle(radius) &#123; // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스의 생성// 반지름이 5인 Circle 객체를 생성const circle1 = new Circle(5);// 반지름이 10인 Circle 객체를 생성const circle2 = new Circle(10);console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 2.4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply와 call 메소드는 Function.prototype의 메소드이다. 즉, apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다. apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.","categories":[],"tags":[]},{"title":"ES6 함수의 추가 기능","slug":"js03-19","date":"2020-03-15T02:55:30.000Z","updated":"2020-03-19T14:52:35.219Z","comments":true,"path":"2020/03/15/js03-19/","link":"","permalink":"https://pkt0831.github.io/2020/03/15/js03-19/","excerpt":"","text":"함수의 구분.-함수는 일반적인 함수로서 호출,new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출, 객체에 바인딩되어 메소드로서 호출이 있다.-호출할 수 있는 함수 객체를 callable,인스턴스를 생성할 수 있는 함수 객체를 constructor, 인스턴스를 생성할 수 없는 함수 객체를 있는 non-constructor라고 부른다.-일반 함수는 constructor이지만 ES6의 메소드와 화살표 함수는 non-constructor이다. 메소드-ES6 사양에서 메소드는 메소드 축약 표현으로 정의된 함수 만을 의미한다.-메소드(이하 ES6 메소드)는 인스턴스를 생성할 없는 non-constructor이다. 따라서 ES6 메소드는 생성자 함수로서 호출할 수 없다.-ES6 메소드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다. 표준 빌드인 객체의 메소드는 모두 non-constructor이다. ES6 메소드는 메소드가 바인딩된 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖고있는데 이러한 매소들만이 super키워드를 사용할 수 있다. 화살표 함수.function 키워드 대신 화살표(=&gt;, fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의하는 방법. 내부 동작도 기존의 함수보다 간략하다. 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다. 화살표 함수 정의매개 변수가 여러 개인 경우, 소괄호 () 안에 매개 변수를 선언.매개 변수가 한 개인 경우, 소괄호 ()를 생략할 수 있다.매개 변수가 없는 경우, 소괄호 ()를 생략할 수 없다.","categories":[],"tags":[]},{"title":"빌트인 객체(built-in objects)","slug":"js0315-1","date":"2020-03-15T02:35:30.000Z","updated":"2020-05-04T12:33:21.732Z","comments":true,"path":"2020/03/15/js0315-1/","link":"","permalink":"https://pkt0831.github.io/2020/03/15/js0315-1/","excerpt":"","text":"1.자바스크립트 객체는 3가지로 분류된다.-표준 빌트인 객체표준 빌트인 객체(standard built-in objects / native objects / global objects) ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다.표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 별도 선언없이 전역 변수처럼 참조 가능하다.-호스트 객체 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경 에서 추가적으로 제공하는 객체를 말한다.-사용자 정의 객체기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체.2. 표준 빌트인 객체Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array 등 40여개의 표준 빌트인 객체를 제공한다.Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다.표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출하여 인스턴스를 생성할 수 있다 12345678910111213141516171819202122232425262728293031323334// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String &#123;\"Lee\"&#125;// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(123);console.log(typeof numObj); // objectconsole.log(numObj); // Number &#123;123&#125;// Boolean 생성자 함수에 의한 Boolean 객체 생성const boolObj= new Boolean(true);console.log(typeof boolObj); // objectconsole.log(boolObj); // Boolean &#123;true&#125;// Function 생성자 함수에 의한 Function 객체(함수) 생성const func = new Function('x', 'return x * x');console.log(typeof func); // functionconsole.dir(func); // ƒ anonymous(x )// Array 생성자 함수에 의한 Array 객체(배열) 생성const arr = new Array(1, 2, 3);console.log(typeof arr); // objectconsole.log(arr); // (3) [1, 2, 3]// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성const regExp = new RegExp(/ab+c/i);console.log(typeof regExp); // objectconsole.log(regExp); // /ab+c/i// Date 생성자 함수에 의한 Date 객체 생성const date = new Date();console.log(typeof date); // objectconsole.log(date); // Tue Mar 19 2019 02:38:26 GMT+0900 (한국 표준시) 3.원시값과 래퍼 객체 중요!원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다. 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체(wrapper object)라 한다. 전역 객체전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다.전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array…)들과 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API) 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.전역 객체는 계층적 구조 상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체와 호스트 객체)의 최상위 객체이다.최상위 객체라는 의미가 아니고 객체의 계층적 구조 상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다. -전역 객체의 특징.-전역 객체는 개발자가 의도적으로 생성할 수 없다.-전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.-전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.-자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖는다. 브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.-var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.-let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.-브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리하여도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미이다.4.1 빌트인 전역 프로퍼티빌트인 전역 프로퍼티(Built-in global property)는 전역 객체의 프로퍼티를 의미한다.4.1.1. InfinityInfinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.4.1.2. NaNNaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다.4.1.3. undefinedundefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.4.2. 빌트인 전역 함수빌트인 전역 함수(Built-in global function)는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다.4.2.1. eval문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다. 123456/** * 주어진 코드를 런타임 평가하고 실행하여 결과값을 반환한다. * @param &#123;string&#125; code - 코드를 나타내는 문자열 * @returns &#123;*&#125; 문자열 코드를 평가/실행한 결과값 */eval(code) 4.2.2. isFinite매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 123456/** * 주어진 숫자가 유한수인지 확인하고 그 결과를 반환한다. * @param &#123;number&#125; testValue - 검사 대상 값 * @returns &#123;boolean&#125; 유한수 여부 확인 결과값 */isFinite(testValue) 4.2.3. isNaN매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 123456/** * 주어진 숫자가 NaN인지 확인하고 그 결과를 반환한다. * @param &#123;number&#125; testValue - 검사 대상 값 * @returns &#123;boolean&#125; NaN 여부 확인 결과값 */isNaN(testValue) 4.2.4. parseFloat 1234567매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다./** * 주어진 문자열을 부동소수점 숫자로 변환하여 반환한다. * @param &#123;string&#125; string - 변환 대상 값 * @returns &#123;number&#125; 변환 결과값 */parseFloat(string) 4.2.5. parseInt매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다. 12345678/** * 주어진 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. * 반환값은 언제나 10진수이다. * @param &#123;string&#125; string - 변환 대상 값 * @param &#123;number&#125; [radix] - 진법을 나타내는 기수(2 ~ 36, 기본값 10) * @returns &#123;number&#125; 변환 결과값 */parseInt(string, radix); 4.2.6. encodeURI / decodeURI 이건 나중에 ….encodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다. URI의 하위개념으로 URL, URN이 있다.4.2.7. encodeURIComponent / decodeURIComponentencodeURIComponent 함수는 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 단, 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) 문자는 이스케이프 처리에서 제외된다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다. 4.3. 암묵적 전역전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작하는 현상을 암묵적 전역(implicit global)이라 한다.","categories":[],"tags":[]},{"title":"엄격 모드(strict mode)","slug":"js0314","date":"2020-03-14T02:35:30.000Z","updated":"2020-05-04T12:33:20.082Z","comments":true,"path":"2020/03/14/js0314/","link":"","permalink":"https://pkt0831.github.io/2020/03/14/js0314/","excerpt":"","text":"strict mode란?strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. strict mode의 적용12345 'use strict'; //함수 몸체 선두에 'use strict';를 추가하면 스크립트 전체에 strict mode가 적용된다.function foo() &#123; x = 10; // ReferenceError: x is not defined&#125;foo(); 123456function foo() &#123; //함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 strict mode가 적용된다. 'use strict'; x = 10; // ReferenceError: x is not defined&#125;foo(); 12345function foo() &#123; //코드의 선두에 strict mode를 위치시키지 않으면 제대로 동작하지 않는다. x = 10; // 에러를 발생시키지 않는다. 'use strict';&#125;foo(); 전역에 strict mode를 적용하는 것은 피하자.전역에 적용한 strict mode는 스크립트 단위로 적용되어 다른 스크립트엔 영향을 주지않고 자신의 스크립트에 한정되어 적용되기때문에 다른 스크립트는 래퍼런스 에러가난다.대신, 즉시 실행 함수로 스크립트 전체를 감사써 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다. 123456// 즉시 실행 함수의 선두에 strict mode 적용(function () &#123; 'use strict'; // Do something...&#125;()); 함수 단위로 strict mode를 적용하는 것도 피하자.모든 함수에 일일이 strict mode를 적용하는 것은 번거로운 일이기에 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다. 1234567891011(function () &#123; // non-strict mode var lеt = 10; // 에러가 발생하지 않는다. function foo() &#123; 'use strict'; let = 20; // SyntaxError: Unexpected strict mode reserved word &#125; foo();&#125;()); strict mode가 발생시키는 에러 암묵적 전역1234567선언하지 않은 변수를 참조하면 ReferenceError가 발생한다.(function () &#123; 'use strict'; x = 1; console.log(x); // ReferenceError: x is not defined&#125;()); 변수, 함수, 매개변수의 삭제delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다. 매개변수 이름의 중복중복된 함수 매개변수 이름을 사용하면 SyntaxError가 발생한다. with 문의 사용with 문을 사용하면 SyntaxError가 발생한다. strict mode 적용에 의한 변화 일반 함수의 thisstrict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다. 이때 에러는 발생하지 않는다.12345678910111213(function () &#123; 'use strict'; function foo() &#123; console.log(this); // undefined &#125; foo(); function Foo() &#123; console.log(this); // Foo &#125; new Foo();&#125;()); arguments 객체strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.12345678(function (a) &#123; 'use strict'; // 매개변수에 전달된 인수를 재할당하여 변경 a = 2; // 변경된 인수가 arguments 객체에 반영되지 않는다. console.log(arguments); // &#123; 0: 1, length: 1 &#125;&#125;(1));","categories":[],"tags":[]},{"title":"프로토 타입(Prototype)","slug":"js0308-5","date":"2020-03-08T02:35:30.000Z","updated":"2020-05-04T12:33:18.226Z","comments":true,"path":"2020/03/08/js0308-5/","link":"","permalink":"https://pkt0831.github.io/2020/03/08/js0308-5/","excerpt":"","text":"앞부분이 중요.함수는 런타임 이전에 생성되고, 그와 동시에 프로토타입이 생성된다. 객체지향 프로그래밍객체란 원시 타입의 값을 제외한 자바스크립트를 이루고 있는 거의 모든 것들이다. 또한 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조 또한 객체라고 한다.객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(Imperative programming)의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다. 객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조라고 할 수 있다. 객체의 상태 데이터를 프로퍼티(property), 동작을 메소드(method)라 부른다. 상속과 프로토타입 상속(Inheritance)은 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. 1234567891011121314151617181920212223// 생성자 함수function Circle(radius) &#123; this.radius = radius; this.getArea = function () &#123; // Math.PI는 원주율을 나타내는 상수이다. // Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다. return Math.PI * Math.pow(this.radius, 2); &#125;;&#125;// 인스턴스 생성// 반지름이 1인 인스턴스 생성const circle1 = new Circle(1);// 반지름이 2인 인스턴스 생성const circle2 = new Circle(2);// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는// getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.// 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.console.log(circle1.getArea === circle2.getArea); // falseconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 프로토타입을 기반으로 상속을 구현한다. 12345678910111213141516171819202122// 생성자 함수function Circle(radius) &#123; this.radius = radius;&#125;// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.Circle.prototype.getArea = function () &#123; return Math.PI * Math.pow(this.radius, 2);&#125;;// 인스턴스 생성const circle1 = new Circle(1);const circle2 = new Circle(2);// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.console.log(circle1.getArea === circle2.getArea); // trueconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 -1- 프로토타입 객체 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드 포함)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 즉, 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정되고 [[prototype]]에 저장된다.모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 null이거나 객체이다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다. 3.1. proto 접근자 프로퍼티모든 객체는 proto 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다. 3.2. 함수 객체의 prototype 프로퍼티 함수 객체는 proto 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다. 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function () &#123;&#125;).hasOwnProperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log(&#123;&#125;.hasOwnProperty('prototype')); // false 모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype로부터 상속받은) proto 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 3.3. 프로토타입의 constructor 프로퍼티와 생성자 함수 모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다. 123456789// 생성자 함수function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// me 객체의 생성자 함수는 Person이다.console.log(me.constructor === Person); // true r 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 123456789101112// obj 객체를 생성한 생성자 함수는 Object이다.const obj = new Object();// add 함수 객체를 생성한 생성자 함수는 Function이다.const add = new Function('a', 'b', 'return a + b');// 생성자 함수function Person(name) &#123; this.name = name;&#125;// me 객체를 생성한 생성자 함수는 Person이다.const me = new Person('Lee'); 1234567891011// 객체 리터럴const obj = &#123;&#125;;// 함수 리터럴const add = function (a, b) &#123; return a + b; &#125;;// 배열 리터럴const arr = [1, 2, 3];// 정규표현식 리터럴const regexr = /is/ig; 프로토타입의 생성 시점 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다.프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 5.1. 사용자 정의 생성자 함수와 프로토타입 생성 시점화살표 함수나 ES6의 메소드 축약 표현으로 정의하지 않고 일반 함수(함수 선언문, 함수 표현식)로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있다. 1234567// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.console.log(Person.prototype); // &#123;constructor: ƒ&#125;// 생성자 함수function Person(name) &#123; this.name = name;&#125; 1234567// 화살표 함수는 non-constructor이다.const Person = name =&gt; &#123; this.name = name;&#125;;// non-constructor는 프로토타입이 생성되지 않는다.console.log(Person.prototype); // undefined 5.2. 빌트인 생성자 함수와 프로토타입 생성 시점Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 전역 객체는 누구보다도 먼저 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다. 객체 생성 방식과 프로토타입의 결정 객체는 아래와 같이 다양한 생성 방법이 있다. -객체 리터럴-Object 생성자 함수-생성자 함수-Object.create 메소드-클래스 (ES6) 위 5가지는 추상연산에 생성된다는 공통점이 있다. 프로토타입은 추상 연산 ObjectCreate에 전달되는 인수(proto)에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다. 6.1. 객체 리터럴에 의해 생성된 객체의 프로토타입객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다.이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다. 1const obj = &#123; x: 1 &#125;; 객체 리터럴이 평가되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 이처럼 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. obj 객체는 constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유하지 않지만 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 이는 obj 객체가 자신의 프로토타입인 Object.prototype 객체를 상속받았기 때문이다. 6.2. Object 생성자 함수에 의해 생성된 객체의 프로토타입 명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다 12 const obj = new Object();obj.x = 1;위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는 것을 알 수 있다. 6.3. 생성자 함수에 의해 생성된 객체의 프로토타입 ew 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 12345function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee'); 위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 생성된 객체 사이에 연결이 만들어 진다. 프로토타입 체인 12345678910111213function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;const me = new Person('Lee');// hasOwnProperty는 Object.prototype의 메소드이다.console.log(me.hasOwnProperty('name')); // true Person 생성자 함수에 의해 생성된 me 객체는 Object.prototype의 메소드인 hasOwnProperty를 호출할 수 있다. 이것은 me 객체가 Person.prototype 뿐만 아니라 Object.prototype도 상속받았다는 의미이다. me 객체의 프로토타입은 Person.prototype이다. 1234console.log(Object.getPrototypeOf(me) === Person.prototype); // truePerson.prototype의 프로토타입은 Object.prototype이다. 프로토타입의 프로토타입은 언제나 Object.prototype이다.console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 proto 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. 캡슐화캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것을 말한다.12345678910111213141516const Person = (function () &#123; // 생성자 함수 function Person(name) &#123; this.name = name; &#125; // 프로토타입 메소드 Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;; // 생성자 함수를 반환 return Person;&#125;());const me = new Person('Lee'); 오버라이딩과 프로퍼티 쉐도잉123456789101112131415161718192021222324const Person = (function () &#123; // 생성자 함수 function Person(name) &#123; this.name = name; &#125; // 프로토타입 메소드 Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;; // 생성자 함수를 반환 return Person;&#125;());const me = new Person('Lee');// 인스턴스 메소드me.sayHello = function () &#123; console.log(`Hey! My name is $&#123;this.name&#125;`);&#125;;// 인스턴스 메소드가 호출된다. 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다.me.sayHello(); // Hey! My name is Lee 123456789// 프로토타입 메소드 변경Person.prototype.sayHello = function () &#123; console.log(`Hey! My name is $&#123;this.name&#125;`);&#125;;me.sayHello(); // Hey! My name is Lee// 프로토타입 메소드 삭제delete Person.prototype.sayHello;me.sayHello(); // TypeError: me.sayHello is not a function 프로토타입의 교체 프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 10.1. 생성자 함수에 의한 프로토타입의 교체 12345678910111213141516const Person = (function () &#123; function Person(name) &#123; this.name = name; &#125; // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = &#123; sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; &#125;; return Person;&#125;());const me = new Person('Lee'); ①에서 Person.prototype에 객체 리터럴을 할당하였다. 이는 Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것이다. 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. 따라서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다. 1234// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.console.log(me.constructor === Person); // false// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.console.log(me.constructor === Object); // true 10.2. 인스턴스에 의한 프로토타입의 교체인스턴스의 proto 접근자 프로퍼티(또는 Object.setPrototypeOf 메소드)를 통해 프로토타입을 교체할 수 있다. instanceof 연산자 instanceof 연산자는 이항 연산자로서 좌변에 객체를 가기키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다. instanceof 연산자는 상속 관계를 고려한다.12. 직접 상속12.1 Object.create에 의한 직접 상속Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. 1234567/** * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환한다. * @param &#123;Object&#125; prototype - 생성할 객체의 프로토타입으로 지정할 객체 * @param &#123;Object&#125; [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체 * @returns &#123;Object&#125; 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체 */Object.create(prototype[, propertiesObject]) // 12345678910111213141516171819202122232425262728293031323334353637383940414243// 프로토타입이 null인 객체를 생성한다.// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.// obj → nulllet obj = Object.create(null);console.log(Object.getPrototypeOf(obj) === null); // true// Object.prototype를 상속받지 못한다.console.log(obj.toString()); // TypeError: obj.toString is not a function// obj = &#123;&#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype);console.log(Object.getPrototypeOf(obj) === Object.prototype); // true// obj = &#123; x: 1 &#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype, &#123; x: &#123; value: 1 &#125;&#125;);// 위 코드는 아래와 동일하다.// obj = Object.create(Object.prototype);// obj.x = 1;console.log(obj.x); // 1console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueconst myProto = &#123; x: 10 &#125;;// 객체를 직접 상속받는다.// obj → myProto → Object.prototype → nullobj = Object.create(myProto);console.log(obj.x); // 10console.log(Object.getPrototypeOf(obj) === myProto); // true// 생성자 함수function Person(name) &#123; this.name = name;&#125;// obj = new Person('Lee')와 동일하다.// obj → Person.prototype → Object.prototype → nullobj = Object.create(Person.prototype);obj.name = 'Lee';console.log(obj.name); // Leeconsole.log(Object.getPrototypeOf(obj) === Person.prototype); // true 이처럼 Object.create 메소드는 첫번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 즉, 객체를 생성하면서 직접적으로 상속을 구현하는 것이다. 이 메소드의 장점은 아래와 같다. new 연산자가 없이도 객체를 생성할 수 있다.객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.프로토타입을 지정하면서 객체를 생성할 수 있다.12.2 객체 리터럴 내부에서 proto에 의한 직접 상속객체 리터럴 내부에서 proto 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다. 1234567891011121314const myProto = &#123; x: 10 &#125;;// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.const obj = &#123; y: 20, // 객체를 직접 상속받는다. // obj → myProto → Object.prototype → null __proto__: myProto 알아두기!. __proto__를 프로퍼티키로 씀&#125;;// 위 코드는 아래와 동일하다.// const obj = Object.create(myProto, &#123; y: &#123; value: 20 &#125; &#125;);console.log(obj.x, obj.y); // 10 20console.log(Object.getPrototypeOf(obj) === myProto); // true 정적 프로퍼티/메소드정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. 1234567891011121314151617181920212223242526// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;// Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다.// 정적 프로퍼티 Person.staticProp = 'static prop';// 정적 메소드Person.staticMethod = function () &#123; console.log('staticMethod');&#125;;const me = new Person('Lee');// 생성자 함수에 추가한 정적 프로퍼티/메소드는 생성자 함수로 참조/호출한다.Person.staticMethod(); // staticMethod// 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.// 인스턴스로 참조/호출할 수 있는 프로퍼티/메소드는 프로토타입 체인 상에 존재해야 한다.me.staticMethod(); // TypeError: me.staticMethod is not a function Object.prototype.hasOwnproperty () 프로토타입 메소드 나열. 프로퍼티 존재 확인1234567891011const person = &#123; name: 'Lee', address: 'Seoul'&#125;;// person 객체에 name 프로퍼티가 존재한다.console.log('name' in person); // true// person 객체에 address 프로퍼티가 존재한다.console.log('address' in person); // true// person 객체에 age 프로퍼티가 존재하지 않는다.console.log('age' in person); // false 프로퍼티 열거 1 for…in 문객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다.12345678910111213const person = &#123; name: 'Lee', address: 'Seoul', __proto__: &#123; age: 20 &#125;&#125;;for (const key in person) &#123; // 객체 자신의 프로퍼티인지 확인한다. if (!person.hasOwnProperty(key)) continue; console.log(key + ': ' + person[key]);&#125;// name: Lee// address: Seoul Object.keys/values/entries 메소드객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.","categories":[],"tags":[]},{"title":"함수와 일급 객체","slug":"js0308-4","date":"2020-03-08T02:24:30.000Z","updated":"2020-03-11T10:25:02.920Z","comments":true,"path":"2020/03/08/js0308-4/","link":"","permalink":"https://pkt0831.github.io/2020/03/08/js0308-4/","excerpt":"","text":"일급 객체아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다. 1.무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.2.변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.3.함수의 매개 변수에게 전달할 수 있다.4.함수의 결과값으로 반환할 수 있다.자바스크립트의 함수는 아래 예제와 같이 위의 조건을 모두 만족하므로 일급 객체이다. 1234567891011121314151617181920212223242526272829303132333435읽어보기만 이해안도됨.// 1. 함수는 무명의 리터럴로 생성할 수 있다.// 2. 함수는 변수에 저장할 수 있다.// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.const increase = function (num) &#123; return ++num;&#125;;const decrease = function (num) &#123; return --num;&#125;;// 2. 함수는 객체에 저장할 수 있다.const predicates = &#123; increase, decrease &#125;;// 3. 함수의 매개 변수에게 전달할 수 있다.// 4. 함수의 반환값으로 사용할 수 있다.function makeCounter(predicate) &#123; let num = 0; return function () &#123; num = predicate(num); return num; &#125;;&#125;// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const increaser = makeCounter(predicates.increase);console.log(increaser()); // 1console.log(increaser()); // 2// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const decreaser = makeCounter(predicates.decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 함수 일급 객체 = 객체와 동일.객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임(runtime)에 함수 객체로 평가된다. 함수 객체의 프로퍼티일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다.arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티이다. 2.1 arguments 프로퍼티함수 객체의 arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다. 자바스크립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. 123456789function multiply(x, y) &#123; console.log(arguments); return x * y; //x,y는 undefined&#125;console.log(multiply()); // NaNconsole.log(multiply(1)); // NaNconsole.log(multiply(1, 2)); // 2console.log(multiply(1, 2, 3)); // 2 함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다. arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다. 1234567891011121314function sum() &#123; let res = 0; // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다. for (let i = 0; i &lt; arguments.length; i++) &#123; res += arguments[i]; &#125; return res;&#125;console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 2.2. caller 프로퍼티 caller 프로퍼티는 ECMAScript 스펙에 포함되지 않은 비표준 프로퍼티이다. 알아두기만 하자.함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다. 2.3. length 프로퍼티함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다. 123456789101112function foo() &#123;&#125;console.log(foo.length); // 0function bar(x) &#123; return x;&#125;console.log(bar.length); // 1function baz(x, y) &#123; return x * y;&#125;console.log(baz.length); // 2 2.4. name 프로퍼티함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.name 프로퍼티는 ES5와 ES6에서 동작을 달리 하므로 주의하기 바란다. 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. 하지만 ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다. 2.5. proto 접근자 프로퍼티모든 객체는 [Prototype]이라는 내부 슬롯을 갖는다.(내부슬롯은 자신의 부모역할을 하는 객체를 가리킨다.그것을 프로토타입 객체라고 부른다.) [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.proto (자신의 부모 프로퍼티 객체를 가리킨다.)프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 proto 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다. 123456789const obj = &#123; a: 1 &#125;;// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.console.log(obj.__proto__ === Object.prototype); // true// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.// hasOwnProperty 메소드는 Object.prototype의 메소드이다.console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.hasOwnProperty('__proto__')); // false 2.6. prototype 프로퍼티prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function() &#123;&#125;).hasOwnProperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log((&#123;&#125;).hasOwnProperty('prototype')); // false prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.","categories":[],"tags":[]},{"title":"생성자 함수에 의한 객체 생성","slug":"js0308-3","date":"2020-03-08T02:22:30.000Z","updated":"2020-03-11T05:44:58.394Z","comments":true,"path":"2020/03/08/js0308-3/","link":"","permalink":"https://pkt0831.github.io/2020/03/08/js0308-3/","excerpt":"","text":"Object 생성자 함수new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.객체 리터럴로 만드는건 고유한 하나의 객체로 만들때,생성자 함수로 객체를 만드는건 하나의 프로퍼티를 여러개의 객체로 만들기위해서 씀.빌트인 생성자 함수? 1234567891011// 빈 객체의 생성const person = new Object();// 프로퍼티 추가person.name = 'Lee';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;;console.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125;person.sayHello(); // Hi! My name is Lee 생성자(constructor) 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다. 생성자 함수 객체 리터럴에 의한 객체 생성 방식의 문제점 객체 리터럴에 의해 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다. 1234567891011121314151617const circle1 = &#123; radius: 5, getDiameter() &#123; return 2 * this.radius; &#125;&#125;;console.log(circle1.getDiameter()); // 10const circle2 = &#123; radius: 10, getDiameter() &#123; return 2 * this.radius; &#125;&#125;;console.log(circle2.getDiameter()); // 20 12345678910111213141516171819202122232425262728293031323334// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String &#123;\"Lee\"&#125;// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(123);console.log(typeof numObj); // objectconsole.log(numObj); // Number &#123;123&#125;// Boolean 생성자 함수에 의한 Boolean 객체 생성const boolObj= new Boolean(true);console.log(typeof boolObj); // objectconsole.log(boolObj); // Boolean &#123;true&#125;// Function 생성자 함수에 의한 Function 객체(함수) 생성const func = new Function('x', 'return x * x');console.log(typeof func); // functionconsole.dir(func); // ƒ anonymous(x)// Array 생성자 함수에 의한 Array 객체(배열) 생성const arr = new Array(1, 2, 3);console.log(typeof arr); // objectconsole.log(arr); // [1, 2, 3]// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성const regExp = new RegExp(/ab+c/i);console.log(typeof regExp); // objectconsole.log(regExp); // /ab+c/i// Date 생성자 함수에 의한 Date 객체 생성const date = new Date();console.log(typeof date); // objectconsole.log(date); // Fri Feb 14 2020 17:17:59 GMT+0900 (대한민국 표준시) 2.2. 생성자 함수에 의한 객체 생성 방식의 장점생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 123456789101112131415// 생성자 함수function Circle(radius) &#123; // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. //객체 리터럴로 만든건 인스턴스 x 객체라고부름., 생성자 함수나 클래스로 만든게 인스턴스라고 부른다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.//여긴 암기.함수 호출 방식 this가 가리키는 값일반 함수로서 호출 전역 객체메소드로서 호출 메소드를 호출한 객체생성자 함수로서 호출 생성자 함수가 (미래에) 생성할 인스턴스 123456789101112131415// 함수는 다양한 방식으로 호출될 수 있다.function foo() &#123; console.log(this);&#125;// 일반적인 함수로서 호출// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.foo(); // window// 메소드로서 호출const obj = &#123; foo &#125;; // ES6 프로퍼티 축약 표현obj.foo(); // obj// 생성자 함수로서 호출const inst = new foo(); // inst 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다. 하지만 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다. 123456789// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.// 즉, 일반적인 함수의 호출이다.const circle3 = Circle(15);// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.console.log(circle3); // undefined// 일반 함수 Circle내의 this는 전역 객체를 가리킨다.console.log(radius); // 15 2.3. 내부 메소드 [[Call]]과 [[Construct]]함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 즉, 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다. 123456789101112// 함수는 객체이다.function foo() &#123;&#125;// 함수는 객체이므로 프로퍼티를 소유할 수 있다.foo.prop = 10;// 함수는 객체이므로 메소드를 소유할 수 있다.foo.method = function () &#123; console.log(this.prop);&#125;;foo.method(); // 10 2.4. constructor와 non-constructor의 구분자바스크립트 엔진은 함수를 생성할 때, FunctionCreate이라는 추상 연산(abstract operation)을 사용한다.추상 연산 FunctionCreate는 함수 정의가 평가될 때 호출된다. 12345678910111213141516171819202122232425&#x2F;&#x2F; 일반 함수 정의 : kind &#x3D; &#39;Normal&#39;function foo() &#123;&#125;const bar &#x3D; function () &#123;&#125;;&#x2F;&#x2F; 프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.const baz &#x3D; &#123; x: function () &#123;&#125;&#125;;&#x2F;&#x2F; 일반 함수로 정의된 함수만이 constructor이다.new foo(); &#x2F;&#x2F; OKnew bar(); &#x2F;&#x2F; OKnew baz.x(); &#x2F;&#x2F; OK&#x2F;&#x2F; 화살표 함수 정의 : kind &#x3D; &#39;Arrow&#39; const arrow &#x3D; () &#x3D;&gt; &#123;&#125;;new arrow(); &#x2F;&#x2F; TypeError: arrow is not a constructor&#x2F;&#x2F; 메소드 정의 : kind &#x3D; &#39;Method&#39;&#x2F;&#x2F; ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.const obj &#x3D; &#123; x() &#123;&#125;&#125;;new obj.x(); &#x2F;&#x2F; TypeError: obj.x is not a constructor 일반적으로 프로퍼티의 값인 함수는 모두 메소드로 통칭한다. 함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다. 123456789function foo() &#123;&#125;// 일반적인 함수로서 호출: [[Call]]이 호출된다.// 모든 함수 객체는 [[Call]]이 구현되어 있다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.// 이때 [[Construct]]를 갖지 않는다면 에러가 발생한다.new foo(); 2.5. 생성자 함수의 인스턴스 생성 과정생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 12345678910111213런타임 이전에 빈객체 생성 thie = 빈 객체 ,암묵적으로 this ruturn 한다. new가있으면 이렇게 동작, 없으면 일반함수처럼 동작.// 생성자 함수function Circle(radius) &#123; // 인스턴스 초기화 this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성 생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다. 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다. 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수가 호출되면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 인스턴스를 초기화한 후, 인스턴스를 반환한다. 인스턴스 생성과 this 바인딩 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 (아직 완성되지는 않았지만) 생성자 함수가 생성한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. 바인딩(binding)바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 인스턴스 초기화 생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다. 인스턴스 반환 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 2.6. new 연산자 new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다. 12345678910111213141516171819// 생성자 함수로서 정의하지 않은 일반 함수function add(x, y) &#123; return x + y;&#125;// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출let inst = new add();// 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.console.log(inst); // &#123;&#125;// 객체를 반환하는 일반 함수function createUser(name, role) &#123; return &#123; name, role &#125;;&#125;// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출inst = new createUser('Lee', 'admin');// 함수가 생성한 객체를 반환한다.console.log(inst); // &#123;name: \"Lee\", role: \"admin\"&#125; 2.7. new.target new.target은 this와 유사하게 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티(meta propery)라고 부른다.함수 내부에서 new.target를 사용하면 new 연산자와 함께 함수가 호출되었는지 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다. 123456789101112131415161718집에가서 해보기.// 생성자 함수function Circle(radius) &#123; // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다. if (!new.target) &#123; // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); 123456789101112131415161718192021// Scope-Safe Constructor Patternfunction Circle(radius) &#123; // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고 // this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다. // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다. // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다. if (!(this instanceof Circle)) &#123; // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); // 10 대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다. 예를 들어, Object 또는 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. 1234567891011let obj = new Object();console.log(obj); // &#123;&#125;obj = Object();console.log(obj); // &#123;&#125;let f = new Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) &#123; return x ** x &#125;f = Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) &#123; return x ** x &#125; 하지만 String 생성자 함수는 new 연산자와 함께 호출했을 때 String 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열 리터럴을 반환한다. 즉 문자열로 타입을 변환한다. 12345let s = new String('abc');console.log(s); // String &#123;\"abc\"&#125;s = String('abc');console.log(s); // abc","categories":[],"tags":[]},{"title":"프로퍼티 어트리뷰트","slug":"js0308-2","date":"2020-03-08T02:21:30.000Z","updated":"2020-03-10T01:58:49.492Z","comments":true,"path":"2020/03/08/js0308-2/","link":"","permalink":"https://pkt0831.github.io/2020/03/08/js0308-2/","excerpt":"","text":"1.내부 슬롯과 내부 메소드이중 대괄호([[…]])로 감싼 이름들이 내부 슬롯과 내부 메소드이다. 외부로 공개된 객체의 프로퍼티는 아니지만 엔진 내부 로직이고 직접적으로 호출할 방법은 제공하지않으나 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수단을 제공하기도 한다. 2.프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체-프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)를 말한다. 1234567const person = &#123; name: 'Lee'&#125;;// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.console.log(Object.getOwnPropertyDescriptor(person, 'name'));// &#123;value: \"Lee\", writable: true, enumerable: true, configurable: true&#125; 123456789101112131415const person = &#123; name: 'Lee'&#125;;// 프로퍼티 동적 생성person.age = 20;// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.console.log(Object.getOwnPropertyDescriptors(person));/*&#123; name: &#123;value: \"Lee\", writable: true, enumerable: true, configurable: true&#125;, age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;&#125;*/ 데이터 프로퍼티와 접근자 프로퍼티 -데이터 프로퍼티(Data property)키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.-접근자 프로퍼티(Accessor property) 제일 중요.자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수(Accessor function)로 구성된 프로퍼티다. 3.1 데이터 프로퍼티프로퍼티어트리뷰트 프로퍼티 디스크립터 객체의 프로퍼티[[Value]] value 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다. 프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.[[Writable]] writable 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.[[Enumerable]] enumerable 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.[[Configurable]] configurable 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. 1234567const person = &#123; name: 'Lee'&#125;;// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.console.log(Object.getOwnPropertyDescriptor(person, 'name'));// &#123;value: \"Lee\", writable: true, enumerable: true, configurable: true&#125; 3.2. 접근자 프로퍼티접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다. 접근자 함수는 getter/setter 함수라고도 부른다. 123456789101112131415161718192021222324252627282930313233343536373839const person = &#123; // 데이터 프로퍼티 firstName: 'Ungmo', lastName: 'Lee',코딩으로 직접 써보면서 해보기. // fullName은 접근자 함수로 구성된 접근자 프로퍼티이다. // getter 함수 get fullName() &#123; get set이 붙으면 funllname은 메소드 이름이 아니라 프로퍼티 이름이다. return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, // setter 함수 set fullName(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;&#125;;// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee// 접근자 프로퍼티를 통한 프로퍼티 값의 저장// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.person.fullName = 'Heegun Lee';console.log(person); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125;// 접근자 프로퍼티를 통한 프로퍼티 값의 참조// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.console.log(person.fullName); // Heegun Lee// firstName는 데이터 프로퍼티이다.// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log(descriptor);// &#123;value: \"Heegun\", writable: true, enumerable: true, configurable: true&#125;// fullName는 접근자 프로퍼티이다.// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log(descriptor);// &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125; 12345678접근자 프로퍼티와 데이터 프로퍼티 구별 방법.// 일반 객체의 __proto__는 접근자 프로퍼티이다.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;// 함수 객체의 prototype은 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(function() &#123;&#125;, 'prototype');// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125; 프로퍼티 정의프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const person = &#123;&#125;;// 데이터 프로퍼티 정의Object.defineProperty(person, 'firstName', &#123; value: 'Ungmo', writable: true, enumerable: true, configurable: true&#125;);Object.defineProperty(person, 'lastName', &#123; value: 'Lee'&#125;);let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log('firstName', descriptor);// firstName &#123;value: \"Ungmo\", writable: true, enumerable: true, configurable: true&#125;// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName &#123;value: \"Lee\", writable: false, enumerable: false, configurable: false&#125;// [[Enumerable]]의 값이 false인 경우,// 해당 프로퍼티는 for…in 문이나 Object.keys 등으로 열거할 수 없다.// lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로 열거되지 않는다.console.log(Object.keys(person)); // [\"firstName\"]// [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.// lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.// 이때 값을 변경하면 에러는 발생하지 않고 무시된다.person.lastName = 'Kim';// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.// lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.// 이때 프로퍼티를 삭제하면 에러는 발생하지 않고 무시된다.delete person.lastName;// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 재정의할 수 없다.// Object.defineProperty(person, 'lastName', &#123; enumerable: true &#125;);// Uncaught TypeError: Cannot redefine property: lastNamedescriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName &#123;value: \"Lee\", writable: false, enumerable: false, configurable: false&#125;// 접근자 프로퍼티 정의Object.defineProperty(person, 'fullName', &#123; // getter 함수 get() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, // setter 함수 set(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;, enumerable: true, configurable: true&#125;);descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log('fullName', descriptor);// fullName &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;person.fullName = 'Heegun Lee';console.log(person); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125; 프로퍼티 대응하는어트리뷰트 프로퍼티 누락 시의 기본값.value [[Value]] undefinedget [[Get]] undefinedset [[Set]] undefinedwritable [[Writable]] falseenumerable [[Enumerable]] falseconfigurable [[Configurable]] false 객체 변경 방지객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 프로퍼티를 추가 또는 삭제할 수 있고,값을 갱신할 수 있다.Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 재정의할 수도 있다. 1 객체 확장 금지Object.preventExtensions 메소드는 객체의 확장을 금지한다. 객체 확장 금지란 프로퍼티 추가 금지를 의미한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다. 프로퍼티는 프로퍼티 동적 추가와 Object.defineProperty 메소드로 추가할 수 있다. 이 두가지 추가 방법이 모두 금지된다. 확장이 금지된 객체인지 여부는 Object.isExtensible 메소드로 확인 할 수 있다. 5.2 객체 밀봉Object.seal 메소드는 객체를 밀봉한다. 객체 밀봉(seal)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다. 밀봉된 객체인지 여부는 Object.isSealed 메소드로 확인 할 수 있다. 5.3. 객체 동결Object.freeze 메소드는 객체를 동결한다. 객체 동결(freeze)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉, 동결된 객체는 읽기만 가능하게 된다. 밀봉된 객체인지 여부는 Object.isFrozen 메소드로 확인 할 수 있다. 5.4. 불변 객체지금까지 살펴본 변경 방지 메소드들은 얕은 변경 방지(Shallow only)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다. 따라서 Object.freeze 메소드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.","categories":[],"tags":[]},{"title":"let,const와 블록 레벨 스코프.","slug":"js0308","date":"2020-03-08T02:20:30.000Z","updated":"2020-03-09T13:02:33.236Z","comments":true,"path":"2020/03/08/js0308/","link":"","permalink":"https://pkt0831.github.io/2020/03/08/js0308/","excerpt":"","text":"1.var 변수는 같은 스코프내에서 중복 선언이 가능하다.대신, 나중에 선언된 변수 선언문은 var 키워드가 없는것처럼 동작한다.사용하지 않는 것이 좋다.1.2 함수 레벨 스코프-var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다.함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다.함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다. 123456789var x = 1;if (true) &#123; // x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다. // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. var x = 10;&#125;console.log(x); // 10 -for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다. 1.3 변수 호이스팅var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 할당문 이전에 변수를 참조하면 undefined를 반환한다. 2.let 키워드2.1 변수 중복 선언 금지var의 중복 선언 부작용을 개선하기 위해 나온 let은 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러가 발생한다. 2.2 블록 레벨 스코프var 키워드는 함수의 코드 블록 만을 지역 스코프로 인정하는 함수 레벨 스코프를 따르고, let 키워드는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 2.3 변수 호이스팅let,const,class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작하지만let,const 등을 포함하여 모든 선언(var, let, const, function, function*, class 등)은 호이스팅한다.let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다. 선언 단계는 런타임 이전에 암묵적으로 실행되고,초기화 단계는 변수 선언문에 도달했을 때 실행된다.스코프 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지의 구간을 일시적 사각지대라고하고 이때는 변수를 참조할 수 없다. 123456789// 런타임 이전에 선언 단계가 실행된다.// 아직 변수가 초기화되지 않았다. 따라서 변수 선언문 이전에 변수를 참조할 수 없다.console.log(foo); // ReferenceError: foo is not definedlet foo; // 변수 선언문에서 초기화 단계가 실행된다.console.log(foo); // undefinedfoo = 1; // 할당문에서 할당 단계가 실행된다.console.log(foo); // 1 2.4. 전역 객체와 let-전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.-var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 1234567891011121314151617181920// 전역 변수var x = 1;// 암묵적 전역y = 2; y 앞에 window.이 숨어져있음.// 전역 함수function foo() &#123;&#125;// var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.console.log(window.x); // 1// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.console.log(x); // 1// 암묵적 전역은 전역 객체의 프로퍼티이다.console.log(window.y); // 2console.log(y); // 2// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.console.log(window.foo); // ƒ foo() &#123;&#125;// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.console.log(foo); // ƒ foo() &#123;&#125; 12345let x = 1;// let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.console.log(window.x); // undefinedconsole.log(x); // 1 const 키워드const 키워드는 상수(constant)를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. 3.1 선언과 초기화const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면 문법 에러가난다. 123456789&#123; // 변수 호이스팅이 발생하지 않는 것처럼 동작한다 console.log(foo); // ReferenceError: Cannot access 'foo' before initialization const foo = 1; console.log(foo); // 1&#125;// 블록 레벨 스코프를 갖는다.console.log(foo); // ReferenceError: foo is not defined 3.2 재할당 금지 123const 키워드로 선언한 변수는 재할당이 금지된다.const foo = 1;foo = 2; // TypeError: Assignment to constant variable. 3.3 상수const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다.변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다.const 키워드로 선언된 변수에 원시 값을 할당한 경우, 원시 값은 변경할 수 없는 값(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다. 3.3 const 키워드와 객체const 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경할 수 있다. 객체는 변경이 가능한 값이기 때문에 재할당없이 직접 변경이 가능하다. 12345678const person = &#123; name: 'Lee'&#125;;// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.person.name = 'Kim';console.log(person); // &#123;name: \"Kim\"&#125; var vs. let vs. const ES6를 사용한다면 var 키워드는 사용하지 않는다. 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다. 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다.","categories":[],"tags":[]},{"title":"변수의 생명 주기","slug":"js0227","date":"2020-02-27T12:35:30.000Z","updated":"2020-05-04T12:33:11.537Z","comments":true,"path":"2020/02/27/js0227/","link":"","permalink":"https://pkt0831.github.io/2020/02/27/js0227/","excerpt":"","text":"1.변수의 생명 주기 1.1 지역 변수의 생명 주기지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다. 12345678function foo() &#123; var x = 10; console.log(x); //10 return x;&#125;foo();console.log(x); ReferenceError: x is not defined foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 변수 x의 선언문이 가장 먼저 실행되어 변수 x가 선언되고 undefined로 초기화된다. 함수 몸체의 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 변수 x에 값이 할당된다. 함수가 종료하면 변수 x도 소멸되어 생명 주기가 종료된다. 함수 내부에서 선언된 지역 변수 x는 foo 함수가 호출되어 실행되는 동안에만 유효하다. 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다. 12345678910var x = 'member';function foo() &#123; console.log(x); //undefined var x = 'local'; return x;&#125;foo();console.log(x); //member 함수 foo 내부에 선언된 지역 변수 x는 이미 선언되어 undefined로 초기화 되었다.따라서 지역 변수 x를 참조하여 값을 출력한다. 이처럼 호이스팅은 스코프를 단위로 동작한다.지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다.호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 고유의 특징을 말한다. 1.2 전역 변수의 생명 주기전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점없이 코드가 로드되자마자 곧바로 해석되고 실행된다. 함수는 함수 몸체의 마지막 문 또는 return문이 실행되면 종료한다.전역 코드는 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.var 키워드로 선언한 전역 변수는 전여 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다. 전역 객체:코드가 실행되기 이전 단계에 엔진에 의해 생성되는 특수한 객체.전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다. 2.전역 변수의 문제점1.암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변수의 유효 범위가 커져서 가독성이 나빠지고 의도치않은 상태 변경이 될 위험도 높아진다.2.긴 생명 주기:생명 주기가 길어서 메모리 리소스도 오랜 기간 소비한다.또한 변수 이름이 중복될 위험성이 있고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다.3.스코프 체인 상에서 종점에 확대: 스코프 체인 상에서 종점에 존재해 변수를 검색할 때 전역 변수가 가장 마지막에 검색되어 검색 속도가 가장 느리다.4.네임 스페이스 오염:하나의 전역 스코프를 공유해서 다른 파일 내에 동일한 이름으로 명명된 변수나 함수가 같은 소코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 3.전역 변수 사용 억제 방법변수의 스코프는 좁을수록 좋으므로 가급적 지역 변수를 사용하여야 한다. 3.1 즉시 실행 함수함수의 정의와 동시에 즉시 실행 함수는 단 한번만 호출되기에 모든 코드를 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 1234567(function () &#123; var foo = 10; // 즉시 실행 함수의 지역 변수 // ...&#125;());console.log(foo); // ReferenceError: foo is not defined이 방법을 사용하면 전역 변수를 생성하지 라이브러리에 주로 쓰인다. 3.2 네임 스페이스 객체 123456전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법.var MYAPP = &#123;&#125;; // 전역 네임 스페이스 객체MYAPP.name = 'Lee';console.log(MYAPP.name); // Lee 123456789네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성하는 방법.var MYAPP = &#123;&#125;; // 전역 네임 스페이스 객체MYAPP.person = &#123; name: 'Lee', address: 'Seoul'&#125;;console.log(MYAPP.person.name); // Lee 3.3 모듈 패턴모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것이다. 모듈 패턴은 클로저를 기반으로 동작한다.전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다.","categories":[],"tags":[]},{"title":"함수(Function)","slug":"함수(0226)","date":"2020-02-26T12:35:30.000Z","updated":"2020-05-04T12:35:26.386Z","comments":true,"path":"2020/02/26/함수(0226)/","link":"","permalink":"https://pkt0831.github.io/2020/02/26/%ED%95%A8%EC%88%98(0226)/","excerpt":"","text":"함수란?함수는 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.함수 f(x, y) = x + y를 자바스크립트의 함수로 표현. 1234567// f(x, y) = x + yfunction add(x, y) &#123; return x + y;&#125;// f(2, 5) = 7add(2, 5); // 7 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value).함수는 여러 개 존재할 수 있으므로 구별하기위해 식별자인 함수 이름 사용이 가능하다.함수를 output하는것을 반환한다고 한다.return을 써서 반환을 한다.프로퍼티키는 식별자 이름 안맞아도 되지만 귀찮아진다.{}&lt;여기에 문이 들어오기 때문에 블록문이라고 부른다(0개이상.) 함수는 함수 정의(Function definition)를 통해 생성한다. 1234// 함수 정의function add(x, y) &#123; return x + y;&#125; 정의만으론 함수가 실행되지 않는다.함수호출을해서 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행 결과,즉 반환값을 반환한다.함수 호출:입력,즉 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는것. 12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.console.log(result); // 7 얕은 복사:1단계만 복사 이유는 퍼포먼스가 떨어지기 때문에. {…o};깊은 복사:재귀함수 등.2. 함수의 사용 이유동일한 작업을 반복 수행할때 코드의 중복을 막고 몇번이든 호출 할수 있으므로 코드의 재사용이라는 측면에서 매우 유용하기 때문에 사용한다.또한 이러한 이유로 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과도 있다. 3.함수 리터럴함수는 객체 타입의 값이다. 함수도 리터럴을 생성할 수 있다. 함수 리터럴은 fucntion 키웓, 함수이름,매개변수 목록함수 몸체로 구성된다.함수 리터럴은 함수 이름을 생략할수도있고 안해도된다. 1234// 변수에 함수 리터럴을 할당var add = function add(x, y) &#123; return x + y;&#125;; -함수 이름1.함수 이름은 식별자이다.따라서 식별자 네이밍 규칙을 준수해야 한다.2.함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.(중요)3.함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명 함수,함수 이름이 없는 함수를 익명 함수라고한다.-매개변수 목록1.0개 이상의 매개변수를 소갈호로 감싸고 쉼표로 구분한다.2.매개변수에는 함수호출문의 인수가 순서대로 할당된다.매개변수 목록은 순서에 의미가 있따.3.매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다.따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 따라야한다.-함수 몸체1.함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.2.함수 몸체는 함수 호출에 의해 실행된다. 함수 리터럴은 평가되어 값을 생성하며 이 값은 객체다.즉, 함수는 객체다.일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.그리고 일반 객체에는없는 함수 객체만의 고유한 프로퍼티가 있다. 4.함수 정의함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다.4가지 방법이 있다. -함수 선언문(Function declaration/Function statement) 123function add(x, y) &#123; return x + y;&#125; 함수 선언문은 함수 이름을 생략할 수 없다.(왜냐면 이 이름으로 식별자를 만들기 때문에)선언문 특징: 모든 선언문은 런타임 이전에 실행된다.함수 이름을 가지고 식별자를 만든다.할당까지 런타임 이전에 한다.함수 선언문은 런타임 이전에 할당까지 해주기 때문에 참조 할 수 있다.그게 변수 호이스팅과 다른점이다.-함수 표현식(Function expression) 1234var add = function (x, y) &#123; return x + y;&#125;;참조(undefined 상태)는 되지만 호출은 안된다.호이스팅 발생 안된다. -Function 생성자 함수(Function constructor) 12var add = new Function('x', 'y', 'return x + y');알고만 있길, 거의 안씁니다.써서도 안됨. -화살표 함수(Arrow function): ES6 1var add = (x, y) =&gt; x + y; 4.1. 함수 선언문함수 선언문과 표현식만 알면 된다. 1234567891011함수 선언문function add(x,y)&#123; return x + y;&#125;// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출 함수 객체를 가리키고 있는 식별자로 함수 호출을 한다. 일반 객체는 호출할수있고, 함수 객체는 호출 할 수 없다.console.log(add(2, 5)); // 7 함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다. 12345// 함수 선언문은 함수 이름을 생략할 수 없다.function (x, y) &#123; return x + y;&#125;// SyntaxError: Function statements require a function name 함수 선언문은 표현식이 아닌 문이다.함수 선언문을 실행하면 완료 값 undifiend를 출력한다.만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 한다. 표현식이 아닌 문은 변수에 할당할 수 없다.함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다.하지만 아래에는 함수 선언문이 변수에 할당되는 것처럼 보인다. 12345678// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.var add = function add(x, y) &#123; return x + y;&#125;;// 함수 호출console.log(add(2, 5)); // 7 이렇게 동작하는 이유는 엔진이 상황에 따라 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다. 이는 함수 이름이 있는 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있따는 의미이다. 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고 값으로 평가되어야만 하는 문맥, 예를 들어 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석된다. 둘 다 함수가 생성되는 것은 동일하다. 123456789// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.// 함수 선언문은 함수 이름을 생략할 수 없다.function foo() &#123; console.log('foo'); &#125;foo(); // foo foo는 참조 ()은 호출 참조할 수 있어야 호출할 수 있다.// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.// 함수 리터럴은 함수 이름을 생략할 수 있다.(function bar() &#123; console.log('bar'); &#125;);bar(); // ReferenceError: bar is not defined 함수 리터럴(foo)는 함수 선언문으로 해석된다. 하지만 그룹 연산자 () 내에 있는 함수 리터럴(bar)은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다. 그룹 연산자의 피연산자는 값으로 평가할 수 있는 표현식이다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다. 함수 리터럴은 상황에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.함수 선언문 foo는 호출할 수 있지만 함수 리터럴 표현식으로 생성된 bar는 호출 할 수 없다.bar가 호출 될 수 없는 이유는 함수 리터럴은 함수 몸체 내에서만 참조 할 수 있는 식별자이기 때문에 몸체 외부에서 함수 이름으로 함수를 참조할수없기때문에 호출 할 수 없다. 위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름이므로 foo로 함수를 호출할 수 없어야 한다. foo라는 이름으로 함수를 호출하려면 foo는 함수 이름이 아니라 함수 객체를 할당한 식별자이어야 한다. 그런데 위 예제에는 식별자 foo를 선언한 적도 없고 할당한 적도 없다. foo는 도대체 무엇인가? 결론부터 말하자면 foo는 생성된 함수 객체를 할당하고 있는 자바스크립트 엔진이 암묵적으로 생성한 식별자이다. 함수 선언문은 실행되어 함수 객체를 생성한다. 이때 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 생성된 함수 객체를 가리키는 식별자가 필요하다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 호출할 수 없고 아무도 참조하고 있지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제된다. 이를 위해 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 1234var add = function add(x,y)&#123; return x + y;&#125;;console.log(add(2,5)); //7 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.함수 이름 add가 아니라 엔진이 암묵적으로 생성한 식별자 add인 것이다.함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출된 것이다. -함수3- 4.2 함수 표현식함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다.이처럼 값의 성질을 갖는 객체를 일급 객체라 한다.함수 = 일급 객체 = 함수를 값처럼 자유롭게 사용 가능. 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다. 123456// 함수 표현식var add = function (x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); // 7 함수 리터럴은 함수 이름을 생략할 수 있다.이러한 함수를 익명 함수라한다.함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. 1234567891011// 기명 함수 표현식var add = function foo (x, y) &#123; return x + y;&#125;;// 함수 객체를 가리키는 식별자로 호출console.log(add(2, 5)); // 7// 함수 이름으로 호출하면 ReferenceError가 발생한다.// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.console.log(foo(2, 5)); // ReferenceError: foo is not defined 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 함수 선언문은 “표현식이 아닌 문”이고 함수 표현식은 “표현식인 문”이다. 미묘하지만 중요한 차이가 있다. 4.3 함수 생성 시점과 함수 호이스팅 1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 표현식var sub = function (x, y) &#123; return x - y;&#125;; 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출이 안되고, 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 함수 선언문은 런타임 이전에 엔진에 의해 먼저 실행된다.즉,런타임 이전에 함수 객체가 먼저 생성된다.그리고 난 후 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.즉, 코드가 한줄씩 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. 함수도 호이스팅처럼 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 고유의 특징이 있는데 이를 함수 호이스팅이라한다. 함수 호이스팅과 변수 호이스팅 모두 런타임 이전에 먼저 실행되어 식별자를 생성하지만, 변수는 undefined로 초기화되고 함수 선언문을 통해 생성된 식별자는 함수 객체로 초기화된다.결론적으로 변수는 선언문 이전에 변수를 참조하면 undefined로 평가되고,함수 선언문은 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다. 함수 표현식은 변수 할당문의 값이 함수 리터럴인 문이다.변수 할당문의 값은 할당문이 실행되는 시점,즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. 함수 표현식 이전에 함수를 참조하면 undefined로 평가된다. 따라서 이때 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출하여야 한다. 4.4Function 생성자 함수자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.)생성자 함수:객체를 생성하는 함수를 말한다. 1234Function 생성자 함수로 add함수를 생성.var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 4.5. 화살표 함수ES6에서 새로 도입된 함수. function대신 화살표(=&gt;)로 함수를 선언할 수 있다.화살표 함수는 익명 함수로 정의한다.화살표 함수는 생성자 함수로 사용할 수 없다. 123//화살표 함수const add = (x,y) =&gt; x + y;console.log(2,3); // 7 5.함수 호출함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 5.1매개변수와 인수함수의 실행을 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다.인수는 값으로 평가될 수 있는 표현식이어야 하며 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 12345678//함수 선언문function add(x,y)&#123; return x + y;&#125;//x,y부분은 변수처럼 함수가 실행되기 이전에 undefined로 할당된다.//함수 호출// 인수 1과 2는 매개 변수x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.var result = add(1,2); 매개 변수는 함수를 정의할 때 사용하며 함수 몸체 내부에서 변수와 동일하게 취급된다.함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.매개변수는 함수 내부에서만 참조할 수 있다. 함수는 매개변수의 개수와 인수의 개수가 맞지 않은 경우 인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다. 12345function add(x,y)&#123; return x + y;&#125;console.log(add(2)); // NaNNan이 난 이유는 인수가 부족하여 x+y는 2+undefined와 같으므로 NaN이 반환된다. 12345function add(x,y)&#123; return x + y;&#125;console.log(add(2,5,10)) // 7인수가 초과하는 경우는 무시된다.초과된 인수는 버려지는 것이 아니라 모든 인수는 암묵적으로 argument 객체의 프로퍼티로 보관된다. 12345678arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할때 유용하게 사용한다.function add(x, y) &#123; console.log(arguments); return x + y;&#125;add(2, 5, 10); 5.2 인수 확인 12345678function add(x, y)&#123; return x + y;&#125;console.log(add(2)); //NaNconsole.log(add('a' , 'b')) //ab이런 결과가 나오는 이유는 2가지이다.1.함수는 인수의 개수와 매개변수의 개수가 일치하는지 확인하지 않는다.2.함수는 매개변수의 타입을 사전에 지정할 수 없다. 12345678910function add(x, y)&#123; if (typeof x !== 'number' || typeof y !== 'number')&#123; throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당 되었습니다.') &#125; return x + y;&#125;console.log(add(2)); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.에러는 런타임에 발생하게 된다. 123456789101112function add(a, b, c) &#123; a = a || 0; b = b || 0; c = c || 0; return a + b + c;&#125;console.log(add(1, 2, 3)); // 6console.log(add(1, 2)); // 3console.log(add(1)); // 1console.log(add()); // 0arguments 객체를 통해 인수 개수를 확인하는 방법. 123456789function add(a = 0, b = 0, c = 0) &#123; return a + b + c;&#125;console.log(add(1, 2, 3)); // 6console.log(add(1, 2)); // 3console.log(add(1)); // 1console.log(add()); // 0ES6에서 도입된 매개변수 기본값을 사용하면(a=0넣어서) 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.단, 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 겨웅와 undefined를 전달한 경우만 유효. 5.3 매개변수의 최대 개수최대 개수에 대해 명시적으로 제한하고 있지 않지만,적을 수록 좋다.최대 3개 이상 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다.이상적인 함수는 가급적 적게 만들어야 한다.그리고 매개변수는 순서에 의미가 있다. 12345678$.ajax(&#123; method: 'POST', url: '/user', data: &#123; id: 1, name: 'Lee' &#125;, cache: false&#125;);객체를 인수로 사용하는 경우,프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다.또한 명시적으로 값의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성이 좋아지고 실수도 줄어드는 효과가 있다.함수 바깥에 var 변수를 만들지않았기 때문에 외부에서 접근할 방법이없음. 5.4 반환문 12345678910함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환할수 있다.function multiply(x, y) &#123; return x * y; // 값의 반환&#125;// 함수는 반환값으로 평가된다.var result = multiply(3, 5);console.log(result); // 15multiply 함수는 두개의 인수를 전달받아서 곱한 결과를 반환한다.반환값은 return 키워드를 사용해 반환한다. 함수는 return 키워드를 통해서 모든 값을 반환할 수 있다. 반환문은 두가지 역할을 한다. 12345671.반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.function multiply(x, y) &#123; return x * y; // 반환문 // 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. console.log('실행되지 않는다.');&#125;console.log(multiply(3, 5)); // 15 12345672.반환문은 return 키워드 뒤에 지정한 값을 반환한다.function foo () &#123; // return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. return;&#125;console.log(foo()); // undefined 123456함수는 반환문을 생략할 수 있다.function foo () &#123; // 반환문을 생략하면 암묵적으로 undefined가 반환된다.&#125;console.log(foo()); // undefined 1234567function multiply(x, y) &#123; // return 키워드와 반환값 사이에 줄바꿈이 있으면 return // 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론이 추가된다. x * y; // 무시된다.&#125;console.log(multiply(3, 5)); // undefined 6.참조에 의한 전달과 외부 상태의 변경원시 값은 값에 의한 전달,객체는 참조에 의한 전달 방식으로 동작한다.매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달,참조에 의한 전달 방식을 그대로 따른다.원시 값은 불변값이기 때문에 문제되지 않지만, 객체의 경우 값이 변할 수 있고 참조에 의한 전달 방식으로 동작하기 때문에 여러 변수가 참조에 의한 전달 방식을 통해 참조값을 공유하고 있다면 이 변수들은 언제든지 참조하고 있는 객체를 직접 변경할 수 있는 문제가 발생 할 수 있다.이러한 문제를 해결하는 방법 중 하나는 객체를 불변 객체로 만들어 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 것이다.7.다양한 함수의 형태 7.1 즉시실행함수함수 정의된 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE)라고한다.단 한번만 호출되며 다시 호출할 수는 없다.따라서 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다. 123456789101112131415161718192021222324252627282930313233343536373839// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;()); &#123;&#125;까지 함수 리터럴 ()부터 함수 호출 일단 &#123;&#125;까지 함수 리터럴이라고 인식함.사용할때 1.인위적인 스코프를 만들때. 왜냐면 전역 변수를 안쓰려고. 함수를 빨리 저세상으로 보내려고.// 기명 즉시 실행 함수(function foo() &#123; var a = 3; var b = 5; return a * b;&#125;());foo(); // ReferenceError: foo is not defined그룹 연산자 (…) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다.function () &#123; // SyntaxError: Function statements require a function name // ...&#125;();즉시 실행 함수는 반드시 그룹 연산자(...)로 감싸 주어야 한다.그렇지 않으면 에러가 발생한다.function foo() &#123; // ...&#125;(); // SyntaxError: Unexpected token ')'에러가 발생하는 이유는 엔진이 암묵적으로 함수 선언문이 끝나는 위치,함수 코드 블록의 닫는 중괄호 뒤에\":\"이 암묵적으로 추가되기 때문이다.function foo() &#123;&#125;(); // =&gt; function foo() &#123;&#125;;();따라서 함수 선언문 뒤의 그룹 연산자에 피연산자가 없기 때문에 에러가 발생한다.(); // SyntaxError: Unexpected token )그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.console.log(typeof (function f()&#123;&#125;)); // functionconsole.log(typeof (function ()&#123;&#125;)); // function그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다.(function () &#123; // ...&#125;());먼저 함수를 평가하여 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용할 수도 있다. 123456789101112131415// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.var res = (function () &#123; var a = 3; var b = 5; return a * b;&#125;());console.log(res); // 15// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.res = (function (a, b) &#123; return a * b;&#125;(3, 5));console.log(res); // 15 7.2 재귀 함수함수가 자기 자신을 호출하는 것을 재귀 호출이라하는데,재귀 호출을 수행하는 함수를 재귀 함수라한다.재귀 함수는 자신을 무한 재귀 호출하기 때문에 함수 내에 탈출 조건을 반드시 만들어야 한다.재귀 함수는 한정적으로 사용하는것이 바람직하다.깊은 복사할때 재귀함수가 쓰인다. 12345678910111213// 함수 표현식var factorial = function foo(n) &#123; // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; // 함수를 가리키는 식별자로 자기 자신을 재귀 호출 return n * factorial(n - 1); // 함수 이름으로 자기 자신을 재귀 호출할 수도 있다. // console.log(factorial === foo); // true // return n * foo(n - 1);&#125;;console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120 123456789101112131415function factorial(n) &#123; if (n &lt;= 1) return 1; var res = n; while (--n) res *= n; return res;&#125;console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 2 * 1 = 2console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6console.log(factorial(4)); // 4! = 4 * 3 * 1 * 1 = 24console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120왠만하면 while문으로 대체하라. 7.3 중첩 함수함수 내부에 정의된 함수를 중첩 함수 or 내부 함수라 하고,중첩 함수를 포함하는 함수는 외부 함수라한다. 123456789101112131415function outer() &#123; var x = 1; // 중첩 함수 function inner() &#123; var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 &#125; inner();&#125;outer();ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.(if문 for문 등의 코드 블록내에서도 정의 가능하지만 호이스팅으로 인해 혼란이 발생할수 있으므로 바람직하지않다.) 7.4 콜백 함수 1234567891011121314151617// n만큼 어떤 일을 반복한다function repeat1(n) &#123; // i를 출력한다. for (var i = 0; i &lt; n; i++) console.log(i);&#125;repeat1(5); // 0 1 2 3 4// n만큼 어떤 일을 반복한다function repeat2(n) &#123; for (var i = 0; i &lt; n; i++) &#123; // i가 홀수일 때만 출력한다. if (i % 2) console.log(i); &#125;&#125;repeat2(5); // 1 3 12345678910111213141516171819202122// 외부에서 전달받은 f를 n만큼 반복 호출한다function repeat(n, f) &#123; for (var i = 0; i &lt; n; i++) &#123; // i를 전달하면서 f를 호출 f(i); &#125;&#125;var logAll = function (i) &#123; console.log(i);&#125;;// 반복 호출할 함수를 인수로 전달한다.repeat(5, logAll); // 0 1 2 3 4var logOdds = function (i) &#123; if (i % 2) console.log(i);&#125;;// 반복 호출할 함수를 인수로 전달한다.repeat(5, logOdds); // 1 3이처럼 함수의 매개변수를 통해 전달되는 함수를 콜백 함수라고 하며,콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수라고 한다. 7.5 순수 함수와 비순수 함수어떤 외부 상태에 의존하지도 않고 변경시키지도 않는 부수효과가 없는 함수를 순수 함수,외부 상태를 변경시키는 부수효과가 있는 함수를 비순수 함수라고 부른다. 순수 함수의 특징.1.동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다.2.어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값을 만든다.3.함수의 외부 상태를 변경하지 않는다. 1234567891011121314var conut = 0; // 현재 카운트를 나타내는 상태// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.function increase(n) &#123; return ++n;&#125;// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경conut = increase(conut);console.log(conut); // 1conut = increase(conut);console.log(conut); // 2 비순수 함수의 특징은 함수의 외부 상태를 변경하는 부수 효과가 있다는 것이다. 1234567891011121314var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.function increase() &#123; return ++count; // 외부 상태를 변경한다.&#125;// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.increase();console.log(count); // 1increase();console.log(count); // 2 13.스코프스코프는 (유효범위)를 뜻한다.매개변수는 함수 몸체 내부에서만 참조할 수 있다.즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부이다.변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.이를 스코프라한다. 스코프는 식별자가 유효한 범위를 말한다.스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다. -변수는 코드의 가장 바깥 영역뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언할수 있고, 코드 블록이나 함수는 중첩될 수 있다.모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다. 123456789101112var x = 'global';function foo() &#123; var x = 'local'; console.log(x); // ①&#125;foo();console.log(x); // ②코드의 가장 바깥 영역과 함수 foo 내부에 같은 이름을 갖는 변수 x를 선언하였고 ①과 ②에서 변수 x를 참조한다. 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다.스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다. 12345678function foo() &#123; var x = 1; // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다. // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. var x = 2; console.log(x); // 2&#125;foo(); let이나 const로 선언된 변수는 지역 변수 , var는 함수 내부에서만 선언한 변수만 지역 변수다.식별자는 스코프에 저장된다. 123456function bar() &#123; let x = 1; // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. let x = 2; // SyntaxError: Identifier 'x' has already been declared&#125;bar(); 2.스코프의 종류 코드는 전역과 지역으로 구분할 수 있다.함수만 스코프를 만든다고해서 함수 레벨 스코프라고 부른다. 2.1 전역과 전역 스코프 2.2 지역과 지역 스코프지역은 함수 몸체 내부를 말한다.지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 스코프 체인함수는 전역에서 정의할 수도 있고 몸체 내부에서 정의할 수도 있다.함수 몸체 내부에서 함수가 정의된것을 ‘함수의 중첩’,몸체 내부에서 정의한 함수를 ‘중첩 함수’,중첩 함수를 포함하는 함수를 ‘외부 함수’라고 부른다.스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라 한다. 위 예제에서 지역은 outer 함수의 지역과 inner 함수의 지역이 있다. inner 함수는 outer 함수의 중첩 함수이다. 이때 outer 함수가 만든 outer 함수의 지역 스코프는 inner 함수가 만든 inner 함수의 지역 스코프의 상위 스코프이다. 그리고 outer 함수의 지역 스코프의 상위 스코프는 전역 스코프이다. 이러한 계층적 구조를 그림으로 나타내보면 아래와 같다. 모든 스코프가 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 계층적으로 연결된 것을 스코프 체인이라 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 3.1 스코프 체인에 의한 변수 검색 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다. 3.2 스코프 체인에 의한 함수 검색 12345678910111213141516171819전역에서 정의된 foo 함수와 bar 함수 내부에서 정의된 foo 함수가 있다.// 전역 함수function foo() &#123; console.log('global function foo');&#125;function bar() &#123; // 중첩 함수 function foo() &#123; console.log('local function foo'); &#125; foo(); // ①&#125;bar();함수 선언문으로 함수를 정의하면 엔진에 의해 다른 코드가 실행되기 이전에 함수 객체가 먼저 생성된다. 그리고 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.위 예제의 모든 함수는 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다.①에서 함수 foo를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 변수 foo를 검색한다.이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다. 스코프를 \"식별자를 검색하는 규칙\"이라고 표현하는 것이 적합하다. 함수 레벨 스코프코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.블록 레벨 스코프:함수 몸체 만이 아니라 모든 코드 블록이 지역 스코프를 만든다.함수 레벨 스코프:var 키어드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 123456789101112var x = 1;if (true) &#123; // var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다. // 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. // 따라서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다. // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. var x = 10; //대신에 let이나 const가 오면 지역변수이다.&#125;console.log(x); // 10전역 변수 x가 선언되었고 if 문의 코드 블록 내에도 변수 x가 선언되었다. 이때 if 문의 코드 블록 내에서 선언된 변수 x는 전역 변수다. var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하기 때문에 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. 따라서 전역 변수 x는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다. 123456789var i = 10;// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.for (var i = 0; i &lt; 5; i++) &#123; console.log(i); // 0 1 2 3 4&#125;// 의도치 않게 변수의 값이 변경되었다.console.log(i); // 5 5.렉시컬 스코프(가장 중요.) 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프 또는 렉시컬 스코프라고 부른다. 12345678910111213var x = 1;function foo() &#123; var x = 10; bar();&#125;function bar() &#123; console.log(x);&#125;foo(); // ?bar(); // ? 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다.1.함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.-&gt;함수foo,전역함수 정의 시점에는 함수가 어디서 호출될 지 알 수 없다.함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.2.함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.-&gt;전역함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프 또는 렉시컬 스코프라고 부른다.","categories":[],"tags":[]},{"title":"원시 값과 객체의 비교","slug":"js0225","date":"2020-02-25T12:35:30.000Z","updated":"2020-05-04T12:34:36.099Z","comments":true,"path":"2020/02/25/js0225/","link":"","permalink":"https://pkt0831.github.io/2020/02/25/js0225/","excerpt":"","text":"원시 값과 객체의 비교 자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, symbol, 객체 타입)은 크게 원시 타입(primitive type)과 객체(object / reference type) 타입으로 구분할 수 있다.원시 타입과 객체 타입의 3가지 차이점. -원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다.반대로 객체(참조)타입의 값은 변경 가능한 값이다.-원시 값을 변수에 할당하면 실제 값이 저장된다. 객체는 변수에 할당하면 변수에는 참조 값이 저장된다.-원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 1.원시 값 1.1 변경 불가능한 값원시 타입의 값은 변경 불가능한 값이다. 오직 read only한 값이고 변경할 수 없다.변수는 메모리 공간을 식별하기 위해 붙인 이름,값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과. 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.값을 변경할 수 없다는 것은 재할당을 할 수 없단는 의미와는 다르다.변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다.상수는 재할당이 금지된 변수를 말한다.왜냐하면 값을 저장하기 위해서는 메모리 공간이 필요하므로 변수의 일종이라고 할 수 있다. 차이점은 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있고,상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다. 1234567// const 키워드를 사용해 선언한 상수는 재할당이 금지된다.const o = &#123;&#125;;// 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.// 즉, 상수는 재할당이 금지된 변수일 뿐이다.o.a = 1;console.log(o); // &#123;a: 1&#125; 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다. 만약 원시값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 주소를 바꿀 필요 없이 원시 값 자체를 수정하면 되지만, 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 원시값은 변경 불가능한 값이기에 직접 변경할 수 없다. 변수 값을 변경하기 위해서는 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후,변수가 참조하던 메모리 공간의 주소를 변경하는데 이런 특성을 불변성이라 한다. 만약 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치않게 변수 값이 변경될 수 있고,이것은 상태 변경을 추적하기 어렵게 만들기 때문에 신뢰성을 떨어뜨린다. 1.2. 문자열과 불변성 원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다. 원시 타입 별로 메모리 공간의 크기가 미리 정해져 있다. 문자열 타입(2byte)과 숫자 타입(8byte) 이외의 원시 타입은 크기를 명확히 규정하고 있지않다. 문자열은 0개 이상의 문자들로 이루어진 집합을 말하며 1개의 문자는 2byte의 메모리 공간에 저장된다. 따라서 몇개의 문자로 이루어졌는지에 따라 메모리 공간의 크기가 결정된다. 숫자값은 어떤값도 동일한 8byte가 필요하다.문자열은 원시 타입이며 변경 불가능하다. 12var str = 'Hello';str = 'world'; 첫번째 문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 문자열 ‘Hello’가 저장된 메모리 공간의 메모리 셀 주소를 가리킨다. 그리고 두번째 문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 식별자 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다. 1234567var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.str[0] = 'S';console.log(str); // string 1.3 값에 의한 전달 12345678910var score = 80;var copy = score;console.log(score); // 80console.log(copy); // 80score = 100;console.log(score); // 100console.log(copy); // ? 변수에 변수를 할당했을때 무엇이 어떻게 달라질까? copy = score에서 score는 변수값 80으로 평가되므로 변수 copy에도 80이 할당될 것이다. 이때 새로운 숫자값 80이 생성되어 변수 copy에 할당된다. 변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다.변수 copy에 원시값을 갖는 변수 score를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값 80이 복사되어 전달된다. 1234567var score = 80;// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.var copy = score;console.log(score, copy); // 80 80console.log(score === copy); // true 변수 score와 copy의 값 80은 다른 메모리 공간에 저장된 별개의 값이다. 1234567891011121314var score = 80;// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.var copy = score;console.log(score, copy); // 80 80console.log(score === copy); // true// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.score = 100;console.log(score, copy); // 100 80console.log(score === copy); // false 지만 변수에 원시값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시값을 참조하다가 어느 한쪽의 변수에 재할당이 이루어졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다. 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼 수 있어야 하므로 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 식별자로 값을 구별하여 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다. 1var copy = score; 위 값은 2가지 평가 방식이 가능하다.1.새로운 80을 생성하여 메모리 주소를 전달하는 방식.할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.2.socre의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.이처럼 “값의 의한 전달”도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.중요한 것은 변수에 원시값을 갖는 변수를 할당하는 경우, 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 원시값을 재할당하는 시점이든 결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다. 2.객체 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다.또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.원시 값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있다. 2.1 변경 가능한 값. 1234변수에 객체를 할당var person = &#123; name: 'Lee'&#125;; 원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다. 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값(Reference value)에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다. 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이 값을 참조 값이라고 한다. 변수는 이 참조 값을 통해 객체에 접근할 수 있다.원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다. 1234567// 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.var person = &#123; name: 'Lee'&#125;;// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근하여 그 객체를 반환한다.console.log(person); // &#123;name: \"Lee\"&#125; 변수 person은 객체 { name: ‘Lee’ }를 가리키고(참조하고) 있다. 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 이외에는 다른 방법이 없다. 하지만 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당없이 객체를 직접 변경할 수 있다. 즉, 재할당없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 생성person.address = 'Seoul';console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리에 원시 값을 새롭게 생성해야 한다. 하지만 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다. 이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다. 메모리를 효율적으로 사용하기위해 그리고 객체의 복사하고 생성하는 비용을 절약하여 퍼포먼스를 향상시키기 위해 객체는 변경 가능한 값으로 디자인되어있다.객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 2.2. 참조에 의한 전달여러 개의 식별자가 하나의 객체를 공유할 시 의미와 부작용. 123456var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사var copy = person; 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 원본 person를 사본 copy에 할당하면 원본 person의 참조 값을 복사하여 copy에 저장한다.이때 원본 person와 사본 copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 다시 말해, 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.var copy = person;// copy와 person은 동일한 객체를 참조한다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 동일한 객체를 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사하여 전달한다는 면에서 동일하다. 다만 식별자가 기억하는 메모리 공간에 저장되어 있는 값이 원시 값인지 참조 값인지의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.","categories":[],"tags":[]},{"title":"타입 변환(explicit coercion)","slug":"js0224","date":"2020-02-24T12:35:30.000Z","updated":"2020-05-04T12:34:34.863Z","comments":true,"path":"2020/02/24/js0224/","link":"","permalink":"https://pkt0831.github.io/2020/02/24/js0224/","excerpt":"","text":"1.타입 변환개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.var x = 10; // 명시적 타입 변환// 숫자를 문자열로 타입 캐스팅한다. 12345var str = x.toString();console.log(typeof str, str); // string 10// 변수 x의 값이 변경된 것은 아니다.console.log(typeof x, x); // number 10 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 12var x = 10;10.tostring ()벗기면 소수로 판별하기때문에 에러가남. 10 + ''써야한다. // 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다. 12345var str = x + '';console.log(typeof str, str); // string 10// 변수 x의 값이 변경된 것은 아니다.console.log(typeof x, x); // number 10 명시적,암묵적 타입 변환이 기존 원시값을 변경하는건 아니다.타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.// 원시값 1이 ‘1’로 직접 변경되는 것이 아니다.// 1을 사용해 타입이 다른 ‘1’을 새롭게 생성하여 ‘1’ + ‘’을 평가한다.1 + ‘’ // ‘1’ 암묵적 타입 변환은 재할당이 아니라 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘’을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘’를 평가한다. 이때 자동 생성된 문자열 ‘10’은 변수 x에 할당되는 것이 아니다. 따라서 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다. 명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다 2.암묵적 타입 변환자바스크립트 엔진은 표현식을 평가할때 개발자의 의도 상관없이 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.// 피연산자가 모두 문자열 타입이여야 하는 문맥‘10’ + 2 // ‘102’ // 피연산자가 모두 숫자 타입이여야 하는 문맥5 * ‘10’ // 50 // 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥!0 // trueif (1) { } 2.1 문자열 타입으로 변환 1 + ‘2’ // “12” 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다. 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다. console.log(1 + 1 = ${1 + 1}); // “1 + 1 = 2”$(1+1) 1+1을 먼저 연산하고 그다음에 타입변환된다. 문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변호나 수행할때의 예. 1234567891011121314151617181920212223242526272829// 숫자 타입0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"NaN + '' // \"NaN\"Infinity + '' // \"Infinity\"-Infinity + '' // \"-Infinity\"// 불리언 타입true + '' // \"true\"false + '' // \"false\"// null 타입null + '' // \"null\"// undefined 타입undefined + '' // \"undefined\"// 심볼 타입(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// 객체 타입(&#123;&#125;) + '' // \"[object Object]\" (&#123;&#125;)는 객체 리터럴.Math + '' // \"[object Math]\"[] + '' // \"\"[10, 20] + '' // \"10,20\"(function()&#123;&#125;) + '' // \"function()&#123;&#125;\"Array + '' // \"function Array() &#123; [native code] &#125;\" 2.2숫자 타입으로 변환 1231 - '1' // 01 * '10' // 101 / 'one' // NaN 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다.산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다. ‘1’ &gt; 0 // true 비교연산자는 불리언 값을 만드는 것이다. 때문에 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다.+ 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다. // 문자열 타입+’’ // 0+’0’ // 0+’1’ // 1+’string’ // NaN // 불리언 타입+true // 1+false // 0 // null 타입+null // 0 // undefined 타입+undefined // NaN // 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number // 객체 타입+{} // NaN+[] // 0+[10, 20] // NaN+(function(){}) // NaN 빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다 2.3. 불리언 타입으로 변환 if (‘’) console.log(x); if,for같은 제어문,삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다. 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. if (‘’) console.log(‘1’);if (true) console.log(‘2’);if (0) console.log(‘3’);if (‘str’) console.log(‘4’);if (null) console.log(‘5’); // 2 4 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다. false로 평가되는 Falsy 값들.falseundefinednull0, -0NaN’’ (빈문자열) // 아래의 조건문은 모두 코드 블록을 실행한다.if (!false) console.log(false + ‘ is falsy value’);if (!undefined) console.log(undefined + ‘ is falsy value’);if (!null) console.log(null + ‘ is falsy value’);if (!0) console.log(0 + ‘ is falsy value’);if (!NaN) console.log(NaN + ‘ is falsy value’);if (!’’) console.log(‘’ + ‘ is falsy value’); Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다. // 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.function isFalsy(v) { return !v;} // 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.function isTruthy(v) { return !!v;} // 모두 true를 반환한다.console.log(isFalsy(false));console.log(isFalsy(undefined));console.log(isFalsy(null));console.log(isFalsy(0));console.log(isFalsy(NaN));console.log(isFalsy(‘’)); // 모두 true를 반환한다.console.log(isTruthy(true));// 빈 문자열이 아닌 문자열은 Truthy 값이다.console.log(isTruthy(‘0’));console.log(isTruthy({}));console.log(isTruthy([])); 명시적 타입 변환문자열은 원시값이다. 문자열 객체는 (‘Hello’).touppercase()개발자 의도에 의해 명시적으로 타입 변경 하는 3가지 방법. 표준 빌트인 생성자 함수를 new 연산자 없이 호출 js에서 제공하는 빌트인 메소드를 사용. 암묵적 변환을 이용하는 방법.(제일 많이 쓰인다.) 3.1. 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환하는 3가지 방법 1234567891011121314151617181920212223242526// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법(잘 쓰이지 않는다.)// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(Infinity)); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // \"true\"console.log(String(false)); // \"false\"// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // \"1\"console.log((NaN).toString()); // \"NaN\"console.log((Infinity).toString()); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // \"true\"console.log((false).toString()); // \"false\"// 3. 문자열 연결 연산자를 이용하는 방법(제일 많이 쓰인다.)// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(Infinity + ''); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // \"true\"console.log(false + ''); // \"false\" 3.2. 숫자 타입으로 변환 숫자 타입이 아닌 값을 숫자 타입으로 변환하는 4가지 방법. 1234567891011121314151617181920212223242526272829303132// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(Number('0')); // 0console.log(Number('-1')); // -1console.log(Number('10.53')); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(Number(true)); // 1console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)// 문자열 타입 =&gt; 숫자 타입console.log(parseInt('0')); // 0console.log(parseInt('-1')); // -1console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(+'0'); // 0console.log(+'-1'); // -1console.log(+'10.53'); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(+true); // 1console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log('0' * 1); // 0console.log('-1' * 1); // -1console.log('10.53' * 1); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(true * 1); // 1console.log(false * 1); // 0 3.3. 불리언 타입으로 변환 불리언 타입이 아닌 값을 불리언 타입으로 변환하는 2가지 방법 1234567891011121314151617181920212223242526272829303132333435// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean(&#123;&#125;)); // trueconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(!!'x'); // trueconsole.log(!!''); // falseconsole.log(!!'false'); // true// 숫자 타입 =&gt; 불리언 타입console.log(!!0); // falseconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // true// null 타입 =&gt; 불리언 타입console.log(!!null); // false// undefined 타입 =&gt; 불리언 타입console.log(!!undefined); // false// 객체 타입 =&gt; 불리언 타입console.log(!!&#123;&#125;); // trueconsole.log(!![]); // true 4.단축 평가 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.” ‘Cat’ &amp;&amp; ‘Dog’ // ‘Dog’ 논리곱(&amp;&amp;) 연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다.첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다.두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 논리곱 연산자는 논리 연산의 결과를 결정한 두번째 피연산자 즉, 문자열 ‘Dog’를 그대로 반환한다.논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다. ‘Cat’ || ‘Dog’ // ‘Cat’ 논리합(||) 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가.논리합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉, 문자열 ‘Cat’를 그대로 반환한다.논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이와 같이 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다.축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행한다. 단축 평가 규칙.단축 평가 표현식. 평가 결과true || anything truefalse || anything anythingtrue &amp;&amp; anything anythingfalse &amp;&amp; anything false // 논리합(||) 연산자‘Cat’ || ‘Dog’ // ‘Cat’false || ‘Dog’ // ‘Dog’‘Cat’ || false // ‘Cat’ // 논리곱(&amp;&amp;) 연산자‘Cat’ &amp;&amp; ‘Dog’ // Dogfalse &amp;&amp; ‘Dog’ // false‘Cat’ &amp;&amp; false // false 단축 평가를 사용하면 if문을 대체할 수 있다. 주어진 조건이 Truthy 값(참으로 평가되는 값)일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자 표현식으로 if문을 대체할 수 있다. var done = true;var message = ‘’; // 주어진 조건이 true일 때if (done) message = ‘완료’; // if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; ‘완료’;console.log(message); // 완료 주어진 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야 한다면 논리합(||) 연산자 표현식으로 if문을 대체할 수 있다. var done = false;var message = ‘’; // 주어진 조건이 false일 때if (!done) message = ‘미완료’; // if문은 단축 평가로 대체 가능하다.message = done || ‘미완료’;console.log(message); // 미완료 삼항 조건 연산자는 if..else문을 대체할 수 있다. var done = true;var message = ‘’; // if…else문if (done) message = ‘완료’;else message = ‘미완료’;console.log(message); // 완료 // if..else문은 삼항 조건 연산자로 대체 가능하다.message = done ? ‘완료’ : ‘미완료’;console.log(message); // 완료 -단축 평가는 아래와 같은 상황에서 유용하게 사용된다. 객체가 null인지 확인하고 프로퍼티를 참조할 때var elem = null; console.log(elem.value); // TypeError: Cannot read property ‘value’ of nullconsole.log(elem &amp;&amp; elem.value); // null 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다. 함수 매개변수에 기본값을 설정할 때 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) &#123; str = str || ''; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') &#123; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다. 10.객체 리터럴 1.객체란?자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 키(Key) = 값을 찾아오는 단서. 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다.-프로퍼티: 객체의 상태를 나타내는 값(data)-메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior) 객체와 함수자바스크립트의 객체는 함수와 밀접한 관계를 갖는다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다. 즉, 객체를 이해해야 함수를 제대로 이해할 수 있고 반대로 함수를 이해해야 객체를 정확히 이해할 수 있다. 2.객체 리터럴에 의한 객체 생성블록문이 아니기 대문에 {}; ;세미콜론 붙인다.인스턴스인스턴스(instance)란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. 자바스크립트는 프로토타입 기반 객체향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다. -객체 리터럴-Object 생성자 함수-생성자 함수-Object.create 메소드-클래스 (ES6) 가장 일바적인 방법은 객체 리터럴을 사용하는 방법이다. 객체 리터럴은 객체를 생성하는 표기법이다.객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다. 1234567891011121314var person = &#123; name: 'Lee', sayHello: function () &#123; console.log(`Hello! My name is $&#123;this.name&#125;.`); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125;중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.var empty = &#123;&#125;; // 빈 객체console.log(typeof empty); // object 객체 리터럴의 중괄호는 코드 블록 의미 x , 코드 블록의 닫는 중괄호 뒤에는 세미 콜론 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이기에 닫는 중괄호 뒤에는 세미 콜론을 붙인다. 3.프로퍼티-객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성.-프로퍼티 나열할 때는 쉼표(,)로 구분.-마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다. 123456var person = &#123; // 프로퍼티 키는 name, 프로퍼티 값은 'Lee' name: 'Lee', // 프로퍼티 키는 age, 프로퍼티 값은 20 age: 20&#125;; 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값.프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값.프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다.프로퍼티 키를 나누는 이유는 식별자는 스코프에서 찾고 키는 프로타입 체인에서 찾는데 그걸 구별하기 위해서.symbol 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다.이때 프로퍼티 키는 문자열이므로 따옴표(‘…’ 또는 “…”)로 묶어야 하지만 유효한 이름인 경우,따옴표를 생략할 수 있다.식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다. 123456var person = &#123; firstName: 'Ung-mo', // 유효한 이름 'last-name': 'Lee' // 유효하지 않은 이름&#125;;console.log(person); // &#123;firstName: \"Ung-mo\", last-name: \"Lee\"&#125; 빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지는 않는다.하지만 키로서의 의미를 갖지 못한다. 12345var foo = &#123; '': '' // 빈문자열도 프로퍼티 키로 사용할 수 있다.&#125;;console.log(foo); // &#123;\"\": \"\"&#125; -프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.-var, function과 같은 예약어(Reserved word)를 프로퍼티 키로 사용해도 에러가 발생하지 않는다.-이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 4.메소드 자바 스크립트에서 사용할 수 있는 모든 값 = 프로퍼티 값으로 사용 가능= 객체 = 함수. 따라서 함수는 값으로 취급 가능하고 프로퍼티의 값이 될 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기위해 메소드라 부른다.메소드= 객체에 제한되어 있는 함수를 의미.메소드도 결국은 프로퍼티다. 12345678910var circle = &#123; radius: 5, // ← 프로퍼티 // 원의 지름 getDiameter: function () &#123; // ← 메소드 return 2 * this.radius; // this는 circle를 가리킨다. &#125;&#125;;this는 객체(프로퍼티)를 가리킨다.console.log(circle.getDiameter()); // 10 5.프로퍼티 접근-name이라는 전역 객체가 있다.-프로퍼티 값에 접근하려면 마침표(.)를 사용하는 마침표 표기법(Dot notation) 또는 대괄호([…])를 사용하는 대괄호 표기법(Bracket notation)을 사용한다.-프로퍼티 키가 js에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용 가능.-마침표 또는 대괄호의 좌측에는 표현식 기술. 우측 또는 대괄호 내부에는 프로퍼티 키를 지정.식별자 규칙을 지키면 ‘ ‘ 안붙여도 엔진이 자동으로 문자열로 해석함.안지키면 ‘’해줘야함. 12345// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Lee 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. -객체에 존재하지 않는 프로퍼티에 접근하면 ReferenceError가 아닌 undefined를 반환한다.-프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법을 사용해야 한다.-대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 6.프로퍼티 값 갱신이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다. 12345678var person = &#123; name: 'Lee'&#125;;// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.person.name = 'Kim';console.log(person); // &#123;name: \"Kim\"&#125; 7.프로퍼티 동적 생성 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.있으면 덮어쓴다. 123456789var person = &#123; &#123;&#125;는 할당 직전에 생성됨.없는걸 지우면 무시한다. name: 'Lee'&#125;;// person 객체에는 age 프로퍼티가 존재하지 않는다.// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.person.age = 20;console.log(person); // &#123;name: \"Lee\", age: 20&#125; 8.프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. ES6에서 추가된 객체 리터럴의 확장 기능 9.1. 프로퍼티 축약 표현 -객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.// ES5var x = 1, y = 2; var obj = { x: x, x: x (이자리는 표현식이 와야하는 자리) y: y}; console.log(obj); // {x: 1, y: 2} -ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략(Property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.9.2. 프로퍼티 키 동적 생성 -문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능.-프로퍼티 키로 사용할 표현식을 대괄호([…])로 묶어야 한다. 이를 계산된 프로퍼티 이름(Computed property name)이라 한다.-ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다. 9.3. 메소드 축약 표현 -ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다.-ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.-S6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다.","categories":[],"tags":[]},{"title":"연산자(operator)","slug":"js2022","date":"2020-02-22T13:35:30.000Z","updated":"2020-05-04T12:33:36.177Z","comments":true,"path":"2020/02/22/js2022/","link":"","permalink":"https://pkt0831.github.io/2020/02/22/js2022/","excerpt":"","text":"7.연산자연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다.피연산자는 값으로 평가될 수 있는 표현식이어야 한다.모든 연산자는 값을 만든다. 모든 연산자 = 표현식이다. // 산술 연산자5 * 4 // -&gt; 20// 문자열 연결 연산자‘My name is ‘ + ‘Lee’ // -&gt; ‘My name is Lee’// 할당 연산자color = ‘red’ // -&gt; ‘red’// 비교 연산자3 &gt; 5 // -&gt; false// 논리 연산자true &amp;&amp; false // -&gt; false// 타입 연산자typeof ‘Hi’ // -&gt; string 1.산술 연산자산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다.산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. 1.1. 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.5 + 2; // -&gt; 75 - 2; // -&gt; 35 * 2; // -&gt; 105 / 2; // -&gt; 2.55 % 2; // -&gt; 1 1.2. 단항 산술 연산자단항(Unary) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 주의할 것은 이항 산술 연산자와는 달리 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. -피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. -피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다. var x = 5, result; // 선할당 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6x 먼저, 후에 1증가 // 선증가 후할당 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7 // 선할당 후감소 (Postfix decrement operator)result = x–;console.log(result, x); // 7 6 // 선감소 후할당 (Prefix decrement operator)result = –x;console.log(result, x); // 5 5 단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. // 아무런 효과가 없다.+10; // -&gt; 10+(-10); // -&gt; -10 // 문자열을 숫자로 타입 변환한다.+’10’; // -&gt; 10 // 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1 // 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0 // 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+’Hello’; // -&gt; NaN – 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. // 부호를 반전한다.-(-10); // -&gt; 10 // 문자열을 숫자로 타입 변환한다.-‘10’; // -&gt; -10 // 불리언 값을 숫자로 타입 변환한다.-true; // -&gt; -1 // 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.-‘Hello’; // -&gt; NaN 1.3 문자열 연결 연산자 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작,그외엔 덧셈 연산자로 동작한다. // 문자열 연결 연산자‘1’ + 2; // -&gt; ‘12’1 + ‘2’; // -&gt; ‘12’ // 산술 연산자1 + 2; // -&gt; 3 // true는 1로 타입 변환된다.1 + true; // -&gt; 2 // false는 0으로 타입 변환된다.1 + false; // -&gt; 1 // null는 0으로 타입 변환된다.1 + null; // -&gt; 1 // undefined는 숫자로 타입 변환되지 않는다.+undefined; // -&gt; NaN1 + undefined; // -&gt; NaN 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다.+/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다. 2.할당 연산자 할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. var x; x = 10;console.log(x); // 10 x += 5; // x = x + 5;console.log(x); // 15 x -= 5; // x = x - 5;console.log(x); // 10 x *= 5; // x = x * 5;console.log(x); // 50 x /= 5; // x = x / 5;console.log(x); // 10 x %= 5; // x = x % 5;console.log(x); // 0 var str = ‘My name is ‘; // 문자열 연결 연산자str += ‘Lee’; // str = str + ‘Lee’; console.log(str); // ‘My name is Lee’ var x; // 할당문은 표현식인 문이다.console.log(x = 10); // 10 3.비교 연산자 비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다. 3.1. 동등 / 일치 비교 연산자 동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다. 등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다. 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다. // 동등 비교5 == 5; // -&gt; true // 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.5 == ‘5’; // -&gt; true 동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵기 때문에 부작용을 일으킬 수 있으므로 사용하지 않는 편이 좋다. // 동등 비교. 결과를 예측하기 어렵다.‘0’ == ‘’; // -&gt; false0 == ‘’; // -&gt; true0 == ‘0’; // -&gt; truefalse == ‘false’; // -&gt; falsefalse == ‘0’; // -&gt; truefalse == null; // -&gt; falsefalse == undefined; // -&gt; false 동등 비교(==) 연산자는 예측하기 어려운 결과를 만들어낸다.일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 다시 말해 암묵적 타입 변환을 하지 않고 값을 비교한다.=== 쓰면 타입도 같고 값도 같아야한다.그래서 3개짜리를 써야한다. ==개는 타입을 암묵적으로 변환시키기 때문에 쓰지 말아야한다. // 일치 비교5 === 5; // -&gt; true // 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === ‘5’; // -&gt; false // NaN은 자신과 일치하지 않는 유일한 값이다.NaN은 숫자 타입이다.NaN === NaN; // -&gt; false NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다. // 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.isNaN(NaN); // -&gt; trueisNaN(10); // -&gt; falseisNaN(1 + undefined); // -&gt; true 자바스크립트에는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다.// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.0 === -0; // -&gt; true0 == -0; // -&gt; true0과 -0을 비교하려면 object.js를 써야한다. -0 === +0; // -&gt; trueObject.is(-0, +0); // -&gt; false NaN === NaN; // -&gt; falseObject.is(NaN, NaN); // -&gt; true 부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다. // 부동등 비교5 != 8; // -&gt; true5 != 5; // -&gt; false5 != ‘5’; // -&gt; false // 불일치 비교5 !== 8; // -&gt; true5 !== 5; // -&gt; false5 !== ‘5’; // -&gt; true 3.2. 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. // 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 삼항 조건 연산자삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 물음표(?) 앞의 첫번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다. var x = 2; // 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? ‘홀수’ : ‘짝수’; console.log(result); // 짝수 삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다. var x = 2, result; // 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.if (x % 2) result = ‘홀수’;else result = ‘짝수’; console.log(result); // 짝수 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없다. var x = 10; // if…else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.var result = if (x % 2) { result = ‘홀수’; } else { result = ‘짝수’; };// SyntaxError: Unexpected token if 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 따라서 삼항 조건 연산자식은 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다. var x = 10; // 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.var result = x % 2 ? ‘홀수’ : ‘짝수’;console.log(result); // 짝수if문의 대용품으로 쓰여짐.if로 쓰면 좋을지 삼황연산자로 쓰면 좋을지 고민해야된다.x % 2(조건) true로 평가되면 ‘홀수’가 평가된다. 조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. 하지만 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면 if…else 문이 보다 가독성이 좋다. 5.논리 연산자 논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다. 쉼표 연산자쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.var x, y, z; x = 1, y = 2, z = 3; // 3 그룹 연산자 10 * 2 + 3; // -&gt; 23 // 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 8.typeof 연산자 ypeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다. typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는 것에 주의, null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다. 9.지수 연산자ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 2 ** 2; // -&gt; 42 ** 2.5; // -&gt; 5.656854249492382 ** 0; // -&gt; 12 ** -2; // -&gt; 0.25 음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다. -5 ** 2;// -&gt; SyntaxError(-5) ** 2; // -&gt; 25 지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.var num = 5;num **= 2; // -&gt; 25 지수 연산자는 모든 이항 연산자보다 우선 순위가 높다.2 * 5 ** 2; // -&gt; 50 연산자의 부수 효과 대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어, 1 * 2는 다른 코드에 어떠한 영향도 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과(side effect)가 있다. 부수 효과과 있는 연산자는 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자이다. var x; // 할당 연산자는 변수 값이 변하는 부수 효과가 있다.// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x = 1;console.log(x); // 1 // 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x++;console.log(x); // 2 var o = { a: 1 }; // delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.delete o.a;console.log(o); // {} 8.제어문 제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.let,const로 만들면 유효범위가 생김. 블록문 블록문(Block statement/Compound statement)는 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 블록문의 끝에는 세미콜론을 붙이지 않는다.js 에선 블록문을 스코프로 인정하지않는다.여러문을 하나로 묶는 역할을 함. // 블록문{ var foo = 10; console.log(foo);} // 제어문var x = 0;while (x &lt; 10) { x++;}console.log(x); // 10 // 함수 선언문function sum(a, b) { return a + b;}console.log(sum(1, 2)); // 3 조건문 조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 2.1 if..else 문 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참(true)일 경우, if 문 다음의 코드 블록이 실행되고 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다. if (조건식) { // 조건식이 참이면 이 코드 블록이 실행된다.} else { // 조건식이 거짓이면 이 코드 블록이 실행된다.} if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 데이터 타입이 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다. 조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if 문을 사용한다.if (조건식1) { // 조건식1이 참이면 이 코드 블록이 실행된다.} else if (조건식2) { // 조건식2이 참이면 이 코드 블록이 실행된다.} else { // 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.} else if 문과 else 문은 옵션이다. 즉, 사용할 수도 있고 사용하지 않을 수도 있다. if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. var num = 2;var kind; // if 문if (num &gt; 0) { kind = ‘양수’; // 음수를 구별할 수 없다}console.log(kind); // 양수 // if…else 문if (num &gt; 0) { kind = ‘양수’;} else { kind = ‘음수’; // 0은 음수가 아니다.}console.log(kind); // 양수 // if…else if 문if (num &gt; 0) { kind = ‘양수’;} else if (num &lt; 0) { kind = ‘음수’;} else { kind = ‘영’;}console.log(kind); // 양수 만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다. var num = 2;var kind; if (num &gt; 0) kind = ‘양수’;else if (num &lt; 0) kind = ‘음수’;else kind = ‘영’; console.log(kind); // 양수 대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.// x가 짝수이면 문자열 ‘짝수’를 반환하고 홀수이면 문자열 ‘홀수’를 반환한다.var x = 2;var result; if (x % 2) { // 2 % 2는 0이다. 이때 0은 false로 암묵적 강제 변환된다. result = ‘홀수’;} else { result = ‘짝수’;} console.log(result); // 짝수 두가지 경우의 수(‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수(양수, 음수, 영)를 갖는 경우는 아래와 같이 바꿔 쓸 수 있다. // x가 짝수이면 문자열 ‘짝수’를 반환하고 홀수이면 문자열 ‘홀수’를 반환한다.var x = 2; // 0은 false로 취급된다.var result = x % 2 ? ‘홀수’ : ‘짝수’; console.log(result); // 짝수 num &gt; 0 ? ‘양수’ : ‘음수’는 표현식이다. 즉, 삼항 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다는 차이가 있다. 2.2. switch 문 switch (표현식) { case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;} if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. 3.반복문 반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. 자바스크립트는 3가지의 반복문 for 문, while 문, do…while 문을 제공한다. 3.1 for 문for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 3.2 while 문while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다 3.3. do…while 문do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다. break 문break 문은 코드 블록을 탈출한다. break는 while,for,switch 문에만 쓰인다. continue 문ntinue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.","categories":[],"tags":[]},{"title":"표현식과 문","slug":"js0220","date":"2020-02-20T13:35:30.000Z","updated":"2020-05-04T12:34:33.540Z","comments":true,"path":"2020/02/20/js0220/","link":"","permalink":"https://pkt0831.github.io/2020/02/20/js0220/","excerpt":"","text":"표현식과 문 1.값값(value)은 식(표현식,expression)이 평가(evaluate)되어 생성된 결과를 말한다.모든 값은 데이터 타입을 갖으며 메모리에 2진수,즉 비트의 나열로 저장된다.// 10을 평가하고 메모리저장 + 20평가하고 메모리에 저장. 더한값 30을 메모리에 정함.고로 10,20 표현식임.10 + 20; // 302.리터럴값을 생성하는 가장 간단한 방법,사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식(notaion)을 말함.자바 스크립트 엔진은 런타임에 리터럴을 평가하여 값을 생성한다.3.표현식표현식은 값으로 평가될 수 있는 문이다.즉,표현식이 평가되면 값을 생성하거나 값을 참조한다.리터럴도 값으로 평가 따라서 리터럴도 표현식.값으로 표현될 수 있으면 무조건 표현식 ex) x = 1;모든 식별자 = 표현식.sum = 10 표현식인 문.sum !== 10 true false로 평가하는식. 같지 않으면 true로 평가됨.표현식인지 아닌지 구별하려면 변수를 할당해보면된다. 4.문-문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.-토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다.var(토큰) sum(토큰) =(토큰) 1(토큰) +(토큰) 2(토큰);(토큰)위 모든걸 통틀어서 문. 5.세미콜론과 세미콜론 자동 삽입 가능세미콜론은 문의 종료를 나타낸다.따라서 문은 세미콜론으로 끝나야 하지만 세미콜론 자동 삽입 기능이 암묵적으로 수행해줘서 굳이 붙이지 않아도된다.하지만 세미콜론 사용을 권장하는 분위기이므로 붙이도록 하자.if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다.이런 코드 블록은 자체 종결성을 갖기 때문이다. 6.표현식인 문과 표현식이 아닌 문표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.var x;// 1, 2, 1 + 2, x = 1 + 2는 표현식이다.// x = 1 + 2은 표현식이면서 완전한 문이기도 하다.x = 1 + 2;문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를 들어 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다.가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.아닌 문은 변수에 할당하면 에러가 난다.// 변수 선언문은 표현식이 아닌 문이다.var x; // 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.x = 100; // 표현식인 문은 값처럼 사용할 수 있다var foo = x = 100;console.log(foo); // 100 6.데이터 타입데이터 타입은 값의 종류를 말한다.자바스크립트의 모든 값은 데이터 타입을 갖는다.7개의 데이터 타입을 제공. 원시 타입과 객체 타입으로 분류.-원시 타입(primitive type)숫자 타입:정수와 실수 구분없이 하나의 숫자 타입만 존재.문자열 타입:문자열불리언 타입: 논리적 참과 거짓undefiend 타입:var 키워드로 선언된 변수에 암묵적으로 할당되는 ㄱ밧null 타입:값이 없다는 것을 의도적으로 명시할 때 사용하는 ㄱ밧Symbol 타입: ES6에서 새롭게 추가된 7번째 타입.-객체 타입: 객체,함수,배열 등 1.숫자 타입C나 Java의 경우, 정수(소숫점 이하가 없는 숫자)와 실수(소숫점 이하가 있는 숫자)를 구분하여 int,long,float,double 등과 같은 다양한 숫자 타입이 존재한다. 이유는 메모리 소비를 아끼려고.자바스크립트는 하나의 숫자 타입만 쓴다.ECMAScript 사양에 따르면 모든 수를 실수로 처리하며 정수만을 표현하기 위한 특별한 데이터타입은 없다.var integer = 10; // 정수var double = 10.12; // 실수var negative = -20; // 음의 정수 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다.infinity: 양의 무한대-infinity:음의 무한대NaN: 산술 연산 불가 // 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * ‘String’); // NaN 자바스크립트는 대소문자를 구별한다. 2.문자열 타입문자열(string) 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 전세계 대부분의 문자를 표현할 수 있다.자바스크립트에서 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다.(ex:’문자열’)문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함.만약 문자열을 따옴표로 감싸지 않으면 엔진은 키워드나 식별자와 같은 토큰으로 인식.자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미.// 문자열 타입var string;string = ‘문자열’; // 작은 따옴표string = “문자열”; // 큰 따옴표string = 문자열; // 백틱 (ES6) string = ‘작은 따옴표로 감싼 문자열 내의 “큰 따옴표”는 문자열로 인식된다.’;string = “큰 따옴표로 감싼 문자열 내의 ‘작은 따옴표’는 문자열로 인식된다.”; 다른 타입의 값과는 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자와 같은 토큰으로 인식한다.다른 타입의 값과는 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함 만약 안하면 키워드나 식별자같은 토큰으로 인식.// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.var string = hello; // ReferenceError: hello is not defined 3.템플릿 리터럴플릿 리터럴은 멀티라인 문자열(Multi-line string), 표현식 삽입(Expression interpolation), 태그드 템플릿(Tagged template) 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.일반적인 따옴표 대신 백틱(backtick) 를 사용한다. var template =Template literal`;console.log(template); // Template literal 3-1.멀티라인 문자열일반 문자열 내에서 줄바꿈은 허용되지 않는다.우리는 LF를 써야한다. 개행은 바로 밑줄로 가고 캐리지리턴으로 밑줄의 첫행으로 옮김.\\n 개행(LF, Line Feed): 다음 행으로 이동\\r 개행(CR, Carriage Return): 커서를 처음으로 이동 3-2.표현식 삽입문자열은 문자열 연산자 +를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작템플릿 리터럴 내에서는 표현식 삽입(Expression interpolation)을 통해 간단히 문자열을 삽입할 수 있다.var first = ‘Ung-mo’;var last = ‘Lee’; +는 산술연산자,문자열 연결 연산자 이어주는 2가지 역할. 문자열 + 문자열 or 강제로 뒤에를 문자열 타입으로 변환함.Ex)’My name is’ + 12345 // ES6: 표현식 삽입문자열은 문자열 연산자 +를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다.var first = ‘Ung-mo’;var last = ‘Lee’; // ES5: 문자열 연결console.log(‘My name is ‘ + first + ‘ ‘ + last + ‘.’);// My name is Ung-mo Lee.표현식 삽입은 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 타입 변환되어 삽입된다.console.log(1 + 2 = ${1 + 2}); // 1 + 2 = 3문자열 인터폴레이션은 반드시 템플릿 리터럴 내에서 사용해야 한다. 템플릿 리터럴 이외의 일반 문자열에서 표현식 삽입은 문자열 취급을 받는다.console.log(‘1 + 2 = ${1 + 2}’); // 1 + 2 = ${1 + 2} 4.불리언 타입참,거짓을 나타내는 true와 false. 5.undefined 타입undefined 타입의 값은 undefined가 유일.선언은 되었지만 아직 값을 할당하지 않은 변수에 접근하면 undefined가 반환.var foo;console.log(foo); // undefined변수에 값이 없다는 것을 명시하고 싶은 경우는 undefined대신 null을 할당하자. var 키워드로 선언한 변수만(const등으로 말고) undefined로 초기화된다.undefined 일부러 생성하지말자.let,const … let 변수. 6.null 타입null 타입의 값은 null이 유일.변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미.엔진은 누구도 참조하지않은 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.null타입까지 원시값을 만들때 리터럴로 만듬.대신에 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는게 베스트이다. 7.symbol 타입심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값.주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용.symbol 타입부터 함수로 만듬.참조를 못함.// 심볼 값 생성var key = Symbol(‘key’);console.log(typeof key); // symbol // 객체 생성var obj = {}; // 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.obj[key] = ‘value’;console.log(obj[key]); // value 8.객체 타입자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 크게 분류.객체 사이즈는 굉장히 클수도있다. 단점:메모리 용량을 소비한다. 장점:값의 추적이 용이하다. 객체는 하나를 바꿀때 다른값도 영향받을수있다.그래도 용량 때문에 객체는 원시값을 공유한다.자바스크립트는 원식값에다 .을 할시 객체로 인식한다. ex) ‘string’(원시값).length 69.데이터 타입의 필요성9-1.데이터 타입에 의한 메모리 공간의 확보와 참조모든 값은 메모리에 저장하고 참조할 수 있어야하는데, 먼저 확보해야할 메모리의 크기를 알아야한다. 그래서 타입마다 메모리 크기를 정해서 확보하게한다.자바스크립트의 변수는 엄밀히 따지면 타입이 없다.값은 타입이 있다.ex) var a; 는 할당을 안했으니 타입을 알 수가 없다.undefined로 평가 될 수 있다. 할당된 값에 의해서 동적 언어가 되는데 a = 1; 이런식으로 타입을 부여하면 동적 타입이 된다. 9-2.데이터 타입에 의한 값의 해석.데이터 타입이 필요한 이유.-값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해-값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해-메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 10.동적 타이핑 10.1 동적 타입 언어와 정적 타입 언어자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다.다만 var, let, const 키워드를 사용해 변수를 선언할 뿐.자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정.그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑(Dynamic typing)이라 하며 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입(Dynamic/Weak type) 언어. var foo;console.log(typeof foo); // undefined foo = 3;console.log(typeof foo); // number foo = ‘Hello’;console.log(typeof foo); // string foo = true;console.log(typeof foo); // boolean foo = null;console.log(typeof foo); // object foo = Symbol(); // 심볼console.log(typeof foo); // symbol foo = {}; // 객체console.log(typeof foo); // object foo = []; // 배열console.log(typeof foo); // object foo = function () {}; // 함수console.log(typeof foo); // function 위 예제들은 변수에 할당된 값의 데이터 타입을 반환한 것이다.자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.이러한 특징을 동적 타이핑이라한다.본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정.정적 타입 언어는 컴파일러 언어다. 10.2 동적 타입 언어와 변수동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.변수를 사용할때 주의사항-변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수값은 재할당에 의해 언제든지 변경될 수 있다. 이로 인해 동적 타입 언어인 자바스크립트는 타입을 잘못 예측해 오류가 발생할 가능성이 높다. 따라서 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 변수의 무분별한 남발은 금물이며 필요 최소한으로 유지하도록 주의해야 한다. -변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 변수의 유효 범위가 넓으면 넓을수록 변수로 인해 오류가 발생할 확률은 높아진다. -전역 변수는 최대한 사용하지 않도록 한다. 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고 다른 코드에 영향을 줄 가능성도 높다. 따라서 전역 변수는 프로그램의 복잡성을 증가시키고 처리의 흐름을 추적하기 어렵게 만들고, 오류가 발생했을 경우, 오류의 원인을 특정하기 어렵게 만든다. 전역 변수의 문제점과 전역 변수의 사용을 억제하는 방법에 대해서는 “14. 전역 변수의 문제점”에서 자세히 살펴보도록 하자. -변수보다는 상수를 사용해 값의 변경을 억제한다. -변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 변수 이름 뿐만이 아니라 모든 식별자(변수, 함수, 클래스 이름 등)는 존재 이유를 파약할 수 있는 적절한 이름을 네이밍해야 한다. 특히 식별자의 유효 범위가 넓을수록 보다 명확한 이름을 명명하도록 노력하도록 하자. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며 이는 협업과 생산성 향상에 도움을 준다. 변수 이름은 첫아이 이름을 짓듯이 심사숙고해서 지어야 한다.","categories":[],"tags":[]},{"title":"변수","slug":"js0219","date":"2020-02-19T07:35:30.000Z","updated":"2020-05-04T12:34:32.209Z","comments":true,"path":"2020/02/19/js0219/","link":"","permalink":"https://pkt0831.github.io/2020/02/19/js0219/","excerpt":"","text":"-변수1.변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.2.변수에 값을 저장하는 것을 할당(assignment)이라 하고,변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다.-식별자(identifier)1.변수 이름을 식별자라고도 부른다.2.식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름.3.식별자는 값이 아니라 메모리 주소를 기억하고 있다.4.식별자라는 용어는 변수 이름에만 국한하지않고, 함수,클래스등의 이름은 모두 식별자다.-변수 선언1.변수를 생성하는 것을 말한다.2.var의 단점. 블록 레벨 스코프를 지원하지않고 함수 레벨 스코프를 지원한다는 것이다.블록 레벨 스코프:함수 밖에서 선언하면 함수 스코프 변수처럼 전역 접근할 수 있고,블록 안에서 선언하면 자신을 정의한 블록과 하위 블록에서만 접근 가능.함수 레벨 스코프:함수 밖에서 선언한 함수 스코프 변수는 전역 범위를 가지고,함수 안에서 사용하면 함수 밖을 제외한 내부 어디서든 접근이 가능.3.변수 선언 이후,변수에 값을 할당하지 않았다.undefiend라는 값이 암묵적으로 할당되어 초기화되어있다.4.변수 선언 2단계.선언 단계: 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefind 할당.5.초기화 단계 거치지 않으면 확보된 메모리 공간에 이전의 애플리케이션 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값(Garbage value)라 한다.6.변수 뿐만 아니라 모든 식별자(함수, 클래스 등)반드시 선언 필요. 만약 선언하지않은 식별자에 접근하면 ReferenceErro(참조 에러) 발생.-변수 선언의 실행 시점과 변수 호이스팅1.자바스크립트 엔진은 변수 선언이 소스 코드의 어디에 있던지 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스 코드에 어디에 있던지 상관없이 변수를 참조할 수 있다.2.이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라한다.-값의 할당1.변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.2. -값의 재할당1.이미 값이 할당되어있는 변수에 새로운 값을 또다시 할당하는것.2.만약 재할당을 할 수 없어서 변수에 저장된 값을 저장할 수 없다면 변수가 아니라 상수라 부른다.-식별자 네이밍 규칙.1.식별자는 특수문자를 제외한 문자,숫자,underscore(),달러 기호($)포함할 수 있다.2.식별자는 특수문자를 제외한 문자,underscore(_), 달러 기호($)로 시작해야 한다.숫자 시작x3.예약어는 식별자로 사용 x4.변수나 함수 이름엔 카멜 케이스,생성자 함수 클래스의 이름에는 파스칼 케이스를 사용. 복습. 왜 원시값은 불변하고,객체는 가능한가?원시값(Primitive Value)원시값에는 6가지 유형이 있다. 1.boolean2.number3.string4.null5.undefined6Symbol(ES2015에서 새로 생김) 그리고 이 원시값에는 다음과 같은 특징이 있다. 1.불변(Immutable)하는 값이다.2.값으로써 비교가 가능하다. (심볼을 제외하고)3.typeof 연산자를 쓰면 각자 고유한 타입을 내뱉는다. (typeof null을 제외하고) 추측이지만 원시값이 변하는 성질이면 다른 래퍼런스가 같은 메모리 주소를 가리키고 있다가 내용을 바뀌게 된다면 영향을 받기 때문에 예측불가 상황이 발생한다.때문에 불변인것같다. 메모리셀 1 = 1byte = 8bit var a = 1 부분에서 호이스팅시 var a(선언문 먼저) = 1 부분은 런타임때 실행.객체 = 변경 가능한 값.(할당없이). ,하나의 값인데 여러개의 값을 가지고있음.원시값 = 변경 불가능한 값.객체를 원시값처럼 못바꾸게 얼린다=freeze프로그래밍 상수는 재할당이 금지된 변수이다.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-02-10T15:25:57.800Z","updated":"2020-02-10T15:25:57.800Z","comments":true,"path":"2020/02/11/hello-world/","link":"","permalink":"https://pkt0831.github.io/2020/02/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
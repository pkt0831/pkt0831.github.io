<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="My Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="pkt0831&#39;s Blog">
<meta property="og:url" content="https://pkt0831.github.io/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="My Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/25/js0225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/js0225/" class="post-title-link" itemprop="url">자바스크립트 25일 복습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-25 21:35:30 / Modified: 21:59:54" itemprop="dateCreated datePublished" datetime="2020-02-25T21:35:30+09:00">2020-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>11.원시 값과 객체의 비교</p>
<p>자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, symbol, 객체 타입)은 크게 원시 타입(primitive type)과 객체(object / reference type) 타입으로 구분할 수 있다.원시 타입과 객체 타입의 3가지 차이점.</p>
<p>-원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다.반대로 객체(참조)타입의 값은 변경 가능한 값이다.<br>-원시 값을 변수에 할당하면 실제 값이 저장된다. 객체는 변수에 할당하면 변수에는 참조 값이 저장된다.<br>-원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다.</p>
<p>1.원시 값</p>
<p>1.1 변경 불가능한 값<br>원시 타입의 값은 변경 불가능한 값이다. 오직 read only한 값이고 변경할 수 없다.<br>변수는 메모리 공간을 식별하기 위해 붙인 이름,값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과. 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.<br>값을 변경할 수 없다는 것은 재할당을 할 수 없단는 의미와는 다르다.변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다.<br>상수는 재할당이 금지된 변수를 말한다.왜냐하면 값을 저장하기 위해서는 메모리 공간이 필요하므로 변수의 일종이라고 할 수 있다. 차이점은 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있고,상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 키워드를 사용해 선언한 상수는 재할당이 금지된다.</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.</span></span><br><span class="line"><span class="comment">// 즉, 상수는 재할당이 금지된 변수일 뿐이다.</span></span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249625-f10fe980-5819-11ea-82a4-7d859a0295f0.png" alt="변수 선언"></p>
<p>만약 원시값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 주소를 바꿀 필요 없이 원시 값 자체를 수정하면 되지만, 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249631-f2411680-5819-11ea-89c2-511b725bce42.png" alt="변수 선언2"></p>
<p>원시값은 변경 불가능한 값이기에 직접 변경할 수 없다. 변수 값을 변경하기 위해서는 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후,변수가 참조하던 메모리 공간의 주소를 변경하는데 이런 특성을 불변성이라 한다.</p>
<p>만약 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치않게 변수 값이 변경될 수 있고,이것은 상태 변경을 추적하기 어렵게 만들기 때문에 신뢰성을 떨어뜨린다.</p>
<p>1.2. 문자열과 불변성</p>
<p>원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다. 원시 타입 별로 메모리 공간의 크기가 미리 정해져 있다. 문자열 타입(2byte)과 숫자 타입(8byte) 이외의 원시 타입은 크기를 명확히 규정하고 있지않다.</p>
<p>문자열은 0개 이상의 문자들로 이루어진 집합을 말하며 1개의 문자는 2byte의 메모리 공간에 저장된다. 따라서 몇개의 문자로 이루어졌는지에 따라 메모리 공간의 크기가 결정된다. 숫자값은 어떤값도 동일한 8byte가 필요하다.문자열은 원시 타입이며 변경 불가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello'</span>;</span><br><span class="line">str = <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure>
<p>첫번째 문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 문자열 ‘Hello’가 저장된 메모리 공간의 메모리 셀 주소를 가리킨다. 그리고 두번째 문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 식별자 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.</span></span><br><span class="line"><span class="comment">// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'S'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>1.3 값에 의한 전달</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);  <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>변수에 변수를 할당했을때 무엇이 어떻게 달라질까? copy = score에서 score는 변수값 80으로 평가되므로 변수 copy에도 80이 할당될 것이다. 이때 새로운 숫자값 80이 생성되어 변수 copy에 할당된다.</p>
<p>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다.변수 copy에 원시값을 갖는 변수 score를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값 80이 복사되어 전달된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score, copy); <span class="comment">// 80  80</span></span><br><span class="line"><span class="built_in">console</span>.log(score === copy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>변수 score와 copy의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249633-f2d9ad00-5819-11ea-8282-18522a066289.png" alt="캡쳐3"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 copy에는 변수 score의 값 80이 복사되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score, copy);    <span class="comment">// 80  80</span></span><br><span class="line"><span class="built_in">console</span>.log(score === copy); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 score와 변수 copy의 값은 다른 메모리 공간에 저장된 별개의 값이다.</span></span><br><span class="line"><span class="comment">// 따라서 변수 score의 값을 변경하여도 변수 copy의 값에는 어떠한 영향도 주지 않는다.</span></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score, copy);    <span class="comment">// 100  80</span></span><br><span class="line"><span class="built_in">console</span>.log(score === copy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/56964928/75249635-f2d9ad00-5819-11ea-8c49-9cbbdd52d740.png" alt="캡쳐4"></p>
<p>지만 변수에 원시값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시값을 참조하다가 어느 한쪽의 변수에 재할당이 이루어졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다. </p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249637-f3724380-5819-11ea-9dc7-68e191124f25.png" alt="캡쳐5"></p>
<p>엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.<br>값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼 수 있어야 하므로 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.</p>
<p>식별자로 값을 구별하여 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copy = score;</span><br></pre></td></tr></table></figure>

<p>위 값은 2가지 평가 방식이 가능하다.<br>1.새로운 80을 생성하여 메모리 주소를 전달하는 방식.할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.<br>2.socre의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.<br>이처럼 “값의 의한 전달”도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.<br>중요한 것은 변수에 원시값을 갖는 변수를 할당하는 경우, 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 원시값을 재할당하는 시점이든 결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.</p>
<p>2.객체</p>
<p>객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다.또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.원시 값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있다. </p>
<p>2.1 변경 가능한 값.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">변수에 객체를 할당</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다. 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값(Reference value)에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249639-f40ada00-5819-11ea-9467-9e8251c47590.png" alt="캡쳐7"></p>
<p>객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이 값을 참조 값이라고 한다. 변수는 이 참조 값을 통해 객체에 접근할 수 있다.<br>원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근하여 그 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee"&#125;</span></span><br></pre></td></tr></table></figure>

<p> 변수 person은 객체 { name: ‘Lee’ }를 가리키고(참조하고) 있다.</p>
<p>원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 이외에는 다른 방법이 없다. 하지만 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당없이 객체를 직접 변경할 수 있다. 즉, 재할당없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 값 갱신</span></span><br><span class="line">person.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.address = <span class="string">'Seoul'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Kim", address: "Seoul"&#125;</span></span><br></pre></td></tr></table></figure>
<p>원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리에 원시 값을 새롭게 생성해야 한다. 하지만 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다. 이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249640-f40ada00-5819-11ea-88cd-04bfa736ca47.png" alt="캡쳐8"></p>
<p>메모리를 효율적으로 사용하기위해 그리고 객체의 복사하고 생성하는 비용을 절약하여 퍼포먼스를 향상시키기 위해 객체는 변경 가능한 값으로 디자인되어있다.<br>객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>
<p>2.2. 참조에 의한 전달<br>여러 개의 식별자가 하나의 객체를 공유할 시 의미와 부작용.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 참조 값을 복사</span></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br></pre></td></tr></table></figure>

<p>객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75249641-f4a37080-5819-11ea-98e2-0e43a87a2864.png" alt="캡쳐9"></p>
<p>원본 person를 사본 copy에 할당하면 원본 person의 참조 값을 복사하여 copy에 저장한다.이때 원본 person와 사본 copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 다시 말해, 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.</span></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 참조한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(copy === person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy를 통해 객체를 변경한다.</span></span><br><span class="line">copy.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person을 통해 객체를 변경한다.</span></span><br><span class="line">person.address = <span class="string">'Seoul'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 가리키고 있다.</span></span><br><span class="line"><span class="comment">// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Kim", address: "Seoul"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);   <span class="comment">// &#123;name: "Kim", address: "Seoul"&#125;</span></span><br></pre></td></tr></table></figure>

<p>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사하여 전달한다는 면에서 동일하다. 다만 식별자가 기억하는 메모리 공간에 저장되어 있는 값이 원시 값인지 참조 값인지의 차이만 있을 뿐이다. 따라서 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/24/js0224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/js0224/" class="post-title-link" itemprop="url">자바스크립트 25일 예습 및 복습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 21:35:30" itemprop="dateCreated datePublished" datetime="2020-02-24T21:35:30+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-25 19:34:48" itemprop="dateModified" datetime="2020-02-25T19:34:48+09:00">2020-02-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.타입 변환<br>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.<br>var x = 10;</p>
<p>// 명시적 타입 변환<br>// 숫자를 문자열로 타입 캐스팅한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 x의 값이 변경된 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>
<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="number">10.</span>tostring ()벗기면 소수로 판별하기때문에 에러가남. <span class="number">10</span> + <span class="string">''</span>써야한다.</span><br></pre></td></tr></table></figure>

<p>// 암묵적 타입 변환<br>// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = x + <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 x의 값이 변경된 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x, x); <span class="comment">// number 10</span></span><br></pre></td></tr></table></figure>
<p>명시적,암묵적 타입 변환이 기존 원시값을 변경하는건 아니다.타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.<br>// 원시값 1이 ‘1’로 직접 변경되는 것이 아니다.<br>// 1을 사용해 타입이 다른 ‘1’을 새롭게 생성하여 ‘1’ + ‘’을 평가한다.<br>1 + ‘’ // ‘1’</p>
<p>암묵적 타입 변환은 재할당이 아니라 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.<br>위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘’을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘’를 평가한다. 이때 자동 생성된 문자열 ‘10’은 변수 x에 할당되는 것이 아니다. 따라서 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다.</p>
<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다</p>
<p>2.암묵적 타입 변환<br>자바스크립트 엔진은 표현식을 평가할때 개발자의 의도 상관없이 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.<br>// 피연산자가 모두 문자열 타입이여야 하는 문맥<br>‘10’ + 2  // ‘102’</p>
<p>// 피연산자가 모두 숫자 타입이여야 하는 문맥<br>5 * ‘10’  // 50</p>
<p>// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥<br>!0 // true<br>if (1) { }</p>
<p>2.1 문자열 타입으로 변환</p>
<p>1 + ‘2’ // “12”</p>
<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다.</li>
</ul>
<p>템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.</p>
<p>console.log(<code>1 + 1 = ${1 + 1}</code>); // “1 + 1 = 2”<br>$(1+1) 1+1을 먼저 연산하고 그다음에 타입변환된다.</p>
<p>문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변호나 수행할때의 예.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입</span></span><br><span class="line"><span class="number">0</span> + <span class="string">''</span>              <span class="comment">// "0"</span></span><br><span class="line"><span class="number">-0</span> + <span class="string">''</span>             <span class="comment">// "0"</span></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span>              <span class="comment">// "1"</span></span><br><span class="line"><span class="number">-1</span> + <span class="string">''</span>             <span class="comment">// "-1"</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span>            <span class="comment">// "NaN"</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="string">''</span>       <span class="comment">// "Infinity"</span></span><br><span class="line">-<span class="literal">Infinity</span> + <span class="string">''</span>      <span class="comment">// "-Infinity"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span>           <span class="comment">// "true"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">''</span>          <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span>           <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span>      <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">(<span class="built_in">Symbol</span>()) + <span class="string">''</span>     <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">(&#123;&#125;) + <span class="string">''</span>           <span class="comment">// "[object Object]"       (&#123;&#125;)는 객체 리터럴.</span></span><br><span class="line"><span class="built_in">Math</span> + <span class="string">''</span>           <span class="comment">// "[object Math]"</span></span><br><span class="line">[] + <span class="string">''</span>             <span class="comment">// ""</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>] + <span class="string">''</span>       <span class="comment">// "10,20"</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) + <span class="string">''</span> <span class="comment">// "function()&#123;&#125;"</span></span><br><span class="line"><span class="built_in">Array</span> + <span class="string">''</span>          <span class="comment">// "function Array() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>
<p>2.2숫자 타입으로 변환</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span>    <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span>   <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span>  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다.산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>
<p>‘1’ &gt; 0   // true</p>
<p>비교연산자는 불리언 값을 만드는 것이다. 때문에 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p>
<p>엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다.+ 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다.</p>
<p>// 문자열 타입<br>+’’             // 0<br>+’0’            // 0<br>+’1’            // 1<br>+’string’       // NaN</p>
<p>// 불리언 타입<br>+true           // 1<br>+false          // 0</p>
<p>// null 타입<br>+null           // 0</p>
<p>// undefined 타입<br>+undefined      // NaN</p>
<p>// 심볼 타입<br>+Symbol()       // TypeError: Cannot convert a Symbol value to a number</p>
<p>// 객체 타입<br>+{}             // NaN<br>+[]             // 0<br>+[10, 20]       // NaN<br>+(function(){}) // NaN</p>
<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다</p>
<p>2.3. 불리언 타입으로 변환</p>
<p>if (‘’) console.log(x);</p>
<p>if,for같은 제어문,삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다. 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>
<p>if (‘’)    console.log(‘1’);<br>if (true)  console.log(‘2’);<br>if (0)     console.log(‘3’);<br>if (‘str’) console.log(‘4’);<br>if (null)  console.log(‘5’);</p>
<p>// 2 4</p>
<p>자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.</p>
<p>false로 평가되는 Falsy 값들.<br>false<br>undefined<br>null<br>0, -0<br>NaN<br>’’ (빈문자열)</p>
<p>// 아래의 조건문은 모두 코드 블록을 실행한다.<br>if (!false)     console.log(false + ‘ is falsy value’);<br>if (!undefined) console.log(undefined + ‘ is falsy value’);<br>if (!null)      console.log(null + ‘ is falsy value’);<br>if (!0)         console.log(0 + ‘ is falsy value’);<br>if (!NaN)       console.log(NaN + ‘ is falsy value’);<br>if (!’’)        console.log(‘’ + ‘ is falsy value’);</p>
<p>Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<p>// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.<br>function isFalsy(v) {<br>  return !v;<br>}</p>
<p>// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.<br>function isTruthy(v) {<br>  return !!v;<br>}</p>
<p>// 모두 true를 반환한다.<br>console.log(isFalsy(false));<br>console.log(isFalsy(undefined));<br>console.log(isFalsy(null));<br>console.log(isFalsy(0));<br>console.log(isFalsy(NaN));<br>console.log(isFalsy(‘’));</p>
<p>// 모두 true를 반환한다.<br>console.log(isTruthy(true));<br>// 빈 문자열이 아닌 문자열은 Truthy 값이다.<br>console.log(isTruthy(‘0’));<br>console.log(isTruthy({}));<br>console.log(isTruthy([]));</p>
<ol start="3">
<li>명시적 타입 변환<br>문자열은 원시값이다. 문자열 객체는 (‘Hello’).touppercase()<br>개발자 의도에 의해 명시적으로 타입 변경 하는 3가지 방법.</li>
<li>표준 빌트인 생성자 함수를 new 연산자 없이 호출</li>
<li>js에서 제공하는 빌트인 메소드를 사용.</li>
<li>암묵적 변환을 이용하는 방법.(제일 많이 쓰인다.)</li>
</ol>
<p>3.1. 문자열 타입으로 변환<br>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 3가지 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법(잘 쓰이지 않는다.)</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>));        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>));      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">Infinity</span>)); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>));     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">false</span>));    <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).toString());        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">NaN</span>).toString());      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">Infinity</span>).toString()); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).toString());     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span>).toString());    <span class="comment">// "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법(제일 많이 쓰인다.)</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">''</span>);        <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">''</span>);      <span class="comment">// "NaN"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> + <span class="string">''</span>); <span class="comment">// "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">''</span>);     <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">''</span>);    <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure>

<p>3.2. 숫자 타입으로 변환</p>
<p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 4가지 방법.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'0'</span>));     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'-1'</span>));    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'0'</span>));       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'-1'</span>));      <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>)); <span class="comment">// 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'0'</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'-1'</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'10.53'</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">false</span>);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> * <span class="number">1</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-1'</span> * <span class="number">1</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10.53'</span> * <span class="number">1</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> * <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * <span class="number">1</span>);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>3.3. 불리언 타입으로 변환</p>
<p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 2가지 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'x'</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>));        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'false'</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">Infinity</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타 입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([]));        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'x'</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">''</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'false'</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">1</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">Infinity</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!&#123;&#125;);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!![]);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>4.단축 평가</p>
<p>논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.”</p>
<p>‘Cat’ &amp;&amp; ‘Dog’ // ‘Dog’</p>
<p>논리곱(&amp;&amp;) 연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다.첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다.두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 논리곱 연산자는 논리 연산의 결과를 결정한 두번째 피연산자 즉, 문자열 ‘Dog’를 그대로 반환한다.<br>논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다.</p>
<p>‘Cat’ || ‘Dog’ // ‘Cat’</p>
<p>논리합(||) 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.<br>첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가.논리합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉, 문자열 ‘Cat’를 그대로 반환한다.논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이와 같이 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다.축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행한다.</p>
<p>단축 평가 규칙.<br>단축 평가 표현식.    평가 결과<br>true || anything      true<br>false || anything      anything<br>true &amp;&amp; anything      anything<br>false &amp;&amp; anything      false</p>
<p>// 논리합(||) 연산자<br>‘Cat’ || ‘Dog’  // ‘Cat’<br>false || ‘Dog’  // ‘Dog’<br>‘Cat’ || false  // ‘Cat’</p>
<p>// 논리곱(&amp;&amp;) 연산자<br>‘Cat’ &amp;&amp; ‘Dog’  // Dog<br>false &amp;&amp; ‘Dog’  // false<br>‘Cat’ &amp;&amp; false  // false</p>
<p>단축 평가를 사용하면 if문을 대체할 수 있다. 주어진 조건이 Truthy 값(참으로 평가되는 값)일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// 주어진 조건이 true일 때<br>if (done) message = ‘완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done &amp;&amp; ‘완료’;<br>console.log(message); // 완료</p>
<p>주어진 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야 한다면 논리합(||) 연산자 표현식으로 if문을 대체할 수 있다.</p>
<p>var done = false;<br>var message = ‘’;</p>
<p>// 주어진 조건이 false일 때<br>if (!done) message = ‘미완료’;</p>
<p>// if문은 단축 평가로 대체 가능하다.<br>message = done || ‘미완료’;<br>console.log(message); // 미완료</p>
<p>삼항 조건 연산자는 if..else문을 대체할 수 있다.</p>
<p>var done = true;<br>var message = ‘’;</p>
<p>// if…else문<br>if (done) message = ‘완료’;<br>else      message = ‘미완료’;<br>console.log(message); // 완료</p>
<p>// if..else문은 삼항 조건 연산자로 대체 가능하다.<br>message = done ? ‘완료’ : ‘미완료’;<br>console.log(message); // 완료</p>
<p>-단축 평가는 아래와 같은 상황에서 유용하게 사용된다.</p>
<p>객체가 null인지 확인하고 프로퍼티를 참조할 때<br>var elem = null;</p>
<p>console.log(elem.value); // TypeError: Cannot read property ‘value’ of null<br>console.log(elem &amp;&amp; elem.value); // null</p>
<p>객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다.</p>
<p>함수 매개변수에 기본값을 설정할 때</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.</p>
<p>10.객체 리터럴</p>
<p>1.객체란?<br>자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.<br>원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 키(Key) = 값을 찾아오는 단서.</p>
<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다.<br>-프로퍼티: 객체의 상태를 나타내는 값(data)<br>-메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</p>
<p>객체와 함수<br>자바스크립트의 객체는 함수와 밀접한 관계를 갖는다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다. 즉, 객체를 이해해야 함수를 제대로 이해할 수 있고 반대로 함수를 이해해야 객체를 정확히 이해할 수 있다.</p>
<p>2.객체 리터럴에 의한 객체 생성<br>블록문이 아니기 대문에 {}; ;세미콜론 붙인다.<br>인스턴스<br>인스턴스(instance)란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다.</p>
<p>자바스크립트는 프로토타입 기반 객체향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다.</p>
<p>-객체 리터럴<br>-Object 생성자 함수<br>-생성자 함수<br>-Object.create 메소드<br>-클래스 (ES6)</p>
<p>가장 일바적인 방법은 객체 리터럴을 사용하는 방법이다. 객체 리터럴은 객체를 생성하는 표기법이다.<br>객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee", sayHello: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> empty = &#123;&#125;; <span class="comment">// 빈 객체</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> empty); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>객체 리터럴의 중괄호는 코드 블록 의미 x , 코드 블록의 닫는 중괄호 뒤에는 세미 콜론 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이기에 닫는 중괄호 뒤에는 세미 콜론을 붙인다.</p>
<p>3.프로퍼티<br>-객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성.<br>-프로퍼티 나열할 때는 쉼표(,)로 구분.<br>-마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 name, 프로퍼티 값은 'Lee'</span></span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 age, 프로퍼티 값은 20</span></span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값.<br>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값.<br>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다.프로퍼티 키를 나누는 이유는 식별자는 스코프에서 찾고 키는 프로타입 체인에서 찾는데 그걸 구별하기 위해서.<br>symbol 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다.<br>이때 프로퍼티 키는 문자열이므로 따옴표(‘…’ 또는 “…”)로 묶어야 하지만 유효한 이름인 경우,따옴표를 생략할 수 있다.식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Ung-mo'</span>, <span class="comment">// 유효한 이름</span></span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>   <span class="comment">// 유효하지 않은 이름</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;firstName: "Ung-mo", last-name: "Lee"&#125;</span></span><br></pre></td></tr></table></figure>
<p>빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지는 않는다.하지만 키로서의 의미를 갖지 못한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="string">''</span>: <span class="string">''</span>  <span class="comment">// 빈문자열도 프로퍼티 키로 사용할 수 있다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123;"": ""&#125;</span></span><br></pre></td></tr></table></figure>
<p>-프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.<br>-var, function과 같은 예약어(Reserved word)를 프로퍼티 키로 사용해도 에러가 발생하지 않는다.<br>-이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.</p>
<p>4.메소드</p>
<p>자바 스크립트에서 사용할 수 있는 모든 값 = 프로퍼티 값으로 사용 가능= 객체 = 함수. 따라서 함수는 값으로 취급 가능하고 프로퍼티의 값이 될 수 있다.</p>
<p>프로퍼티 값이 함수일 경우, 일반 함수와 구분하기위해 메소드라 부른다.메소드= 객체에 제한되어 있는 함수를 의미.메소드도 결국은 프로퍼티다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  radius: <span class="number">5</span>, <span class="comment">// ← 프로퍼티</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 원의 지름</span></span><br><span class="line">  getDiameter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// ← 메소드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius; <span class="comment">// this는 circle를 가리킨다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>는 객체(프로퍼티)를 가리킨다.</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>5.프로퍼티 접근<br>-name이라는 전역 객체가 있다.<br>-프로퍼티 값에 접근하려면 마침표(.)를 사용하는 마침표 표기법(Dot notation) 또는 대괄호([…])를 사용하는 대괄호 표기법(Bracket notation)을 사용한다.<br>-프로퍼티 키가 js에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용 가능.<br>-마침표 또는 대괄호의 좌측에는 표현식 기술. 우측 또는 대괄호 내부에는 프로퍼티 키를 지정.<br>식별자 규칙을 지키면 ‘ ‘ 안붙여도 엔진이 자동으로 문자열로 해석함.안지키면 ‘’해줘야함.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마침표 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>]); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>
<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다.</p>
<p>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값<br>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</p>
<p>대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. </p>
<p>-객체에 존재하지 않는 프로퍼티에 접근하면 ReferenceError가 아닌 undefined를 반환한다.<br>-프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법을 사용해야 한다.<br>-대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.</p>
<p>6.프로퍼티 값 갱신<br>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.</span></span><br><span class="line">person.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123;name: "Kim"&#125;</span></span><br></pre></td></tr></table></figure>
<p>7.프로퍼티 동적 생성</p>
<p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.있으면 덮어쓴다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;                        &#123;&#125;는 할당 직전에 생성됨.없는걸 지우면 무시한다.</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 객체에는 age 프로퍼티가 존재하지 않는다.</span></span><br><span class="line"><span class="comment">// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee", age: 20&#125;</span></span><br></pre></td></tr></table></figure>
<p>8.프로퍼티 삭제<br>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다.</p>
<ol start="9">
<li>ES6에서 추가된 객체 리터럴의 확장 기능</li>
</ol>
<p>9.1. 프로퍼티 축약 표현</p>
<p>-객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.<br>// ES5<br>var x = 1, y = 2;</p>
<p>var obj = {<br>  x: x,                      x: x (이자리는 표현식이 와야하는 자리)<br>  y: y<br>};</p>
<p>console.log(obj); // {x: 1, y: 2}</p>
<p>-ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략(Property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.<br>9.2. 프로퍼티 키 동적 생성</p>
<p>-문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능.<br>-프로퍼티 키로 사용할 표현식을 대괄호([…])로 묶어야 한다. 이를 계산된 프로퍼티 이름(Computed property name)이라 한다.<br>-ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.</p>
<p>9.3. 메소드 축약 표현</p>
<p>-ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다.<br>-ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.<br>-S6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/22/js2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/22/js2022/" class="post-title-link" itemprop="url">자바스크립트 24일 예습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 22:35:30" itemprop="dateCreated datePublished" datetime="2020-02-22T22:35:30+09:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-24 20:41:44" itemprop="dateModified" datetime="2020-02-24T20:41:44+09:00">2020-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>7.연산자<br>연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다.<br>피연산자는 값으로 평가될 수 있는 표현식이어야 한다.<br>모든 연산자는 값을 만든다. 모든 연산자 = 표현식이다.</p>
<p>// 산술 연산자<br>5 * 4 // -&gt; 20<br>// 문자열 연결 연산자<br>‘My name is ‘ + ‘Lee’ // -&gt; ‘My name is Lee’<br>// 할당 연산자<br>color = ‘red’ // -&gt; ‘red’<br>// 비교 연산자<br>3 &gt; 5 // -&gt; false<br>// 논리 연산자<br>true &amp;&amp; false // -&gt; false<br>// 타입 연산자<br>typeof ‘Hi’ // -&gt; string</p>
<p>1.산술 연산자<br>산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다.<br>산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>
<p>1.1. 이항 산술 연산자<br>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.<br>5 + 2; // -&gt; 7<br>5 - 2; // -&gt; 3<br>5 * 2; // -&gt; 10<br>5 / 2; // -&gt; 2.5<br>5 % 2; // -&gt; 1</p>
<p>1.2. 단항 산술 연산자<br>단항(Unary) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 주의할 것은 이항 산술 연산자와는 달리 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.</p>
<p>-피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.</p>
<p>-피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.</p>
<p>var x = 5, result;</p>
<p>// 선할당 후증가 (Postfix increment operator)<br>result = x++;<br>console.log(result, x); // 5 6<br>x 먼저, 후에 1증가 </p>
<p>// 선증가 후할당 (Prefix increment operator)<br>result = ++x;<br>console.log(result, x); // 7 7</p>
<p>// 선할당 후감소 (Postfix decrement operator)<br>result = x–;<br>console.log(result, x); // 7 6</p>
<p>// 선감소 후할당 (Prefix decrement operator)<br>result = –x;<br>console.log(result, x); // 5 5</p>
<ul>
<li>단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.</li>
</ul>
<p>// 아무런 효과가 없다.<br>+10;    // -&gt; 10<br>+(-10); // -&gt; -10</p>
<p>// 문자열을 숫자로 타입 변환한다.<br>+’10’; // -&gt; 10</p>
<p>// 불리언 값을 숫자로 타입 변환한다.<br>+true; // -&gt; 1</p>
<p>// 불리언 값을 숫자로 타입 변환한다.<br>+false; // -&gt; 0</p>
<p>// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.<br>+’Hello’; // -&gt; NaN</p>
<p>– 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.</p>
<p>// 부호를 반전한다.<br>-(-10); // -&gt; 10</p>
<p>// 문자열을 숫자로 타입 변환한다.<br>-‘10’; // -&gt; -10</p>
<p>// 불리언 값을 숫자로 타입 변환한다.<br>-true; // -&gt; -1</p>
<p>// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.<br>-‘Hello’; // -&gt; NaN</p>
<p>1.3 문자열 연결 연산자<br> 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작,그외엔 덧셈 연산자로 동작한다.</p>
<p> // 문자열 연결 연산자<br>‘1’ + 2; // -&gt; ‘12’<br>1 + ‘2’; // -&gt; ‘12’</p>
<p>// 산술 연산자<br>1 + 2; // -&gt; 3</p>
<p>// true는 1로 타입 변환된다.<br>1 + true; // -&gt; 2</p>
<p>// false는 0으로 타입 변환된다.<br>1 + false; // -&gt; 1</p>
<p>// null는 0으로 타입 변환된다.<br>1 + null; // -&gt; 1</p>
<p>// undefined는 숫자로 타입 변환되지 않는다.<br>+undefined;    // -&gt; NaN<br>1 + undefined; // -&gt; NaN</p>
<p>자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.<br>1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다.</p>
<p>이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다.<br>+/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다.</p>
<p>2.할당 연산자</p>
<p>할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다.</p>
<p>var x;</p>
<p>x = 10;<br>console.log(x); // 10</p>
<p>x += 5; // x = x + 5;<br>console.log(x); // 15</p>
<p>x -= 5; // x = x - 5;<br>console.log(x); // 10</p>
<p>x *= 5; // x = x * 5;<br>console.log(x); // 50</p>
<p>x /= 5; // x = x / 5;<br>console.log(x); // 10</p>
<p>x %= 5; // x = x % 5;<br>console.log(x); // 0</p>
<p>var str = ‘My name is ‘;</p>
<p>// 문자열 연결 연산자<br>str += ‘Lee’; // str = str + ‘Lee’;</p>
<p>console.log(str); // ‘My name is Lee’</p>
<p>var x;</p>
<p>// 할당문은 표현식인 문이다.<br>console.log(x = 10); // 10</p>
<p>3.비교 연산자</p>
<p>비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</p>
<p>3.1. 동등 / 일치 비교 연산자</p>
<p>동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.</p>
<p>등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다. 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</p>
<p>// 동등 비교<br>5 == 5; // -&gt; true</p>
<p>// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.<br>5 == ‘5’; // -&gt; true</p>
<p>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵기 때문에 부작용을 일으킬 수 있으므로 사용하지 않는 편이 좋다.</p>
<p>// 동등 비교. 결과를 예측하기 어렵다.<br>‘0’ == ‘’; // -&gt; false<br>0 == ‘’;   // -&gt; true<br>0 == ‘0’;  // -&gt; true<br>false == ‘false’;   // -&gt; false<br>false == ‘0’;       // -&gt; true<br>false == null;      // -&gt; false<br>false == undefined; // -&gt; false</p>
<p>동등 비교(==) 연산자는 예측하기 어려운 결과를 만들어낸다.<br>일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 다시 말해 암묵적 타입 변환을 하지 않고 값을 비교한다.<br>=== 쓰면 타입도 같고 값도 같아야한다.그래서 3개짜리를 써야한다. ==개는 타입을 암묵적으로 변환시키기 때문에 쓰지 말아야한다.</p>
<p>// 일치 비교<br>5 === 5; // -&gt; true</p>
<p>// 암묵적 타입 변환을 하지 않고 값을 비교한다.<br>// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.<br>5 === ‘5’; // -&gt; false</p>
<p>// NaN은 자신과 일치하지 않는 유일한 값이다.NaN은 숫자 타입이다.<br>NaN === NaN; // -&gt; false</p>
<p>NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다.</p>
<p>// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.<br>isNaN(NaN); // -&gt; true<br>isNaN(10);  // -&gt; false<br>isNaN(1 + undefined); // -&gt; true</p>
<p>자바스크립트에는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다.<br>// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.<br>0 === -0; // -&gt; true<br>0 == -0;  // -&gt; true<br>0과 -0을 비교하려면 object.js를 써야한다.</p>
<p>-0 === +0;         // -&gt; true<br>Object.is(-0, +0); // -&gt; false</p>
<p>NaN === NaN;         // -&gt; false<br>Object.is(NaN, NaN); // -&gt; true</p>
<p>부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다.</p>
<p>// 부동등 비교<br>5 != 8;   // -&gt; true<br>5 != 5;   // -&gt; false<br>5 != ‘5’; // -&gt; false</p>
<p>// 불일치 비교<br>5 !== 8;   // -&gt; true<br>5 !== 5;   // -&gt; false<br>5 !== ‘5’; // -&gt; true</p>
<p>3.2. 대소 관계 비교 연산자<br>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<p>// 대소 관계 비교<br>5 &gt; 0;  // -&gt; true<br>5 &gt; 5;  // -&gt; false<br>5 &gt;= 5; // -&gt; true<br>5 &lt;= 5; // -&gt; true</p>
<ol start="4">
<li>삼항 조건 연산자<br>삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다.</li>
</ol>
<p>조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값</p>
<p>물음표(?) 앞의 첫번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다.</p>
<p>var x = 2;</p>
<p>// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.<br>var result = x % 2 ? ‘홀수’ : ‘짝수’;</p>
<p>console.log(result); // 짝수</p>
<p>삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다.</p>
<p>var x = 2, result;</p>
<p>// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.<br>if (x % 2) result = ‘홀수’;<br>else       result = ‘짝수’;</p>
<p>console.log(result); // 짝수</p>
<p>하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없다.</p>
<p>var x = 10;</p>
<p>// if…else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.<br>var result = if (x % 2) { result = ‘홀수’; } else { result = ‘짝수’; };<br>// SyntaxError: Unexpected token if</p>
<p>삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 따라서 삼항 조건 연산자식은 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.</p>
<p>var x = 10;</p>
<p>// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.<br>var result = x % 2 ? ‘홀수’ : ‘짝수’;<br>console.log(result); // 짝수<br>if문의 대용품으로 쓰여짐.if로 쓰면 좋을지 삼황연산자로 쓰면 좋을지 고민해야된다.<br>x % 2(조건) true로 평가되면 ‘홀수’가 평가된다.</p>
<p>조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. 하지만 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면 if…else 문이 보다 가독성이 좋다.</p>
<p>5.논리 연산자</p>
<p>논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.<br>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.<br>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.</p>
<ol start="6">
<li>쉼표 연산자<br>쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.<br>var x, y, z;</li>
</ol>
<p>x = 1, y = 2, z = 3; // 3</p>
<ol start="7">
<li>그룹 연산자</li>
</ol>
<p>10 * 2 + 3; // -&gt; 23</p>
<p>// 그룹 연산자를 사용하여 우선 순위 조절<br>10 * (2 + 3); // -&gt; 50</p>
<p>8.typeof 연산자</p>
<p>ypeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다.</p>
<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는 것에 주의, null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.<br>선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다.</p>
<p>9.지수 연산자<br>ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다.</p>
<p>2 ** 2;   // -&gt; 4<br>2 ** 2.5; // -&gt; 5.65685424949238<br>2 ** 0;   // -&gt; 1<br>2 ** -2;  // -&gt; 0.25</p>
<p>음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다.</p>
<p>-5 ** 2;<br>// -&gt; SyntaxError<br>(-5) ** 2; // -&gt; 25</p>
<p>지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.<br>var num = 5;<br>num **= 2; // -&gt; 25</p>
<p>지수 연산자는 모든 이항 연산자보다 우선 순위가 높다.<br>2 * 5 ** 2; // -&gt; 50</p>
<ol start="10">
<li>연산자의 부수 효과</li>
</ol>
<p>대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어, 1 * 2는 다른 코드에 어떠한 영향도 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과(side effect)가 있다.</p>
<p>부수 효과과 있는 연산자는 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자이다.</p>
<p>var x;</p>
<p>// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.<br>// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.<br>x = 1;<br>console.log(x); // 1</p>
<p>// 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.<br>// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.<br>x++;<br>console.log(x); // 2</p>
<p>var o = { a: 1 };</p>
<p>// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.<br>// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.<br>delete o.a;<br>console.log(o); // {}</p>
<p>8.제어문</p>
<p>제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.<br>let,const로 만들면 유효범위가 생김.</p>
<ol>
<li>블록문</li>
</ol>
<p>블록문(Block statement/Compound statement)는 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.</p>
<p>블록문의 끝에는 세미콜론을 붙이지 않는다.js 에선 블록문을 스코프로 인정하지않는다.여러문을 하나로 묶는 역할을 함.</p>
<p>// 블록문<br>{<br>  var foo = 10;<br>  console.log(foo);<br>}</p>
<p>// 제어문<br>var x = 0;<br>while (x &lt; 10) {<br>  x++;<br>}<br>console.log(x); // 10</p>
<p>// 함수 선언문<br>function sum(a, b) {<br>  return a + b;<br>}<br>console.log(sum(1, 2)); // 3</p>
<ol start="2">
<li>조건문</li>
</ol>
<p>조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>
<p>2.1 if..else 문</p>
<p>주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참(true)일 경우, if 문 다음의 코드 블록이 실행되고 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다.</p>
<p>if (조건식) {<br>  // 조건식이 참이면 이 코드 블록이 실행된다.<br>} else {<br>  // 조건식이 거짓이면 이 코드 블록이 실행된다.<br>}</p>
<p>if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 데이터 타입이 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.</p>
<p>조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if 문을 사용한다.<br>if (조건식1) {<br>  // 조건식1이 참이면 이 코드 블록이 실행된다.<br>} else if (조건식2) {<br>  // 조건식2이 참이면 이 코드 블록이 실행된다.<br>} else {<br>  // 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.<br>}</p>
<p>else if 문과 else 문은 옵션이다. 즉, 사용할 수도 있고 사용하지 않을 수도 있다. if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다.</p>
<p>var num = 2;<br>var kind;</p>
<p>// if 문<br>if (num &gt; 0) {<br>  kind = ‘양수’; // 음수를 구별할 수 없다<br>}<br>console.log(kind); // 양수</p>
<p>// if…else 문<br>if (num &gt; 0) {<br>  kind = ‘양수’;<br>} else {<br>  kind = ‘음수’; // 0은 음수가 아니다.<br>}<br>console.log(kind); // 양수</p>
<p>// if…else if 문<br>if (num &gt; 0) {<br>  kind = ‘양수’;<br>} else if (num &lt; 0) {<br>  kind = ‘음수’;<br>} else {<br>  kind = ‘영’;<br>}<br>console.log(kind); // 양수</p>
<p>만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.</p>
<p>var num = 2;<br>var kind;</p>
<p>if (num &gt; 0)      kind = ‘양수’;<br>else if (num &lt; 0) kind = ‘음수’;<br>else              kind = ‘영’;</p>
<p>console.log(kind); // 양수</p>
<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.<br>// x가 짝수이면 문자열 ‘짝수’를 반환하고 홀수이면 문자열 ‘홀수’를 반환한다.<br>var x = 2;<br>var result;</p>
<p>if (x % 2) { // 2 % 2는 0이다. 이때 0은 false로 암묵적 강제 변환된다.<br>  result = ‘홀수’;<br>} else {<br>  result = ‘짝수’;<br>}</p>
<p>console.log(result); // 짝수</p>
<p>두가지 경우의 수(‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수(양수, 음수, 영)를 갖는 경우는 아래와 같이 바꿔 쓸 수 있다.</p>
<p>// x가 짝수이면 문자열 ‘짝수’를 반환하고 홀수이면 문자열 ‘홀수’를 반환한다.<br>var x = 2;</p>
<p>// 0은 false로 취급된다.<br>var result = x % 2 ? ‘홀수’ : ‘짝수’;</p>
<p>console.log(result); // 짝수</p>
<p>num &gt; 0 ? ‘양수’ : ‘음수’는 표현식이다. 즉, 삼항 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다는 차이가 있다.</p>
<p>2.2. switch 문</p>
<p>switch (표현식) {<br>  case 표현식1:<br>    switch 문의 표현식과 표현식1이 일치하면 실행될 문;<br>    break;<br>  case 표현식2:<br>    switch 문의 표현식과 표현식2가 일치하면 실행될 문;<br>    break;<br>  default:<br>    switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;<br>}</p>
<p>if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.</p>
<p>3.반복문</p>
<p>반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.</p>
<p>자바스크립트는 3가지의 반복문 for 문, while 문, do…while 문을 제공한다.</p>
<p>3.1 for 문<br>for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다.</p>
<p>3.2 while 문<br>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다</p>
<p>3.3. do…while 문<br>do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다.</p>
<ol start="4">
<li><p>break 문<br>break 문은 코드 블록을 탈출한다. break는 while,for,switch 문에만 쓰인다.</p>
</li>
<li><p>continue 문<br>ntinue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/20/js0220/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/20/js0220/" class="post-title-link" itemprop="url">자바스크립트 21일 예습 및 복습 추가.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-20 22:35:30" itemprop="dateCreated datePublished" datetime="2020-02-20T22:35:30+09:00">2020-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-24 10:30:41" itemprop="dateModified" datetime="2020-02-24T10:30:41+09:00">2020-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>21일 예습.<br>5.표현식과 문<br>1.값<br>값(value)은 식(표현식,expression)이 평가(evaluate)되어 생성된 결과를 말한다.<br>모든 값은 데이터 타입을 갖으며 메모리에 2진수,즉 비트의 나열로 저장된다.<br>// 10을 평가하고 메모리저장 + 20평가하고 메모리에 저장. 더한값 30을 메모리에 정함.고로 10,20 표현식임.<br>10 + 20; // 30<br>2.리터럴<br>값을 생성하는 가장 간단한 방법,사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식(notaion)을 말함.자바 스크립트 엔진은 런타임에 리터럴을 평가하여 값을 생성한다.<br>3.표현식<br>표현식은 값으로 평가될 수 있는 문이다.즉,표현식이 평가되면 값을 생성하거나 값을 참조한다.<br>리터럴도 값으로 평가 따라서 리터럴도 표현식.<br>값으로 표현될 수 있으면 무조건 표현식 ex) x = 1;<br>모든 식별자 = 표현식.<br>sum = 10 표현식인 문.<br>sum !== 10 true false로 평가하는식. 같지 않으면 true로 평가됨.<br>표현식인지 아닌지 구별하려면 변수를 할당해보면된다.</p>
<p>4.문<br>-문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.<br>-토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다.<br>var(토큰) sum(토큰) =(토큰) 1(토큰) +(토큰) 2(토큰);(토큰)<br>위 모든걸 통틀어서 문.</p>
<p>5.세미콜론과 세미콜론 자동 삽입 가능<br>세미콜론은 문의 종료를 나타낸다.따라서 문은 세미콜론으로 끝나야 하지만 세미콜론 자동 삽입 기능이 암묵적으로 수행해줘서 굳이 붙이지 않아도된다.하지만 세미콜론 사용을 권장하는 분위기이므로 붙이도록 하자.<br>if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다.이런 코드 블록은 자체 종결성을 갖기 때문이다.</p>
<p>6.표현식인 문과 표현식이 아닌 문<br>표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.<br>// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.<br>var x;<br>// 1, 2, 1 + 2, x = 1 + 2는 표현식이다.<br>// x = 1 + 2은 표현식이면서 완전한 문이기도 하다.<br>x = 1 + 2;<br>문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를 들어 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다.<br>가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.아닌 문은 변수에 할당하면 에러가 난다.<br>// 변수 선언문은 표현식이 아닌 문이다.<br>var x;</p>
<p>// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.<br>x = 100;</p>
<p>// 표현식인 문은 값처럼 사용할 수 있다<br>var foo = x = 100;<br>console.log(foo); // 100</p>
<p>6.데이터 타입<br>데이터 타입은 값의 종류를 말한다.자바스크립트의 모든 값은 데이터 타입을 갖는다.<br>7개의 데이터 타입을 제공. 원시 타입과 객체 타입으로 분류.<br>-원시 타입(primitive type)<br>숫자 타입:정수와 실수 구분없이 하나의 숫자 타입만 존재.<br>문자열 타입:문자열<br>불리언 타입: 논리적 참과 거짓<br>undefiend 타입:var 키워드로 선언된 변수에 암묵적으로 할당되는 ㄱ밧<br>null 타입:값이 없다는 것을 의도적으로 명시할 때 사용하는 ㄱ밧<br>Symbol 타입: ES6에서 새롭게 추가된 7번째 타입.<br>-객체 타입: 객체,함수,배열 등</p>
<p>1.숫자 타입<br>C나 Java의 경우, 정수(소숫점 이하가 없는 숫자)와 실수(소숫점 이하가 있는 숫자)를 구분하여 int,long,float,double 등과 같은 다양한 숫자 타입이 존재한다. 이유는 메모리 소비를 아끼려고.<br>자바스크립트는 하나의 숫자 타입만 쓴다.<br>ECMAScript 사양에 따르면 모든 수를 실수로 처리하며 정수만을 표현하기 위한 특별한 데이터타입은 없다.<br>var integer = 10;    // 정수<br>var double = 10.12;  // 실수<br>var negative = -20;  // 음의 정수</p>
<p>숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다.<br>infinity: 양의 무한대<br>-infinity:음의 무한대<br>NaN: 산술 연산 불가 </p>
<p>// 숫자 타입의 3가지 특별한 값<br>console.log(10 / 0);       // Infinity<br>console.log(10 / -0);      // -Infinity<br>console.log(1 * ‘String’); // NaN</p>
<p>자바스크립트는 대소문자를 구별한다.</p>
<p>2.문자열 타입<br>문자열(string) 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 전세계 대부분의 문자를 표현할 수 있다.<br>자바스크립트에서 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다.(ex:’문자열’)<br>문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함.만약 문자열을 따옴표로 감싸지 않으면 엔진은 키워드나 식별자와 같은 토큰으로 인식.<br>자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미.<br>// 문자열 타입<br>var string;<br>string = ‘문자열’; // 작은 따옴표<br>string = “문자열”; // 큰 따옴표<br>string = <code>문자열</code>; // 백틱 (ES6)</p>
<p>string = ‘작은 따옴표로 감싼 문자열 내의 “큰 따옴표”는 문자열로 인식된다.’;<br>string = “큰 따옴표로 감싼 문자열 내의 ‘작은 따옴표’는 문자열로 인식된다.”;</p>
<p>다른 타입의 값과는 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자와 같은 토큰으로 인식한다.<br>다른 타입의 값과는 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함 만약 안하면 키워드나 식별자같은 토큰으로 인식.<br>// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.<br>var string = hello; // ReferenceError: hello is not defined</p>
<p>3.템플릿 리터럴<br>플릿 리터럴은 멀티라인 문자열(Multi-line string), 표현식 삽입(Expression interpolation), 태그드 템플릿(Tagged template) 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.일반적인 따옴표 대신 백틱(backtick) <code>를 사용한다.
var template =</code>Template literal`;<br>console.log(template); // Template literal</p>
<p>3-1.멀티라인 문자열<br>일반 문자열 내에서 줄바꿈은 허용되지 않는다.<br>우리는 LF를 써야한다. 개행은 바로 밑줄로 가고 캐리지리턴으로 밑줄의 첫행으로 옮김.<br>\n    개행(LF, Line Feed): 다음 행으로 이동<br>\r    개행(CR, Carriage Return): 커서를 처음으로 이동</p>
<p>3-2.표현식 삽입<br>문자열은 문자열 연산자 +를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작<br>템플릿 리터럴 내에서는 표현식 삽입(Expression interpolation)을 통해 간단히 문자열을 삽입할 수 있다.<br>var first = ‘Ung-mo’;<br>var last = ‘Lee’;</p>
<p>+는 산술연산자,문자열 연결 연산자 이어주는 2가지 역할. 문자열 + 문자열 or  강제로 뒤에를 문자열 타입으로 변환함.<br>Ex)’My name is’ + 12345  </p>
<p>// ES6: 표현식 삽입<br>문자열은 문자열 연산자 +를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다.<br>var first = ‘Ung-mo’;<br>var last = ‘Lee’;</p>
<p>// ES5: 문자열 연결<br>console.log(‘My name is ‘ + first + ‘ ‘ + last + ‘.’);<br>// My name is Ung-mo Lee.<br>표현식 삽입은 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 타입 변환되어 삽입된다.<br>console.log(<code>1 + 2 = ${1 + 2}</code>); // 1 + 2 = 3<br>문자열 인터폴레이션은 반드시 템플릿 리터럴 내에서 사용해야 한다. 템플릿 리터럴 이외의 일반 문자열에서 표현식 삽입은 문자열 취급을 받는다.<br>console.log(‘1 + 2 = ${1 + 2}’); // 1 + 2 = ${1 + 2}</p>
<p>4.불리언 타입<br>참,거짓을 나타내는 true와 false.</p>
<p>5.undefined 타입<br>undefined 타입의 값은 undefined가 유일.선언은 되었지만 아직 값을 할당하지 않은 변수에 접근하면 undefined가 반환.<br>var foo;<br>console.log(foo); // undefined<br>변수에 값이 없다는 것을 명시하고 싶은 경우는 undefined대신 null을 할당하자.</p>
<p>var 키워드로 선언한 변수만(const등으로 말고) undefined로 초기화된다.undefined 일부러 생성하지말자.<br>let,const … let 변수.</p>
<p>6.null 타입<br>null 타입의 값은 null이 유일.<br>변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미.엔진은 누구도 참조하지않은 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.<br>null타입까지 원시값을 만들때 리터럴로 만듬.대신에 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는게 베스트이다.</p>
<p>7.symbol 타입<br>심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값.<br>주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용.<br>symbol 타입부터 함수로 만듬.참조를 못함.<br>// 심볼 값 생성<br>var key = Symbol(‘key’);<br>console.log(typeof key); // symbol</p>
<p>// 객체 생성<br>var obj = {};</p>
<p>// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.<br>obj[key] = ‘value’;<br>console.log(obj[key]); // value</p>
<p>8.객체 타입<br>자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 크게 분류.<br>객체 사이즈는 굉장히 클수도있다. 단점:메모리 용량을 소비한다.  장점:값의 추적이 용이하다.   객체는 하나를 바꿀때 다른값도 영향받을수있다.<br>그래도 용량 때문에 객체는 원시값을 공유한다.<br>자바스크립트는 원식값에다 .을 할시 객체로 인식한다. ex) ‘string’(원시값).length   6<br>9.데이터 타입의 필요성<br>9-1.데이터 타입에 의한 메모리 공간의 확보와 참조<br>모든 값은 메모리에 저장하고 참조할 수 있어야하는데, 먼저 확보해야할 메모리의 크기를 알아야한다. 그래서 타입마다 메모리 크기를 정해서 확보하게한다.<br>자바스크립트의 변수는 엄밀히 따지면 타입이 없다.값은 타입이 있다.<br>ex) var a; 는 할당을 안했으니 타입을 알 수가 없다.undefined로 평가 될 수 있다. 할당된 값에 의해서 동적 언어가 되는데 a = 1; 이런식으로 타입을 부여하면 동적 타입이 된다.</p>
<p>9-2.데이터 타입에 의한 값의 해석.<br>데이터 타입이 필요한 이유.<br>-값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해<br>-값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해<br>-메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해</p>
<p>10.동적 타이핑</p>
<p>10.1 동적 타입 언어와 정적 타입 언어<br>자바스크립트는  정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다.다만 var, let, const 키워드를 사용해 변수를 선언할 뿐.<br>자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정.그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑(Dynamic typing)이라 하며 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입(Dynamic/Weak type) 언어.</p>
<p>var foo;<br>console.log(typeof foo);  // undefined</p>
<p>foo = 3;<br>console.log(typeof foo);  // number</p>
<p>foo = ‘Hello’;<br>console.log(typeof foo);  // string</p>
<p>foo = true;<br>console.log(typeof foo);  // boolean</p>
<p>foo = null;<br>console.log(typeof foo);  // object</p>
<p>foo = Symbol(); // 심볼<br>console.log(typeof foo);  // symbol</p>
<p>foo = {}; // 객체<br>console.log(typeof foo);  // object</p>
<p>foo = []; // 배열<br>console.log(typeof foo);  // object</p>
<p>foo = function () {}; // 함수<br>console.log(typeof foo);  // function</p>
<p>위 예제들은 변수에 할당된 값의 데이터 타입을 반환한 것이다.자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.이러한 특징을 동적 타이핑이라한다.<br>본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정.<br>정적 타입 언어는 컴파일러 언어다.</p>
<p>10.2 동적 타입 언어와 변수<br>동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.<br>동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.<br>변수를 사용할때 주의사항<br>-변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수값은 재할당에 의해 언제든지 변경될 수 있다. 이로 인해 동적 타입 언어인 자바스크립트는 타입을 잘못 예측해 오류가 발생할 가능성이 높다. 따라서 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 변수의 무분별한 남발은 금물이며 필요 최소한으로 유지하도록 주의해야 한다.</p>
<p>-변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 변수의 유효 범위가 넓으면 넓을수록 변수로 인해 오류가 발생할 확률은 높아진다.</p>
<p>-전역 변수는 최대한 사용하지 않도록 한다. 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고 다른 코드에 영향을 줄 가능성도 높다. 따라서 전역 변수는 프로그램의 복잡성을 증가시키고 처리의 흐름을 추적하기 어렵게 만들고, 오류가 발생했을 경우, 오류의 원인을 특정하기 어렵게 만든다. 전역 변수의 문제점과 전역 변수의 사용을 억제하는 방법에 대해서는 “14. 전역 변수의 문제점”에서 자세히 살펴보도록 하자.</p>
<p>-변수보다는 상수를 사용해 값의 변경을 억제한다.</p>
<p>-변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 변수 이름 뿐만이 아니라 모든 식별자(변수, 함수, 클래스 이름 등)는 존재 이유를 파약할 수 있는 적절한 이름을 네이밍해야 한다. 특히 식별자의 유효 범위가 넓을수록 보다 명확한 이름을 명명하도록 노력하도록 하자. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며 이는 협업과 생산성 향상에 도움을 준다. 변수 이름은 첫아이 이름을 짓듯이 심사숙고해서 지어야 한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/19/js0219/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/19/js0219/" class="post-title-link" itemprop="url">자바스크립트 20일 예습 및 복습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-19 16:35:30" itemprop="dateCreated datePublished" datetime="2020-02-19T16:35:30+09:00">2020-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-23 22:17:52" itemprop="dateModified" datetime="2020-02-23T22:17:52+09:00">2020-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>20일 예습.<br>-변수<br>1.변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.<br>2.변수에 값을 저장하는 것을 할당(assignment)이라 하고,변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다.<br>-식별자(identifier)<br>1.변수 이름을 식별자라고도 부른다.<br>2.식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름.<br>3.식별자는 값이 아니라 메모리 주소를 기억하고 있다.<br>4.식별자라는 용어는 변수 이름에만 국한하지않고, 함수,클래스등의 이름은 모두 식별자다.<br>-변수 선언<br>1.변수를 생성하는 것을 말한다.<br>2.var의 단점. 블록 레벨 스코프를 지원하지않고 함수 레벨 스코프를 지원한다는 것이다.<br>블록 레벨 스코프:함수 밖에서 선언하면 함수 스코프 변수처럼 전역 접근할 수 있고,블록 안에서 선언하면 자신을 정의한 블록과 하위 블록에서만 접근 가능.<br>함수 레벨 스코프:함수 밖에서 선언한 함수 스코프 변수는 전역 범위를 가지고,함수 안에서 사용하면 함수 밖을 제외한 내부 어디서든 접근이 가능.<br>3.변수 선언 이후,변수에 값을 할당하지 않았다.undefiend라는 값이 암묵적으로 할당되어 초기화되어있다.<br>4.변수 선언 2단계.<br>선언 단계: 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.<br>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefind 할당.<br>5.초기화 단계 거치지 않으면 확보된 메모리 공간에 이전의 애플리케이션 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값(Garbage value)라 한다.<br>6.변수 뿐만 아니라 모든 식별자(함수, 클래스 등)반드시 선언 필요. 만약 선언하지않은 식별자에 접근하면 ReferenceErro(참조 에러) 발생.<br>-변수 선언의 실행 시점과 변수 호이스팅<br>1.자바스크립트 엔진은 변수 선언이 소스 코드의 어디에 있던지 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스 코드에 어디에 있던지 상관없이 변수를 참조할 수 있다.<br>2.이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라한다.<br>-값의 할당<br>1.변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.<br>2.</p>
<p>-값의 재할당<br>1.이미 값이 할당되어있는 변수에 새로운 값을 또다시 할당하는것.<br>2.만약 재할당을 할 수 없어서 변수에 저장된 값을 저장할 수 없다면 변수가 아니라 상수라 부른다.<br>-식별자 네이밍 규칙.<br>1.식별자는 특수문자를 제외한 문자,숫자,underscore(<em>),달러 기호($)포함할 수 있다.<br>2.식별자는 특수문자를 제외한 문자,underscore(_</em>), 달러 기호($)로 시작해야 한다.숫자 시작x<br>3.예약어는 식별자로 사용 x<br>4.변수나 함수 이름엔 카멜 케이스,생성자 함수 클래스의 이름에는 파스칼 케이스를 사용.</p>
<p>복습.</p>
<p>왜 원시값은 불변하고,객체는 가능한가?<br>원시값(Primitive Value)<br>원시값에는 6가지 유형이 있다.</p>
<p>1.boolean<br>2.number<br>3.string<br>4.null<br>5.undefined<br>6Symbol(ES2015에서 새로 생김)</p>
<p>그리고 이 원시값에는 다음과 같은 특징이 있다.</p>
<p>1.불변(Immutable)하는 값이다.<br>2.값으로써 비교가 가능하다. (심볼을 제외하고)<br>3.typeof 연산자를 쓰면 각자 고유한 타입을 내뱉는다. (typeof null을 제외하고)</p>
<p>추측이지만 원시값이 변하는 성질이면 다른 래퍼런스가 같은 메모리 주소를 가리키고 있다가 내용을 바뀌게 된다면 영향을 받기 때문에 예측불가 상황이 발생한다.때문에 불변인것같다.</p>
<p>메모리셀 1 = 1byte = 8bit</p>
<p>var a = 1 부분에서 호이스팅시 var a(선언문 먼저) = 1 부분은 런타임때 실행.<br>객체 = 변경 가능한 값.(할당없이).  ,하나의 값인데 여러개의 값을 가지고있음.<br>원시값 = 변경 불가능한 값.<br>객체를 원시값처럼 못바꾸게 얼린다=freeze<br>프로그래밍 상수는 재할당이 금지된 변수이다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/11/My-first-blog-post-with-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/My-first-blog-post-with-hexo/" class="post-title-link" itemprop="url">My first blog post with hexo</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-11 00:28:37 / Modified: 00:31:27" itemprop="dateCreated datePublished" datetime="2020-02-11T00:28:37+09:00">2020-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#나의 첫번째 hexo 포스트<br>마크다운 문법으로 포스트를 작성하시고 hexo generte로 변환합니다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-11 00:25:57" itemprop="dateCreated datePublished" datetime="2020-02-11T00:25:57+09:00">2020-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

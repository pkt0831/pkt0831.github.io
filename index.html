<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="My Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="pkt0831&#39;s Blog">
<meta property="og:url" content="https://pkt0831.github.io/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="My Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/15/js0315-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/js0315-1/" class="post-title-link" itemprop="url">빌트인 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 11:35:30 / Modified: 23:30:44" itemprop="dateCreated datePublished" datetime="2020-03-15T11:35:30+09:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.자바스크립트 객체는 3가지로 분류된다.<br>-표준 빌트인 객체<br>표준 빌트인 객체(standard built-in objects / native objects / global objects)  ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다.<br>표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 별도 선언없이 전역 변수처럼 참조 가능하다.<br>-호스트 객체<br> ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경 에서 추가적으로 제공하는 객체를 말한다.<br>-사용자 정의 객체<br>기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체.<br>2. 표준 빌트인 객체<br>Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array 등 40여개의 표준 빌트인 객체를 제공한다.Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.<br>생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다.<br>표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출하여 인스턴스를 생성할 수 있다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 생성자 함수에 의한 String 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Lee'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj);        <span class="comment">// String &#123;"Lee"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 생성자 함수에 의한 Number 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj);        <span class="comment">// Number &#123;123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean 생성자 함수에 의한 Boolean 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> boolObj= <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj);        <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 생성자 함수에 의한 Function 객체(함수) 생성</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> func); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.dir(func);        <span class="comment">// ƒ anonymous(x )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에 의한 Array 객체(배열) 생성</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);        <span class="comment">// (3) [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성</span></span><br><span class="line"><span class="keyword">const</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/i</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> regExp); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(regExp);        <span class="comment">// /ab+c/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date 생성자 함수에 의한 Date 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(date);        <span class="comment">// Tue Mar 19 2019 02:38:26 GMT+0900 (한국 표준시)</span></span><br></pre></td></tr></table></figure>
<p>3.원시값과 래퍼 객체<br>원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다.</p>
<p>이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체(wrapper object)라 한다.<br><img src="https://user-images.githubusercontent.com/56964928/76703405-dcd25480-6714-11ea-8443-6bcebf4e4e9b.png" alt="객체1"></p>
<ol start="4">
<li>전역 객체<br>전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.<br>브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다.<br>전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array…)들과 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API) 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.<br>전역 객체는 계층적 구조 상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체와 호스트 객체)의 최상위 객체이다.<br>최상위 객체라는 의미가 아니고 객체의 계층적 구조 상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다.</li>
</ol>
<p>-전역 객체의 특징.<br>-전역 객체는 개발자가 의도적으로 생성할 수 없다.<br>-전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.<br>-전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.<br>-자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖는다. 브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.<br>-var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.<br>-let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.<br>-브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리하여도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미이다.<br>4.1 빌트인 전역 프로퍼티<br>빌트인 전역 프로퍼티(Built-in global property)는 전역 객체의 프로퍼티를 의미한다.<br>4.1.1. Infinity<br>Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.<br>4.1.2. NaN<br>NaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다.<br>4.1.3. undefined<br>undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.<br>4.2. 빌트인 전역 함수<br>빌트인 전역 함수(Built-in global function)는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다.<br>4.2.1. eval<br>문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 주어진 코드를 런타임 평가하고 실행하여 결과값을 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">code</span></span> - 코드를 나타내는 문자열</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span> </span>문자열 코드를 평가/실행한 결과값</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">eval</span>(code)</span><br></pre></td></tr></table></figure>
<p>4.2.2. isFinite<br>매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 주어진 숫자가 유한수인지 확인하고 그 결과를 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>유한수 여부 확인 결과값</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">isFinite</span>(testValue)</span><br></pre></td></tr></table></figure>
<p>4.2.3. isNaN<br>매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 주어진 숫자가 NaN인지 확인하고 그 결과를 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span> </span>NaN 여부 확인 결과값</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">isNaN</span>(testValue)</span><br></pre></td></tr></table></figure>
<p>4.2.4. parseFloat</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 주어진 문자열을 부동소수점 숫자로 변환하여 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">string</span></span> - 변환 대상 값</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span> </span>변환 결과값</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseFloat</span>(string)</span><br></pre></td></tr></table></figure>
<p>4.2.5. parseInt<br>매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 주어진 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다.</span></span><br><span class="line"><span class="comment"> * 반환값은 언제나 10진수이다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">string</span></span> - 변환 대상 값</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[radix] - 진법을 나타내는 기수(2 ~ 36, 기본값 10)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span> </span>변환 결과값</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseInt</span>(string, radix);</span><br></pre></td></tr></table></figure>
<p>4.2.6. encodeURI / decodeURI<br>encodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다. URI의 하위개념으로 URL, URN이 있다.<br><img src="https://user-images.githubusercontent.com/56964928/76703406-de9c1800-6714-11ea-863d-036c6e40346d.png" alt="객체2"><br>4.2.7. encodeURIComponent / decodeURIComponent<br>encodeURIComponent 함수는 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 단, 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) 문자는 이스케이프 처리에서 제외된다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.</p>
<p>4.3. 암묵적 전역<br>전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작하는 현상을 암묵적 전역(implicit global)이라 한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/15/js0315-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/js0315-2/" class="post-title-link" itemprop="url">this</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 11:35:30" itemprop="dateCreated datePublished" datetime="2020-03-15T11:35:30+09:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 00:49:52" itemprop="dateModified" datetime="2020-03-16T00:49:52+09:00">2020-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>this 키워드<br>객체는 상태를 나타내느 프로퍼티와 동작을 나타내는 메소드를 하나의 논리적인 단위로 묶은것인데, this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다.<br>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 코드 어디에서든지 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.<br>strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.</li>
<li>함수 호출 방식과 this 바인딩<br>this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.<br>렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.<br>함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. this에 바인딩될 객체는 함수 호출 시점에 결정된다.</li>
</ol>
<p>함수를 호출하는 4가지 방식.<br>1.일반 함수 호출<br>2.메소드 호출<br>3.생성자 함수 호출<br>4.Function.prototype.apply/call/bind 메소드에 의한 간접 호출</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this에 바인딩될 객체는 함수 호출 방식에 따라 동적으로 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 동일한 함수도 다양한 방식으로 호출할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 일반 함수 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 일반적인 방식으로 호출</span></span><br><span class="line"><span class="comment">// this는 전역 객체 window를 가리킨다.</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 메소드 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 프로퍼티의 값으로 할당하여 호출</span></span><br><span class="line"><span class="comment">// this는 메소드를 호출한 객체 obj를 가리킨다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 생성자 함수 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 new 연산자와 함께 생성자 함수로 호출</span></span><br><span class="line"><span class="comment">// this는 생성자 함수가 생성한 인스턴스를 가리킨다.</span></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">// foo &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출</span></span><br><span class="line"><span class="comment">// this는 인수에 의해 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"></span><br><span class="line">foo.call(bar);   <span class="comment">// bar</span></span><br><span class="line">foo.apply(bar);  <span class="comment">// bar</span></span><br><span class="line">foo.bind(bar)(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>2.1. 일반 함수 호출<br>기본적으로 this에는 전역 객체(Global object)가 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// window</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 <span class="keyword">this</span>에는 전역 객체가 바인딩된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">객체를 생성하지 않는 일반 함수에서 <span class="keyword">this</span>는 의미가 없기 때문에 strict mode가 적용된 일반 함수 내부의 <span class="keyword">this</span>에는 <span class="literal">undefined</span>가 바인딩된다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// undefined</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 변수 value는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const 키워드로 선언한 변수 value는 전역 객체의 프로퍼티가 아니다.</span></span><br><span class="line"><span class="comment">// const value = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 내에서 정의한 중첩 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"bar's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면</span></span><br><span class="line">    <span class="comment">// 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">콜백 함수 내부의 <span class="keyword">this</span>에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 <span class="keyword">this</span>에 전역 객체가 바인딩된다.</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="comment">// 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"callback's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"callback's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>
<p>일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.</p>
<p>2.2. 메소드 호출<br>메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체에 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// 메소드의 this는 메소드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 getName을 호출한 객체는 person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName());</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">메소드 내부의 <span class="keyword">this</span>는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다.</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// 메소드의 this는 메소드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 getName을 호출한 객체는 person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>
<p>2.3. 생성자 함수 호출<br>생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>2.4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출<br>Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply와 call 메소드는 Function.prototype의 메소드이다. 즉, apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다.<br><img src="https://user-images.githubusercontent.com/56964928/76704933-aea64200-671f-11ea-9467-23b1ee729597.png" alt="메소드1"></p>
<p>apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/76704985-fb8a1880-671f-11ea-8e07-94b02edd1c18.png" alt="캡처_2020_03_16_00_49_02_135"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/14/js0314/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/js0314/" class="post-title-link" itemprop="url">엄격 모드.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-14 11:35:30" itemprop="dateCreated datePublished" datetime="2020-03-14T11:35:30+09:00">2020-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-15 23:31:28" itemprop="dateModified" datetime="2020-03-15T23:31:28+09:00">2020-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>strict mode란?<br>strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던<br>오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.<br><img src="https://user-images.githubusercontent.com/56964928/76703433-0a1f0280-6715-11ea-8125-fb721e07008a.png" alt="모드1"></p>
<ol start="2">
<li>strict mode의 적용<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> 'use strict'</span>; <span class="comment">//함수 몸체 선두에 'use strict';를 추가하면 스크립트 전체에 strict mode가 적용된다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 strict mode가 적용된다.</span></span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//코드의 선두에 strict mode를 위치시키지 않으면 제대로 동작하지 않는다.</span></span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// 에러를 발생시키지 않는다.</span></span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>전역에 strict mode를 적용하는 것은 피하자.<br>전역에 적용한 strict mode는 스크립트 단위로 적용되어 다른 스크립트엔 영향을 주지않고 자신의 스크립트에 한정되어 적용되기때문에 다른 스크립트는 래퍼런스 에러가난다.<br>대신, 즉시 실행 함수로 스크립트 전체를 감사써 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수의 선두에 strict mode 적용</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
<li><p>함수 단위로 strict mode를 적용하는 것도 피하자.<br>모든 함수에 일일이 strict mode를 적용하는 것은 번거로운 일이기에 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// non-strict mode</span></span><br><span class="line">  <span class="keyword">var</span> lеt = <span class="number">10</span>; <span class="comment">// 에러가 발생하지 않는다.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> = <span class="number">20</span>; <span class="comment">// SyntaxError: Unexpected strict mode reserved word</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
<li><p>strict mode가 발생시키는 에러</p>
</li>
<li><ol>
<li>암묵적 전역<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">선언하지 않은 변수를 참조하면 <span class="built_in">ReferenceError</span>가 발생한다.</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>변수, 함수, 매개변수의 삭제<br>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</li>
</ol>
</li>
<li><ol start="3">
<li>매개변수 이름의 중복<br>중복된 함수 매개변수 이름을 사용하면 SyntaxError가 발생한다.</li>
</ol>
</li>
<li><ol start="4">
<li>with 문의 사용<br>with 문을 사용하면 SyntaxError가 발생한다.</li>
</ol>
</li>
<li><p>strict mode 적용에 의한 변화</p>
</li>
<li><ol>
<li>일반 함수의 this<br>strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다. 이때 에러는 발생하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Foo</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>arguments 객체<br>strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// 매개변수에 전달된 인수를 재할당하여 변경</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 변경된 인수가 arguments 객체에 반영되지 않는다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// &#123; 0: 1, length: 1 &#125;</span></span><br><span class="line">&#125;(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/08/js0308-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/js0308-5/" class="post-title-link" itemprop="url">프로토 타입</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 11:35:30" itemprop="dateCreated datePublished" datetime="2020-03-08T11:35:30+09:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-13 16:54:06" itemprop="dateModified" datetime="2020-03-13T16:54:06+09:00">2020-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>앞부분이 중요.<br>함수는 런타임 이전에 생성되고, 그와 동시에 프로토타입이 생성된다.</p>
<ol>
<li>객체지향 프로그래밍<br>객체란 원시 타입의 값을 제외한 자바스크립트를 이루고 있는 거의 모든 것들이다. 또한 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조 또한 객체라고 한다.<br>객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(Imperative programming)의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.</li>
</ol>
<p>객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조라고 할 수 있다. 객체의 상태 데이터를 프로퍼티(property), 동작을 메소드(method)라 부른다.</p>
<ol start="2">
<li>상속과 프로토타입</li>
</ol>
<p>상속(Inheritance)은 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Math.PI는 원주율을 나타내는 상수이다.</span></span><br><span class="line">    <span class="comment">// Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="comment">// 반지름이 1인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 반지름이 2인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는</span></span><br><span class="line"><span class="comment">// getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span></span><br><span class="line"><span class="comment">// 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>
<p>프로토타입을 기반으로 상속을 구현한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.</span></span><br><span class="line"><span class="comment">// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.</span></span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span></span><br><span class="line"><span class="comment">// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.</span></span><br><span class="line"><span class="comment">// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>
<p>-1-</p>
<ol start="3">
<li>프로토타입 객체</li>
</ol>
<p>프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드 포함)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.<br>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 즉, 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정되고 [[prototype]]에 저장된다.<br>모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 null이거나 객체이다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</p>
<p>3.1. <strong>proto</strong> 접근자 프로퍼티<br>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다.</p>
<p>3.2. 함수 객체의 prototype 프로퍼티</p>
<p>함수 객체는 <strong>proto</strong> 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
<p>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).hasOwnProperty(<span class="string">'prototype'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.hasOwnProperty(<span class="string">'prototype'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype로부터 상속받은) <strong>proto</strong> 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.<br><img src="https://user-images.githubusercontent.com/56964928/76538933-67237a00-64c3-11ea-861b-ef9e68aae4aa.png" alt="캡처_2020_03_13_00_39_40_693"></p>
<p>3.3. 프로토타입의 constructor 프로퍼티와 생성자 함수</p>
<p>모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// me 객체의 생성자 함수는 Person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/56964928/76539378-0ba5bc00-64c4-11ea-80f0-a561b45dcb4f.png" alt="프로퍼티2">r</p>
<ol start="4">
<li>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</li>
</ol>
<p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 객체를 생성한 생성자 함수는 Object이다.</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add 함수 객체를 생성한 생성자 함수는 Function이다.</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// me 객체를 생성한 생성자 함수는 Person이다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 리터럴</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 리터럴</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정규표현식 리터럴</span></span><br><span class="line"><span class="keyword">const</span> regexr = <span class="regexp">/is/ig</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>프로토타입의 생성 시점</li>
</ol>
<p>객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다.<br>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>
<p>5.1. 사용자 정의 생성자 함수와 프로토타입 생성 시점<br>화살표 함수나 ES6의 메소드 축약 표현으로 정의하지 않고 일반 함수(함수 선언문, 함수 표현식)로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 화살표 함수는 non-constructor이다.</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-constructor는 프로토타입이 생성되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>5.2. 빌트인 생성자 함수와 프로토타입 생성 시점<br>Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.</p>
<p>전역 객체는 누구보다도 먼저 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.</p>
<ol start="6">
<li>객체 생성 방식과 프로토타입의 결정</li>
</ol>
<p>객체는 아래와 같이 다양한 생성 방법이 있다.</p>
<p>-객체 리터럴<br>-Object 생성자 함수<br>-생성자 함수<br>-Object.create 메소드<br>-클래스 (ES6)</p>
<p>위 5가지는 추상연산에 생성된다는 공통점이 있다.</p>
<p>프로토타입은 추상 연산 ObjectCreate에 전달되는 인수(proto)에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<p>6.1. 객체 리터럴에 의해 생성된 객체의 프로토타입<br>객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다.<br>이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>
<p> 객체 리터럴이 평가되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다.</p>
<p> 이처럼 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. obj 객체는 constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유하지 않지만 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 이는 obj 객체가 자신의 프로토타입인 Object.prototype 객체를 상속받았기 때문이다.</p>
<p> 6.2. Object 생성자 함수에 의해 생성된 객체의 프로토타입<br> 명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</p>
<p> 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는 것을 알 수 있다.</p>
<p>6.3. 생성자 함수에 의해 생성된 객체의 프로토타입</p>
<p>ew 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</p>
<p>이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br></pre></td></tr></table></figure>
<p>위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 생성된 객체 사이에 연결이 만들어 진다.</p>
<ol start="7">
<li>프로토타입 체인</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메소드</span></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty는 Object.prototype의 메소드이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Person 생성자 함수에 의해 생성된 me 객체는 Object.prototype의 메소드인 hasOwnProperty를 호출할 수 있다. 이것은 me 객체가 Person.prototype 뿐만 아니라 Object.prototype도 상속받았다는 의미이다.</p>
<p>me 객체의 프로토타입은 Person.prototype이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(me) === Person.prototype); <span class="comment">// true</span></span><br><span class="line">Person.prototype의 프로토타입은 <span class="built_in">Object</span>.prototype이다. 프로토타입의 프로토타입은 언제나 <span class="built_in">Object</span>.prototype이다.</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(Person.prototype) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. </p>
<ol start="8">
<li>캡슐화<br>캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것을 말한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메소드</span></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 반환</span></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br></pre></td></tr></table></figure></li>
<li>오버라이딩과 프로퍼티 쉐도잉<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메소드</span></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 반환</span></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 메소드</span></span><br><span class="line">me.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hey! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 메소드가 호출된다. 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다.</span></span><br><span class="line">me.sayHello(); <span class="comment">// Hey! My name is Lee</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 메소드 변경</span></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hey! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">me.sayHello(); <span class="comment">// Hey! My name is Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메소드 삭제</span></span><br><span class="line"><span class="keyword">delete</span> Person.prototype.sayHello;</span><br><span class="line">me.sayHello(); <span class="comment">// TypeError: me.sayHello is not a function</span></span><br></pre></td></tr></table></figure>
<ol start="10">
<li>프로토타입의 교체</li>
</ol>
<p>프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다.</p>
<p>10.1. 생성자 함수에 의한 프로토타입의 교체</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span></span><br><span class="line">  Person.prototype = &#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br></pre></td></tr></table></figure>
<p>①에서 Person.prototype에 객체 리터럴을 할당하였다. 이는 Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것이다. </p>
<p>프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. 따라서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>10.2. 인스턴스에 의한 프로토타입의 교체<br>인스턴스의 <strong>proto</strong> 접근자 프로퍼티(또는 Object.setPrototypeOf 메소드)를 통해 프로토타입을 교체할 수 있다.</p>
<ol start="11">
<li>instanceof 연산자</li>
</ol>
<p>instanceof 연산자는 이항 연산자로서 좌변에 객체를 가기키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.<br>좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다. instanceof 연산자는 상속 관계를 고려한다.<br>12. 직접 상속<br>12.1 Object.create에 의한 직접 상속<br>Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.<br>12.2 객체 리터럴 내부에서 <strong>proto</strong>에 의한 직접 상속<br>객체 리터럴 내부에서 <strong>proto</strong> 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>
<ol start="13">
<li><p>정적 프로퍼티/메소드<br>정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. </p>
</li>
<li><p>프로퍼티 존재 확인</p>
</li>
</ol>
<ol start="15">
<li>프로퍼티 열거</li>
<li>1 for…in 문<br>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다.</li>
</ol>
<p>15.2. Object.keys/values/entries 메소드<br>객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/08/js0308-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/js0308-4/" class="post-title-link" itemprop="url">함수와 일급 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 11:24:30" itemprop="dateCreated datePublished" datetime="2020-03-08T11:24:30+09:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-11 19:25:02" itemprop="dateModified" datetime="2020-03-11T19:25:02+09:00">2020-03-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>일급 객체<br>아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다.</li>
</ol>
<p>1.무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.<br>2.변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.<br>3.함수의 매개 변수에게 전달할 수 있다.<br>4.함수의 결과값으로 반환할 수 있다.<br>자바스크립트의 함수는 아래 예제와 같이 위의 조건을 모두 만족하므로 일급 객체이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">읽어보기만 이해안도됨.</span><br><span class="line"><span class="comment">// 1. 함수는 무명의 리터럴로 생성할 수 있다.</span></span><br><span class="line"><span class="comment">// 2. 함수는 변수에 저장할 수 있다.</span></span><br><span class="line"><span class="comment">// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span></span><br><span class="line"><span class="keyword">const</span> increase = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrease = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 함수는 객체에 저장할 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> predicates = &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 함수의 매개 변수에게 전달할 수 있다.</span></span><br><span class="line"><span class="comment">// 4. 함수의 반환값으로 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = predicate(num);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> increaser = makeCounter(predicates.increase);</span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> decreaser = makeCounter(predicates.decrease);</span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<p>함수 일급 객체 = 객체와 동일.객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임(runtime)에 함수 객체로 평가된다.</p>
<ol start="2">
<li>함수 객체의 프로퍼티<br>일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다.<br>arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티이다.</li>
</ol>
<p>2.1 arguments 프로퍼티<br>함수 객체의 arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다.</p>
<p>자바스크립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x * y;                  <span class="comment">//x,y는 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply());        <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>));       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</p>
<p>arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    res += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum());        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>2.2. caller 프로퍼티</p>
<p>caller 프로퍼티는 ECMAScript 스펙에 포함되지 않은 비표준 프로퍼티이다. 알아두기만 하자.<br>함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.</p>
<p>2.3. length 프로퍼티<br>함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar.length); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(baz.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>2.4. name 프로퍼티<br>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.<br>name 프로퍼티는 ES5와 ES6에서 동작을 달리 하므로 주의하기 바란다. 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. 하지만 ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</p>
<p>2.5. <strong>proto</strong> 접근자 프로퍼티<br>모든 객체는 <a href="내부슬롯이름">[Prototype]</a>이라는 내부 슬롯을 갖는다.(내부슬롯은 자신의 부모역할을 하는 객체를 가리킨다.그것을 프로토타입 객체라고 부른다.) [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.<br><strong>proto</strong> (자신의 부모 프로퍼티 객체를 가리킨다.)프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 <strong>proto</strong> 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.</span></span><br><span class="line"><span class="comment">// hasOwnProperty 메소드는 Object.prototype의 메소드이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'a'</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'__proto__'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>2.6. prototype 프로퍼티<br>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).hasOwnProperty(<span class="string">'prototype'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).hasOwnProperty(<span class="string">'prototype'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/08/js0308-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/js0308-3/" class="post-title-link" itemprop="url">생성자 함수에 의한 객체 생성</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 11:22:30" itemprop="dateCreated datePublished" datetime="2020-03-08T11:22:30+09:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-11 14:44:58" itemprop="dateModified" datetime="2020-03-11T14:44:58+09:00">2020-03-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>Object 생성자 함수<br>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.<br>객체 리터럴로 만드는건 고유한 하나의 객체로 만들때,생성자 함수로 객체를 만드는건 하나의 프로퍼티를 여러개의 객체로 만들기위해서 씀.<br>빌트인 생성자 함수?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 객체의 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">'Lee'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Lee", sayHello: ƒ&#125;</span></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>
<p>생성자(constructor) 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.</p>
</li>
<li><p>생성자 함수</p>
</li>
<li><ol>
<li>객체 리터럴에 의한 객체 생성 방식의 문제점</li>
</ol>
</li>
</ol>
<p>객체 리터럴에 의해 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle1 = &#123;</span><br><span class="line">  radius: <span class="number">5</span>,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = &#123;</span><br><span class="line">  radius: <span class="number">10</span>,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 생성자 함수에 의한 String 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Lee'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj);        <span class="comment">// String &#123;"Lee"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 생성자 함수에 의한 Number 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj);        <span class="comment">// Number &#123;123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean 생성자 함수에 의한 Boolean 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> boolObj= <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj);        <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 생성자 함수에 의한 Function 객체(함수) 생성</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> func); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.dir(func);        <span class="comment">// ƒ anonymous(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에 의한 Array 객체(배열) 생성</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);        <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성</span></span><br><span class="line"><span class="keyword">const</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/i</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> regExp); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(regExp);        <span class="comment">// /ab+c/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date 생성자 함수에 의한 Date 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(date);        <span class="comment">// Fri Feb 14 2020 17:17:59 GMT+0900 (대한민국 표준시)</span></span><br></pre></td></tr></table></figure>
<p>2.2. 생성자 함수에 의한 객체 생성 방식의 장점<br>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="comment">//객체 리터럴로 만든건 인스턴스 x 객체라고부름., 생성자 함수나 클래스로 만든게 인스턴스라고 부른다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;     </span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);  <span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>this<br>this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.<br>//여긴 암기.<br>함수 호출 방식                  this가 가리키는 값<br>일반 함수로서 호출                전역 객체<br>메소드로서 호출                    메소드를 호출한 객체<br>생성자 함수로서 호출              생성자 함수가 (미래에) 생성할 인스턴스</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 다양한 방식으로 호출될 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출</span></span><br><span class="line"><span class="comment">// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드로서 호출</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;; <span class="comment">// ES6 프로퍼티 축약 표현</span></span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> foo(); <span class="comment">// inst</span></span><br></pre></td></tr></table></figure>
<p>생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다. 하지만 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</p>
<p>만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.</span></span><br><span class="line"><span class="comment">// 즉, 일반적인 함수의 호출이다.</span></span><br><span class="line"><span class="keyword">const</span> circle3 = Circle(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle3); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 함수 Circle내의 this는 전역 객체를 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(radius); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>2.3. 내부 메소드 [[Call]]과 [[Construct]]<br>함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 즉, 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 객체이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼티를 소유할 수 있다.</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메소드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.method(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>2.4. constructor와 non-constructor의 구분<br>자바스크립트 엔진은 함수를 생성할 때, FunctionCreate이라는 추상 연산(abstract operation)을 사용한다.<br>추상 연산 FunctionCreate는 함수 정의가 평가될 때 호출된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 일반 함수 정의 : kind &#x3D; &#39;Normal&#39;</span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line">const bar &#x3D; function () &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; 프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.</span><br><span class="line">const baz &#x3D; &#123;</span><br><span class="line">  x: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 함수로 정의된 함수만이 constructor이다.</span><br><span class="line">new foo(); &#x2F;&#x2F; OK</span><br><span class="line">new bar(); &#x2F;&#x2F; OK</span><br><span class="line">new baz.x(); &#x2F;&#x2F; OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 화살표 함수 정의 : kind &#x3D; &#39;Arrow&#39;         </span><br><span class="line">const arrow &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">new arrow(); &#x2F;&#x2F; TypeError: arrow is not a constructor</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 메소드 정의 : kind &#x3D; &#39;Method&#39;</span><br><span class="line">&#x2F;&#x2F; ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new obj.x(); &#x2F;&#x2F; TypeError: obj.x is not a constructor</span><br></pre></td></tr></table></figure>
<p>일반적으로 프로퍼티의 값인 함수는 모두 메소드로 통칭한다. 함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출: [[Call]]이 호출된다.</span></span><br><span class="line"><span class="comment">// 모든 함수 객체는 [[Call]]이 구현되어 있다.</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출: [[Construct]]가 호출된다.</span></span><br><span class="line"><span class="comment">// 이때 [[Construct]]를 갖지 않는다면 에러가 발생한다.</span></span><br><span class="line"><span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure>
<p>2.5. 생성자 함수의 인스턴스 생성 과정<br>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">런타임 이전에 빈객체 생성 thie = 빈 객체 ,암묵적으로 <span class="keyword">this</span> ruturn 한다. new가있으면 이렇게 동작, 없으면 일반함수처럼 동작.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 인스턴스 초기화</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);  <span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br></pre></td></tr></table></figure>
<p>생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다. 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다.</p>
<p>자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수가 호출되면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 인스턴스를 초기화한 후, 인스턴스를 반환한다.</p>
<ol>
<li>인스턴스 생성과 this 바인딩</li>
</ol>
<p>암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 (아직 완성되지는 않았지만) 생성자 함수가 생성한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다.</p>
<p>바인딩(binding)<br>바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다.</p>
<ol start="2">
<li>인스턴스 초기화</li>
</ol>
<p>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</p>
<ol start="3">
<li>인스턴스 반환</li>
</ol>
<p>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.</p>
<p>2.6. new 연산자</p>
<p>new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수로서 정의하지 않은 일반 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> add();</span><br><span class="line"><span class="comment">// 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(inst); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체를 반환하는 일반 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params">name, role</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name, role &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span></span><br><span class="line">inst = <span class="keyword">new</span> createUser(<span class="string">'Lee'</span>, <span class="string">'admin'</span>);</span><br><span class="line"><span class="comment">// 함수가 생성한 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(inst); <span class="comment">// &#123;name: "Lee", role: "admin"&#125;</span></span><br></pre></td></tr></table></figure>

<p>2.7. new.target</p>
<p>new.target은 this와 유사하게 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티(meta propery)라고 부른다.<br>함수 내부에서 new.target를 사용하면 new 연산자와 함께 함수가 호출되었는지 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">집에가서 해보기.</span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope-Safe Constructor Pattern</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고</span></span><br><span class="line">  <span class="comment">// this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.</span></span><br><span class="line">  <span class="comment">// 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Circle)) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</p>
<p>예를 들어, Object 또는 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj = <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x ** x'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">// ƒ anonymous(x) &#123; return x ** x &#125;</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x ** x'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">// ƒ anonymous(x) &#123; return x ** x &#125;</span></span><br></pre></td></tr></table></figure>
<p>하지만 String 생성자 함수는 new 연산자와 함께 호출했을 때 String 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열 리터럴을 반환한다. 즉 문자열로 타입을 변환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/08/js0308-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/js0308-2/" class="post-title-link" itemprop="url">프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 11:21:30" itemprop="dateCreated datePublished" datetime="2020-03-08T11:21:30+09:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 10:58:49" itemprop="dateModified" datetime="2020-03-10T10:58:49+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.내부 슬롯과 내부 메소드<br>이중 대괄호([[…]])로 감싼 이름들이 내부 슬롯과 내부 메소드이다. 외부로 공개된 객체의 프로퍼티는 아니지만 엔진 내부 로직이고 직접적으로 호출할 방법은 제공하지않으나 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수단을 제공하기도 한다.</p>
<p>2.프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체<br>-프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)를 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "Lee", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: &#123;value: "Lee", writable: true, enumerable: true, configurable: true&#125;,</span></span><br><span class="line"><span class="comment">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>데이터 프로퍼티와 접근자 프로퍼티</li>
</ol>
<p>-데이터 프로퍼티(Data property)<br>키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.<br>-접근자 프로퍼티(Accessor property) 제일 중요.<br>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수(Accessor function)로 구성된 프로퍼티다.</p>
<p>3.1 데이터 프로퍼티<br>프로퍼티어트리뷰트  프로퍼티 디스크립터 객체의 프로퍼티<br>[[Value]]    value    </p>
<ul>
<li>프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다.</li>
<li>프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.<br>[[Writable]]    writable    </li>
<li>프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.</li>
<li>[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.<br>[[Enumerable]]    enumerable    </li>
<li>프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.</li>
<li>[[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.<br>[[Configurable]]    configurable    </li>
<li>프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.</li>
<li>[[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "Lee", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>3.2. 접근자 프로퍼티<br>접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/76272192-0c6d0100-62be-11ea-92a0-a7996a7c2ab6.png" alt="캡처_2020_03_10_10_57_29_202"><br>접근자 함수는 getter/setter 함수라고도 부른다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  firstName: <span class="string">'Ungmo'</span>,</span><br><span class="line">  lastName: <span class="string">'Lee'</span>,</span><br><span class="line">코딩으로 직접 써보면서 해보기.</span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;                   <span class="keyword">get</span> <span class="keyword">set</span>이 붙으면 funllname은 메소드 이름이 아니라 프로퍼티 이름이다.</span><br><span class="line">    return `$&#123;<span class="keyword">this</span>.firstName&#125; $&#123;<span class="keyword">this</span>.lastName&#125;<span class="string">`;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  // setter 함수</span></span><br><span class="line"><span class="string">  set fullName(name) &#123;</span></span><br><span class="line"><span class="string">    [this.firstName, this.lastName] = name.split(' ');</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.</span></span><br><span class="line"><span class="string">console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="string">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line"><span class="string">person.fullName = 'Heegun Lee';</span></span><br><span class="line"><span class="string">console.log(person); // &#123;firstName: "Heegun", lastName: "Lee"&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="string">// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.</span></span><br><span class="line"><span class="string">console.log(person.fullName); // Heegun Lee</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// firstName는 데이터 프로퍼티이다.</span></span><br><span class="line"><span class="string">// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="string">let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');</span></span><br><span class="line"><span class="string">console.log(descriptor);</span></span><br><span class="line"><span class="string">// &#123;value: "Heegun", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// fullName는 접근자 프로퍼티이다.</span></span><br><span class="line"><span class="string">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="string">descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');</span></span><br><span class="line"><span class="string">console.log(descriptor);</span></span><br><span class="line"><span class="string">// &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">접근자 프로퍼티와 데이터 프로퍼티 구별 방법.</span><br><span class="line"><span class="comment">// 일반 객체의 __proto__는 접근자 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>);</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체의 prototype은 데이터 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="string">'prototype'</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>프로퍼티 정의<br>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'firstName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Ungmo'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'lastName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Lee'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'firstName'</span>, descriptor);</span><br><span class="line"><span class="comment">// firstName &#123;value: "Ungmo", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'lastName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'lastName'</span>, descriptor);</span><br><span class="line"><span class="comment">// lastName &#123;value: "Lee", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Enumerable]]의 값이 false인 경우,</span></span><br><span class="line"><span class="comment">// 해당 프로퍼티는 for…in 문이나 Object.keys 등으로 열거할 수 없다.</span></span><br><span class="line"><span class="comment">// lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로 열거되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ["firstName"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.</span></span><br><span class="line"><span class="comment">// lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.</span></span><br><span class="line"><span class="comment">// 이때 값을 변경하면 에러는 발생하지 않고 무시된다.</span></span><br><span class="line">person.lastName = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.</span></span><br><span class="line"><span class="comment">// lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.</span></span><br><span class="line"><span class="comment">// 이때 프로퍼티를 삭제하면 에러는 발생하지 않고 무시된다.</span></span><br><span class="line"><span class="keyword">delete</span> person.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 재정의할 수 없다.</span></span><br><span class="line"><span class="comment">// Object.defineProperty(person, 'lastName', &#123; enumerable: true &#125;);</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: lastName</span></span><br><span class="line"></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'lastName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'lastName'</span>, descriptor);</span><br><span class="line"><span class="comment">// lastName &#123;value: "Lee", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'fullName'</span>, &#123;</span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span>(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'fullName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fullName'</span>, descriptor);</span><br><span class="line"><span class="comment">// fullName &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line">person.fullName = <span class="string">'Heegun Lee'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;firstName: "Heegun", lastName: "Lee"&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>프로퍼티   대응하는어트리뷰트        프로퍼티 누락 시의 기본값.<br>value            [[Value]]                      undefined<br>get              [[Get]]                        undefined<br>set              [[Set]]                        undefined<br>writable        [[Writable]]                   false<br>enumerable      [[Enumerable]]                 false<br>configurable    [[Configurable]]               false</p>
<ol start="5">
<li>객체 변경 방지<br>객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 프로퍼티를 추가 또는 삭제할 수 있고,값을 갱신할 수 있다.<br>Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 재정의할 수도 있다.<br><img src="https://user-images.githubusercontent.com/56964928/76271632-74224c80-62bc-11ea-84f3-912b84ad1c2e.png" alt="캡처_2020_03_10_10_44_52_378"></li>
<li>1 객체 확장 금지<br>Object.preventExtensions 메소드는 객체의 확장을 금지한다. 객체 확장 금지란 프로퍼티 추가 금지를 의미한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다. 프로퍼티는 프로퍼티 동적 추가와 Object.defineProperty 메소드로 추가할 수 있다. 이 두가지 추가 방법이 모두 금지된다.</li>
</ol>
<p>확장이 금지된 객체인지 여부는 Object.isExtensible 메소드로 확인 할 수 있다.</p>
<p>5.2 객체 밀봉<br>Object.seal 메소드는 객체를 밀봉한다. 객체 밀봉(seal)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다.</p>
<p>밀봉된 객체인지 여부는 Object.isSealed 메소드로 확인 할 수 있다.</p>
<p>5.3. 객체 동결<br>Object.freeze 메소드는 객체를 동결한다. 객체 동결(freeze)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉, 동결된 객체는 읽기만 가능하게 된다.</p>
<p>밀봉된 객체인지 여부는 Object.isFrozen 메소드로 확인 할 수 있다.</p>
<p>5.4. 불변 객체<br>지금까지 살펴본 변경 방지 메소드들은 얕은 변경 방지(Shallow only)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다. 따라서 Object.freeze 메소드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/08/js0308/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/js0308/" class="post-title-link" itemprop="url">let,const와 블록 레벨 스코프.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 11:20:30" itemprop="dateCreated datePublished" datetime="2020-03-08T11:20:30+09:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-09 22:02:33" itemprop="dateModified" datetime="2020-03-09T22:02:33+09:00">2020-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.var 변수는 같은 스코프내에서 중복 선언이 가능하다.대신, 나중에 선언된 변수 선언문은 var 키워드가 없는것처럼 동작한다.사용하지 않는 것이 좋다.<br>1.2 함수 레벨 스코프<br>-var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다.함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다.<br>함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다.</span></span><br><span class="line">  <span class="comment">// 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>-for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다.</p>
<p>1.3 변수 호이스팅<br>var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 할당문 이전에 변수를 참조하면 undefined를 반환한다.</p>
<p>2.let 키워드<br>2.1 변수 중복 선언 금지<br>var의 중복 선언 부작용을 개선하기 위해 나온 let은 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러가 발생한다.</p>
<p>2.2 블록 레벨 스코프<br>var 키워드는 함수의 코드 블록 만을 지역 스코프로 인정하는 함수 레벨 스코프를 따르고, let 키워드는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p>
<p>2.3 변수 호이스팅<br>let,const,class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작하지만<br>let,const 등을 포함하여 모든 선언(var, let, const, function, function*, class 등)은 호이스팅한다.<br>let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다. 선언 단계는 런타임 이전에 암묵적으로 실행되고,초기화 단계는 변수 선언문에 도달했을 때 실행된다.스코프 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지의 구간을 일시적 사각지대라고하고 이때는 변수를 참조할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 런타임 이전에 선언 단계가 실행된다.</span></span><br><span class="line"><span class="comment">// 아직 변수가 초기화되지 않았다. 따라서 변수 선언문 이전에 변수를 참조할 수 없다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo; <span class="comment">// 변수 선언문에서 초기화 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">1</span>; <span class="comment">// 할당문에서 할당 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/56964928/76151089-3e326c00-60f4-11ea-9035-92361caa4e2e.png" alt="let1"></p>
<p>2.4. 전역 객체와 let<br>-전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.<br>-var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 변수</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 암묵적 전역</span></span><br><span class="line">y = <span class="number">2</span>;    y 앞에 <span class="built_in">window</span>.이 숨어져있음.</span><br><span class="line"><span class="comment">// 전역 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 전역은 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// ƒ foo() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>const 키워드<br>const 키워드는 상수(constant)를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. </li>
</ol>
<p>3.1 선언과 초기화<br>const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면 문법 에러가난다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 변수 호이스팅이 발생하지 않는 것처럼 동작한다</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: Cannot access 'foo' before initialization</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 블록 레벨 스코프를 갖는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>3.2 재할당 금지</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 키워드로 선언한 변수는 재할당이 금지된다.</span><br><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</span><br><span class="line">foo = <span class="number">2</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>3.3 상수<br>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다.<br>변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다.<br>const 키워드로 선언된 변수에 원시 값을 할당한 경우, 원시 값은 변경할 수 없는 값(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</p>
<p>3.3 const 키워드와 객체<br>const 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경할 수 있다. 객체는 변경이 가능한 값이기 때문에 재할당없이 직접 변경이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.</span></span><br><span class="line">person.name = <span class="string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Kim"&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>var vs. let vs. const</li>
</ol>
<ul>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/27/js0227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/js0227/" class="post-title-link" itemprop="url">자바스크립트 28일 예습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 21:35:30" itemprop="dateCreated datePublished" datetime="2020-02-27T21:35:30+09:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-28 00:25:52" itemprop="dateModified" datetime="2020-02-28T00:25:52+09:00">2020-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.변수의 생명 주기</p>
<p>1.1 지역 변수의 생명 주기<br>지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">//10</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="built_in">ReferenceError</span>: x is not defined</span><br></pre></td></tr></table></figure>
<p>foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 변수 x의 선언문이 가장 먼저 실행되어 변수 x가 선언되고 undefined로 초기화된다. 함수 몸체의 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 변수 x에 값이 할당된다. 함수가 종료하면 변수 x도 소멸되어 생명 주기가 종료된다. 함수 내부에서 선언된 지역 변수 x는 foo 함수가 호출되어 실행되는 동안에만 유효하다. 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'member'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">//member</span></span><br></pre></td></tr></table></figure>
<p>함수 foo 내부에 선언된 지역 변수 x는 이미 선언되어 undefined로 초기화 되었다.따라서 지역 변수 x를 참조하여 값을 출력한다. 이처럼 호이스팅은 스코프를 단위로 동작한다.<br>지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다.호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 고유의 특징을 말한다.</p>
<p>1.2 전역 변수의 생명 주기<br>전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점없이 코드가 로드되자마자 곧바로 해석되고 실행된다.</p>
<p>함수는 함수 몸체의 마지막 문 또는 return문이 실행되면 종료한다.<br>전역 코드는 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.<br>var 키워드로 선언한 전역 변수는 전여 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다.</p>
<p>전역 객체:코드가 실행되기 이전 단계에 엔진에 의해 생성되는 특수한 객체.<br>전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.</p>
<p>2.전역 변수의 문제점<br>1.암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변수의 유효 범위가 커져서 가독성이 나빠지고 의도치않은 상태 변경이 될 위험도 높아진다.<br>2.긴 생명 주기:생명 주기가 길어서 메모리 리소스도 오랜 기간 소비한다.또한 변수 이름이 중복될 위험성이 있고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다.<br>3.스코프 체인 상에서 종점에 확대: 스코프 체인 상에서 종점에 존재해 변수를 검색할 때 전역 변수가 가장 마지막에 검색되어 검색 속도가 가장 느리다.<br>4.네임 스페이스 오염:하나의 전역 스코프를 공유해서 다른 파일 내에 동일한 이름으로 명명된 변수나 함수가 같은 소코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</p>
<p>3.전역 변수 사용 억제 방법<br>변수의 스코프는 좁을수록 좋으므로 가급적 지역 변수를 사용하여야 한다.</p>
<p>3.1 즉시 실행 함수<br>함수의 정의와 동시에 즉시 실행 함수는 단 한번만 호출되기에 모든 코드를 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>; <span class="comment">// 즉시 실행 함수의 지역 변수</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">이 방법을 사용하면 전역 변수를 생성하지 라이브러리에 주로 쓰인다.</span><br></pre></td></tr></table></figure>

<p>3.2 네임 스페이스 객체</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법.</span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'Lee'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.name); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성하는 방법.</span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line"></span><br><span class="line">MYAPP.person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  address: <span class="string">'Seoul'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.person.name); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>

<p>3.3 모듈 패턴<br>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것이다. 모듈 패턴은 클로저를 기반으로 동작한다.전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/02/26/js0226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/js0226/" class="post-title-link" itemprop="url">자바스크립트 27일 예습 복습.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 21:35:30" itemprop="dateCreated datePublished" datetime="2020-02-26T21:35:30+09:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-28 16:48:36" itemprop="dateModified" datetime="2020-02-28T16:48:36+09:00">2020-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>함수란?<br>함수는  문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.<br>함수 f(x, y) = x + y를 자바스크립트의 함수로 표현.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x, y) = x + y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(2, 5) = 7</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value).함수는 여러 개 존재할 수 있으므로 구별하기위해 식별자인 함수 이름 사용이 가능하다.<br>함수를 output하는것을 반환한다고 한다.return을 써서 반환을 한다.<br>프로퍼티키는 식별자 이름 안맞아도 되지만 귀찮아진다.<br>{}&lt;여기에 문이 들어오기 때문에 블록문이라고 부른다(0개이상.)<br><img src="https://user-images.githubusercontent.com/56964928/75345067-524dc080-58df-11ea-9957-f1181f2c3d66.png" alt="함수1"></p>
</li>
</ol>
<p>함수는 함수 정의(Function definition)를 통해 생성한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>정의만으론 함수가 실행되지 않는다.<br>함수호출을해서 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행 결과,즉 반환값을 반환한다.<br>함수 호출:입력,즉 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는것.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>얕은 복사:1단계만 복사 이유는 퍼포먼스가 떨어지기 때문에. {…o};<br>깊은 복사:재귀함수 등.<br>2. 함수의 사용 이유<br>동일한 작업을 반복 수행할때 코드의 중복을 막고 몇번이든 호출 할수 있으므로 코드의 재사용이라는 측면에서 매우 유용하기 때문에 사용한다.또한 이러한 이유로 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과도 있다.</p>
<p>3.함수 리터럴<br>함수는 객체 타입의 값이다. 함수도 리터럴을 생성할 수 있다. 함수 리터럴은 fucntion 키웓, 함수이름,매개변수 목록함수 몸체로 구성된다.함수 리터럴은 함수 이름을 생략할수도있고 안해도된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수에 함수 리터럴을 할당</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>-함수 이름<br>1.함수 이름은 식별자이다.따라서 식별자 네이밍 규칙을 준수해야 한다.<br>2.함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.(중요)<br>3.함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명 함수,함수 이름이 없는 함수를 익명 함수라고한다.<br>-매개변수 목록<br>1.0개 이상의 매개변수를 소갈호로 감싸고 쉼표로 구분한다.<br>2.매개변수에는 함수호출문의 인수가 순서대로 할당된다.매개변수 목록은 순서에 의미가 있따.<br>3.매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다.따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 따라야한다.<br>-함수 몸체<br>1.함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.<br>2.함수 몸체는 함수 호출에 의해 실행된다.</p>
<p>함수 리터럴은 평가되어 값을 생성하며 이 값은 객체다.즉, 함수는 객체다.<br>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.그리고 일반 객체에는없는 함수 객체만의 고유한 프로퍼티가 있다.</p>
<p>4.함수 정의<br>함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다.4가지 방법이 있다.</p>
<p>-함수 선언문(Function declaration/Function statement)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수 선언문은 함수 이름을 생략할 수 없다.(왜냐면 이 이름으로 식별자를 만들기 때문에)<br>선언문 특징: 모든 선언문은 런타임 이전에 실행된다.함수 이름을 가지고 식별자를 만든다.할당까지 런타임 이전에 한다.함수 선언문은 런타임 이전에 할당까지 해주기 때문에 참조 할 수 있다.그게 변수 호이스팅과 다른점이다.<br>-함수 표현식(Function expression)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">참조(<span class="literal">undefined</span> 상태)는 되지만 호출은 안된다.호이스팅 발생 안된다.</span><br></pre></td></tr></table></figure>

<p>-Function 생성자 함수(Function constructor)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>);</span><br><span class="line">알고만 있길, 거의 안씁니다.써서도 안됨.</span><br></pre></td></tr></table></figure>
<p>-화살표 함수(Arrow function): ES6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<p>4.1. 함수 선언문<br>함수 선언문과 표현식만 알면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">함수 선언문</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="comment">// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.</span></span><br><span class="line"><span class="comment">// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// ƒ add(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출    함수 객체를 가리키고 있는 식별자로 함수 호출을 한다. 일반 객체는 호출할수있고, 함수 객체는 호출 할 수 없다.</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문은 함수 이름을 생략할 수 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Function statements require a function name</span></span><br></pre></td></tr></table></figure>
<p>함수 선언문은 표현식이 아닌 문이다.함수 선언문을 실행하면 완료 값 undifiend를 출력한다.만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 한다.</p>
<p>표현식이 아닌 문은 변수에 할당할 수 없다.함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다.하지만 아래에는 함수 선언문이 변수에 할당되는 것처럼 보인다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.</span></span><br><span class="line"><span class="comment">// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>이렇게 동작하는 이유는 엔진이 상황에 따라 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.<br>함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다. 이는 함수 이름이 있는 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있따는 의미이다.</p>
<p>함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고 값으로 평가되어야만 하는 문맥, 예를 들어 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석된다. 둘 다 함수가 생성되는 것은 동일하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.</span></span><br><span class="line"><span class="comment">// 함수 선언문은 함수 이름을 생략할 수 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>); &#125;</span><br><span class="line">foo(); <span class="comment">// foo                           foo는 참조 ()은 호출 참조할 수 있어야 호출할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.</span></span><br><span class="line"><span class="comment">// 함수 리터럴은 함수 이름을 생략할 수 있다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'bar'</span>); &#125;);</span><br><span class="line">bar(); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure>
<p>함수 리터럴(foo)는 함수 선언문으로 해석된다. 하지만 그룹 연산자 () 내에 있는 함수 리터럴(bar)은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다. 그룹 연산자의 피연산자는 값으로 평가할 수 있는 표현식이다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다.</p>
<p>함수 리터럴은 상황에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.함수 선언문 foo는 호출할 수 있지만 함수 리터럴 표현식으로 생성된 bar는 호출 할 수 없다.bar가 호출 될 수 없는 이유는 함수 리터럴은 함수 몸체 내에서만 참조 할 수 있는 식별자이기 때문에 몸체 외부에서 함수 이름으로 함수를 참조할수없기때문에 호출 할 수 없다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75345069-524dc080-58df-11ea-8578-5e81372b093a.png" alt="함수2"></p>
<p>위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름이므로 foo로 함수를 호출할 수 없어야 한다. foo라는 이름으로 함수를 호출하려면 foo는 함수 이름이 아니라 함수 객체를 할당한 식별자이어야 한다. 그런데 위 예제에는 식별자 foo를 선언한 적도 없고 할당한 적도 없다. foo는 도대체 무엇인가? 결론부터 말하자면 foo는 생성된 함수 객체를 할당하고 있는 자바스크립트 엔진이 암묵적으로 생성한 식별자이다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75345071-52e65700-58df-11ea-83dc-5b30aa17ebab.png" alt="함수3"></p>
<p>함수 선언문은 실행되어 함수 객체를 생성한다. 이때 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 생성된 함수 객체를 가리키는 식별자가 필요하다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 호출할 수 없고 아무도 참조하고 있지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제된다. 이를 위해 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">5</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.함수 이름 add가 아니라 엔진이 암묵적으로 생성한 식별자 add인 것이다.함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출된 것이다.</p>
<p>-함수3-</p>
<p>4.2 함수 표현식<br>함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다.<br>이처럼 값의 성질을 갖는 객체를 일급 객체라 한다.<br>함수 = 일급 객체 = 함수를 값처럼 자유롭게 사용 가능.</p>
<p>함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>함수 리터럴은 함수 이름을 생략할 수 있다.이러한 함수를 익명 함수라한다.함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체를 가리키는 식별자로 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 이름으로 호출하면 ReferenceError가 발생한다.</span></span><br><span class="line"><span class="comment">// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 함수 선언문은 “표현식이 아닌 문”이고 함수 표현식은 “표현식인 문”이다. 미묘하지만 중요한 차이가 있다.</p>
<p>4.3 함수 생성 시점과 함수 호이스팅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// ƒ add(x, y)</span></span><br><span class="line"><span class="built_in">console</span>.dir(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// TypeError: sub is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.<br>함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출이 안되고, 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.</p>
<p>함수 선언문은 런타임 이전에 엔진에 의해 먼저 실행된다.즉,런타임 이전에 함수 객체가 먼저 생성된다.그리고 난 후 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.즉, 코드가 한줄씩 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.</p>
<p>함수도 호이스팅처럼 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 고유의 특징이 있는데 이를 함수 호이스팅이라한다.</p>
<p>함수 호이스팅과 변수 호이스팅 모두 런타임 이전에 먼저 실행되어 식별자를 생성하지만, 변수는 undefined로 초기화되고 함수 선언문을 통해 생성된 식별자는 함수 객체로 초기화된다.결론적으로 변수는 선언문 이전에 변수를 참조하면 undefined로 평가되고,함수 선언문은 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.</p>
<p>함수 표현식은 변수 할당문의 값이 함수 리터럴인 문이다.변수 할당문의 값은 할당문이 실행되는 시점,즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.<br>따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/75345073-537eed80-58df-11ea-91da-0a915a936fa4.png" alt="함수4"></p>
<p>함수 표현식 이전에 함수를 참조하면 undefined로 평가된다. 따라서 이때 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출하여야 한다.</p>
<p>4.4Function 생성자 함수<br>자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.)<br>생성자 함수:객체를 생성하는 함수를 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> 생성자 함수로 add함수를 생성.</span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>4.5. 화살표 함수<br>ES6에서 새로 도입된 함수. function대신 화살표(=&gt;)로 함수를 선언할 수 있다.화살표 함수는 익명 함수로 정의한다.화살표 함수는 생성자 함수로 사용할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//화살표 함수</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>5.함수 호출<br>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다.</p>
<p>5.1매개변수와 인수<br>함수의 실행을 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다.인수는 값으로 평가될 수 있는 표현식이어야 하며 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;                      </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x,y부분은 변수처럼 함수가 실행되기 이전에 undefined로 할당된다.</span></span><br><span class="line"><span class="comment">//함수 호출</span></span><br><span class="line"><span class="comment">// 인수 1과 2는 매개 변수x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>매개 변수는 함수를 정의할 때 사용하며 함수 몸체 내부에서 변수와 동일하게 취급된다.함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.<br>매개변수는 함수 내부에서만 참조할 수 있다.<br><img src="https://user-images.githubusercontent.com/56964928/75345075-537eed80-58df-11ea-89d6-68fd7fde7521.png" alt="함수5"></p>
<p>함수는 매개변수의 개수와 인수의 개수가 맞지 않은 경우 인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line">Nan이 난 이유는 인수가 부족하여 x+y는 <span class="number">2</span>+<span class="literal">undefined</span>와 같으므로 <span class="literal">NaN</span>이 반환된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>)) <span class="comment">// 7</span></span><br><span class="line">인수가 초과하는 경우는 무시된다.초과된 인수는 버려지는 것이 아니라 모든 인수는 암묵적으로 argument 객체의 프로퍼티로 보관된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span> 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할때 유용하게 사용한다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>5.2 인수 확인</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>));  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'a'</span> , <span class="string">'b'</span>))  <span class="comment">//ab</span></span><br><span class="line">이런 결과가 나오는 이유는 <span class="number">2</span>가지이다.</span><br><span class="line"><span class="number">1.</span>함수는 인수의 개수와 매개변수의 개수가 일치하는지 확인하지 않는다.</span><br><span class="line"><span class="number">2.</span>함수는 매개변수의 타입을 사전에 지정할 수 없다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">'number'</span> || <span class="keyword">typeof</span> y !== <span class="string">'number'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'매개변수에 숫자 타입이 아닌 값이 할당 되었습니다.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>));   <span class="comment">// TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'a'</span>, <span class="string">'b'</span>));  <span class="comment">// TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.</span></span><br><span class="line">에러는 런타임에 발생하게 된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a = a || <span class="number">0</span>;</span><br><span class="line">  b = b || <span class="number">0</span>;</span><br><span class="line">  c = c || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">arguments</span> 객체를 통해 인수 개수를 확인하는 방법.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 0</span></span><br><span class="line">ES6에서 도입된 매개변수 기본값을 사용하면(a=<span class="number">0</span>넣어서)  함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.단, 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 겨웅와 <span class="literal">undefined</span>를 전달한 경우만 유효.</span><br></pre></td></tr></table></figure>
<p>5.3 매개변수의 최대 개수<br>최대 개수에 대해 명시적으로 제한하고 있지 않지만,적을 수록 좋다.최대 3개 이상 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다.이상적인 함수는 가급적 적게 만들어야 한다.그리고 매개변수는 순서에 의미가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Lee'</span> &#125;,</span><br><span class="line">  cache: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">객체를 인수로 사용하는 경우,프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다.또한 명시적으로 값의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성이 좋아지고 실수도 줄어드는 효과가 있다.</span><br><span class="line">함수 바깥에 <span class="keyword">var</span> 변수를 만들지않았기 때문에 외부에서 접근할 방법이없음.</span><br></pre></td></tr></table></figure>
<p>5.4 반환문</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">함수는 <span class="keyword">return</span> 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환할수 있다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y; <span class="comment">// 값의 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 반환값으로 평가된다.</span></span><br><span class="line"><span class="keyword">var</span> result = multiply(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 15</span></span><br><span class="line">multiply 함수는 두개의 인수를 전달받아서 곱한 결과를 반환한다.반환값은 <span class="keyword">return</span> 키워드를 사용해 반환한다. 함수는 <span class="keyword">return</span> 키워드를 통해서 모든 값을 반환할 수 있다.</span><br></pre></td></tr></table></figure>
<p>반환문은 두가지 역할을 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y; <span class="comment">// 반환문</span></span><br><span class="line">  <span class="comment">// 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'실행되지 않는다.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>반환문은 <span class="keyword">return</span> 키워드 뒤에 지정한 값을 반환한다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">함수는 반환문을 생략할 수 있다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 반환문을 생략하면 암묵적으로 undefined가 반환된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return 키워드와 반환값 사이에 줄바꿈이 있으면</span></span><br><span class="line">  <span class="keyword">return</span> <span class="comment">// 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론이 추가된다.</span></span><br><span class="line">  x * y; <span class="comment">// 무시된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>6.참조에 의한 전달과 외부 상태의 변경<br>원시 값은 값에 의한 전달,객체는 참조에 의한 전달 방식으로 동작한다.매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달,참조에 의한 전달 방식을 그대로 따른다.<br>원시 값은 불변값이기 때문에 문제되지 않지만, 객체의 경우 값이 변할 수 있고 참조에 의한 전달 방식으로 동작하기 때문에 여러 변수가 참조에 의한 전달 방식을 통해 참조값을 공유하고 있다면 이 변수들은 언제든지 참조하고 있는 객체를 직접 변경할 수 있는 문제가 발생 할 수 있다.<br>이러한 문제를 해결하는 방법 중 하나는 객체를 불변 객체로 만들어 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 것이다.<br>7.다양한 함수의 형태</p>
<p>7.1 즉시실행함수<br>함수 정의된 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE)라고한다.단 한번만 호출되며 다시 호출할 수는 없다.따라서 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());      &#123;&#125;까지 함수 리터럴 ()부터 함수 호출 일단 &#123;&#125;까지 함수 리터럴이라고 인식함.</span><br><span class="line">사용할때 <span class="number">1.</span>인위적인 스코프를 만들때. 왜냐면 전역 변수를 안쓰려고. 함수를 빨리 저세상으로 보내려고.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기명 즉시 실행 함수</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">그룹 연산자 (…) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// SyntaxError: Function statements require a function name</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br><span class="line">즉시 실행 함수는 반드시 그룹 연산자(...)로 감싸 주어야 한다.그렇지 않으면 에러가 발생한다.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;(); <span class="comment">// SyntaxError: Unexpected token ')'</span></span><br><span class="line">에러가 발생하는 이유는 엔진이 암묵적으로 함수 선언문이 끝나는 위치,함수 코드 블록의 닫는 중괄호 뒤에<span class="string">":"</span>이 암묵적으로 추가되기 때문이다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;(); <span class="comment">// =&gt; function foo() &#123;&#125;;();</span></span><br><span class="line">따라서 함수 선언문 뒤의 그룹 연산자에 피연산자가 없기 때문에 에러가 발생한다.</span><br><span class="line">(); <span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line">그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;));  <span class="comment">// function</span></span><br><span class="line">그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다.</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line">먼저 함수를 평가하여 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용할 수도 있다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> res = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.</span></span><br><span class="line">res = (<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>7.2 재귀 함수<br>함수가 자기 자신을 호출하는 것을 재귀 호출이라하는데,재귀 호출을 수행하는 함수를 재귀 함수라한다.<br>재귀 함수는 자신을 무한 재귀 호출하기 때문에 함수 내에 탈출 조건을 반드시 만들어야 한다.<br>재귀 함수는 한정적으로 사용하는것이 바람직하다.깊은 복사할때 재귀함수가 쓰인다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 함수를 가리키는 식별자로 자기 자신을 재귀 호출</span></span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 함수 이름으로 자기 자신을 재귀 호출할 수도 있다.</span></span><br><span class="line">  <span class="comment">// console.log(factorial === foo); // true</span></span><br><span class="line">  <span class="comment">// return n * foo(n - 1);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 5! = 5 * 4 * 3 * 2 * 1 = 120</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> res = n;</span><br><span class="line">  <span class="keyword">while</span> (--n) res *= n;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">0</span>)); <span class="comment">// 0! = 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">1</span>)); <span class="comment">// 1! = 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">2</span>)); <span class="comment">// 2! = 2 * 1 = 2</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>)); <span class="comment">// 3! = 3 * 2 * 1 = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>)); <span class="comment">// 4! = 4 * 3 * 1 * 1 = 24</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 5! = 5 * 4 * 3 * 2 * 1 = 120</span></span><br><span class="line">왠만하면 <span class="keyword">while</span>문으로 대체하라.</span><br></pre></td></tr></table></figure>
<p>7.3 중첩 함수<br>함수 내부에 정의된 함수를 중첩 함수 or 내부 함수라 하고,중첩 함수를 포함하는 함수는 외부 함수라한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line">ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.(<span class="keyword">if</span>문 <span class="keyword">for</span>문 등의 코드 블록내에서도 정의 가능하지만 호이스팅으로 인해 혼란이 발생할수 있으므로 바람직하지않다.)</span><br></pre></td></tr></table></figure>

<p>7.4 콜백 함수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n만큼 어떤 일을 반복한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// i를 출력한다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeat1(<span class="number">5</span>); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n만큼 어떤 일을 반복한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// i가 홀수일 때만 출력한다.</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeat2(<span class="number">5</span>); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복 호출한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">    f(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br><span class="line">이처럼 함수의 매개변수를 통해 전달되는 함수를 콜백 함수라고 하며,콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수라고 한다.</span><br></pre></td></tr></table></figure>

<p>7.5 순수 함수와 비순수 함수<br>어떤 외부 상태에 의존하지도 않고 변경시키지도 않는 부수효과가 없는 함수를 순수 함수,외부 상태를 변경시키는 부수효과가 있는 함수를 비순수 함수라고 부른다.</p>
<p>순수 함수의 특징.<br>1.동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다.<br>2.어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값을 만든다.<br>3.함수의 외부 상태를 변경하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> conut = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수</span></span><br><span class="line"><span class="comment">// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경</span></span><br><span class="line">conut = increase(conut);</span><br><span class="line"><span class="built_in">console</span>.log(conut); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">conut = increase(conut);</span><br><span class="line"><span class="built_in">console</span>.log(conut); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>비순수 함수의 특징은 함수의 외부 상태를 변경하는 부수 효과가 있다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수</span></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count; <span class="comment">// 외부 상태를 변경한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.</span></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<p>13.스코프<br>스코프는 (유효범위)를 뜻한다.<br>매개변수는 함수 몸체 내부에서만 참조할 수 있다.즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부이다.<br>변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.이를 스코프라한다. 스코프는 식별자가 유효한 범위를 말한다.<br>스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.</p>
<p>-변수는 코드의 가장 바깥 영역뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언할수 있고, 코드 블록이나 함수는 중첩될 수 있다.<br>모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ②</span></span><br><span class="line">코드의 가장 바깥 영역과 함수 foo 내부에 같은 이름을 갖는 변수 x를 선언하였고 ①과 ②에서 변수 x를 참조한다.</span><br></pre></td></tr></table></figure>
<p>스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다.<br>스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span></span><br><span class="line">  <span class="comment">// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>let이나 const로 선언된 변수는  지역 변수 , var는 함수 내부에서만 선언한 변수만 지역 변수다.식별자는 스코프에 저장된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier 'x' has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>2.스코프의 종류</p>
<p>코드는 전역과 지역으로 구분할 수 있다.함수만 스코프를 만든다고해서 함수 레벨 스코프라고 부른다.</p>
<p>2.1 전역과 전역 스코프</p>
<p>2.2 지역과 지역 스코프<br>지역은 함수 몸체 내부를 말한다.지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.<br>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</p>
<ol start="3">
<li>스코프 체인<br>함수는 전역에서 정의할 수도 있고 몸체 내부에서 정의할 수도 있다.함수 몸체 내부에서 함수가 정의된것을 ‘함수의 중첩’,몸체 내부에서 정의한 함수를 ‘중첩 함수’,중첩 함수를 포함하는 함수를  ‘외부 함수’라고 부른다.<br>스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라 한다.</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/56964928/75345062-511c9380-58df-11ea-9fb1-3e1c67cd91a4.png" alt="스코프1"></p>
<p>위 예제에서 지역은 outer 함수의 지역과 inner 함수의 지역이 있다. inner 함수는 outer 함수의 중첩 함수이다. 이때 outer 함수가 만든 outer 함수의 지역 스코프는 inner 함수가 만든 inner 함수의 지역 스코프의 상위 스코프이다. 그리고 outer 함수의 지역 스코프의 상위 스코프는 전역 스코프이다. 이러한 계층적 구조를 그림으로 나타내보면 아래와 같다.</p>
<p>모든 스코프가 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 계층적으로 연결된 것을 스코프 체인이라 부른다.</p>
<p>변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</p>
<p>3.1 스코프 체인에 의한 변수 검색</p>
<p>스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.</p>
<p>3.2 스코프 체인에 의한 함수 검색</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">전역에서 정의된 foo 함수와 bar 함수 내부에서 정의된 foo 함수가 있다.</span><br><span class="line"><span class="comment">// 전역 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global function foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'local function foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo(); <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">함수 선언문으로 함수를 정의하면 엔진에 의해 다른 코드가 실행되기 이전에 함수 객체가 먼저 생성된다. 그리고 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.</span><br><span class="line">위 예제의 모든 함수는 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다.①에서 함수 foo를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 변수 foo를 검색한다.</span><br><span class="line">이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다. 스코프를 <span class="string">"식별자를 검색하는 규칙"</span>이라고 표현하는 것이 적합하다.</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>함수 레벨 스코프<br>코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.<br>블록 레벨 스코프:함수 몸체 만이 아니라 모든 코드 블록이 지역 스코프를 만든다.<br>함수 레벨 스코프:var 키어드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다.</span></span><br><span class="line">  <span class="comment">// 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다.</span></span><br><span class="line">  <span class="comment">// 따라서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다.</span></span><br><span class="line">  <span class="comment">// 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;   <span class="comment">//대신에 let이나 const가 오면 지역변수이다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">전역 변수 x가 선언되었고 <span class="keyword">if</span> 문의 코드 블록 내에도 변수 x가 선언되었다. 이때 <span class="keyword">if</span> 문의 코드 블록 내에서 선언된 변수 x는 전역 변수다. var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하기 때문에 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. 따라서 전역 변수 x는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 의도치 않게 변수의 값이 변경되었다.</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>5.렉시컬 스코프(가장 중요.)<br> 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프 또는 렉시컬 스코프라고 부른다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ?</span></span><br><span class="line">bar(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>함수 bar의 상위 스코프가 무엇인지에 따라 결정된다.<br>1.함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.-&gt;함수foo,전역<br>함수 정의 시점에는 함수가 어디서 호출될 지 알 수 없다.함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.<br>2.함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.-&gt;전역<br>함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프 또는 렉시컬 스코프라고 부른다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

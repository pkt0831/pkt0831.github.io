<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="My Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="pkt0831&#39;s Blog">
<meta property="og:url" content="https://pkt0831.github.io/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="My Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/04/08/Promise(04.08)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Promise(04.08)/" class="post-title-link" itemprop="url">Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-08 09:55:30 / Modified: 21:35:32" itemprop="dateCreated datePublished" datetime="2020-04-08T09:55:30+09:00">2020-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>프로미스란?<br>자바스크립트는 비동기 처리를 위해 콜백 함수를 사용하는데 에러의 예외 처리가 곤란한 단점을 보완하기위해 비동기 처리를 위한 다른 패턴인 프로미스가 생기게 되었다. 이로인해 비동기 처리 시점이 명확하게 표현할수있게되었다.</p>
</li>
<li><p>콜백 패턴의 단점.</p>
</li>
</ul>
<p>1.콜백 헬.<br>비동기 처리를 위해 콜백 패턴을 사용하면 여러개의 콜백 함수가 정칩되어 복잡도가 높아지는 현상.<br>이러한 현상이 생기는 원인은 비동기 처리 모델은 실행 완료를 기다리지 않고 즉시 다음 태스크를 실행하기 때문에 기대한 대로 동작하지않게 된다.<br>2.에러 처리의 한계.<br>비동기 처리 함수의 콜백 함수 실행 순서는.<br>1.이벤트 발생 -&gt; 태스트 큐 이동 -&gt; 호출 스택이 비어졌을때 호출 스택으로 이동후 실행.</p>
<ul>
<li><p>프로미스의 생성.<br>프로미스는 Promise 생성자 함수를 통해 인스턴스화하고 resolve와 reject  함수를 인자로 전달받는다.<br>Promise는 비동기 처리가 성공(fulfilled)하였는지 또는 실패(rejected)하였는지 등의 상태(state) 정보를 갖는다.<br>fullfilled (성공), rejected(실패), settled(성공 또는 실패), pending(수행 안됨).</p>
</li>
<li><p>프로미스의 후속 처리 메소드<br>Promise로 구현된 비동기 함수는 Promise 객체를 반환한다. Promise 객체의 후속 처리 메소드(then, catch)를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다.<br>then: 두 개의 콜백 함수를 인자로 전달 받는다. 첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 두 번째 함수는 실패.<br>then 메소드는 Promise를 반환.<br>catch: 예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출.</p>
</li>
<li><p>프로미스의 에러 처리.<br>catch 메소드는 비동기 처리에서 발생한 에러뿐만 아니라 then메소드 내부에서 발생한 에러도 캐치한다. 에러처리는 catch메소드를 사용하는 편이 효율적이다.</p>
</li>
<li><p>프로미스 체이닝<br>프로미스는 후속 처리 메소드를 체이닝하여 여러 개의 프로미스를 연결하여 사용하여 콜백 헬을 해결한다.</p>
</li>
<li><p>프로미스의 정적 메소드.<br>4가지 정적 메소드를 제공한다.</p>
</li>
</ul>
<ol>
<li>Promise.resolve/Promise.reject<br>Promise.resolve 메소드는 인자로 전달된 값을 resolve하는 Promise를 생성.<br>Promise.reject 인자로 전달된 값을 reject하는 프로미스를 생성.</li>
</ol>
<p>2.Promise.all<br>프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다.</p>
<p>3.Promise.race<br>Promise.all처럼 배열,이터러블을 인자로 전달 받지만 차이점은 병렬로 처리하는것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 반환한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/04/04/TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/TIL/" class="post-title-link" itemprop="url">하루 정리.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-04 11:55:30" itemprop="dateCreated datePublished" datetime="2020-04-04T11:55:30+09:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-08 21:01:09" itemprop="dateModified" datetime="2020-04-08T21:01:09+09:00">2020-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>04.07<br>todo 리스트를 JSON을 이용해서 가상의 백엔드 서버를 설정하고 서버 호출 실습.<br>todo 리스트 마스터 요망. </li>
<li>04.08<br>todo 리스트 미비한거 공부 및 Promise 예습. 비동기 처리의 어려움을 느낌.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/26/js0326-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/js0326-2/" class="post-title-link" itemprop="url">js0326-2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 17:33:26" itemprop="dateCreated datePublished" datetime="2020-03-26T17:33:26+09:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-06 23:46:31" itemprop="dateModified" datetime="2020-04-06T23:46:31+09:00">2020-04-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/26/js0326/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/js0326/" class="post-title-link" itemprop="url">수학 상수와 함수를 위한 Math 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 05:55:30" itemprop="dateCreated datePublished" datetime="2020-03-26T05:55:30+09:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-30 21:46:04" itemprop="dateModified" datetime="2020-03-30T21:46:04+09:00">2020-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Math-Property"><a href="#Math-Property" class="headerlink" title="Math Property"></a>Math Property</h1><p>1.Math.Pi<br>Pi값 = 3.14… 반환.</p>
<h1 id="Math-Method"><a href="#Math-Method" class="headerlink" title="Math Method"></a>Math Method</h1><p>1.Math.abs(x: number): number<br>인수의 절댓값 반환. 반드시 0또는 양수이어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">'-1'</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">null</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">undefined</span>);<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>2 Math.round(x: number): number</p>
<p>인수의 소수점 이하를 반올림한 정수 반환.</p>
<p>3 Math.ceil(x: number): number<br>인수의 소수점 이하를 올림한 정수를 반환.</p>
<p>4 Math.floor(x: number): number<br>인수의 소수점 이하를 내림한 정수 반환.</p>
<ul>
<li>양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환</li>
<li>음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환.</li>
</ul>
<p>5 Math.sqrt(x: number): number<br>인수의 제곱근 반환.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">9</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-9</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>6 Math.random(): number<br>임의의 부동 소수점 0 ~ 1 미만 반환.</p>
<p>7 Math.pow(x: number, y: number): number<br>첫번째 인수 밑, 두번째 인수를 지수로하여 거듭제곱.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">8</span>);  <span class="comment">// 256</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>);     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>8 Math.max(…values: number[]): number<br>인수 중에서 가장 큰 수 반환.</p>
<p>9 Math.min(…values: number[]): number<br>인수 중에서 가장 작은 수 반환.</p>
<p>10.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/23/js0323/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/js0323/" class="post-title-link" itemprop="url">디스트럭처링 할당(Destructuring assignment)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-23 11:55:30 / Modified: 19:40:15" itemprop="dateCreated datePublished" datetime="2020-03-23T11:55:30+09:00">2020-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>디스트럭처링 할당이란?</p>
<ul>
<li>구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</li>
<li>ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다. 할당 기준은 배열의 인덱스이다.</li>
<li>배열에서 필요한 요소만 추출하여 변수에 할당하고싶을때 유용하다.</li>
</ul>
<p>객체 디스트럭처링 할당</p>
<ul>
<li>ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용.</li>
<li>ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/22/js0322/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/js0322/" class="post-title-link" itemprop="url">스프레드 문법(Spread syntax)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-22 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-22T11:55:30+09:00">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 19:02:50" itemprop="dateModified" datetime="2020-03-25T19:02:50+09:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스프레드-문법-Spread-syntax-이란"><a href="#스프레드-문법-Spread-syntax-이란" class="headerlink" title="스프레드 문법(Spread syntax)이란?"></a>스프레드 문법(Spread syntax)이란?</h1><ul>
<li>하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개, 분산하여, spread) 개별적인 값들의 목록으로 만드는것.</li>
<li>사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), Arguments와 같이 for…of 문으로 순회할 수 있는 이터러블에 한정된다.</li>
</ul>
<h1 id="스프레드-문법-사용-3가지"><a href="#스프레드-문법-사용-3가지" class="headerlink" title="스프레드 문법 사용 3가지."></a>스프레드 문법 사용 3가지.</h1><ol>
<li>함수 호출문의 인수 목록</li>
</ol>
<ul>
<li>요소값들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우</li>
</ul>
<ol start="2">
<li>배열 리터럴 내부에서 사용</li>
</ol>
<ul>
<li>concat:배열 요소들을 새로운 배열의 일부로 만들고 싶은 경우, 배열 리터럴 만으로 해결할 수 없고 concat 메소드를 사용해야 한다.</li>
<li>push: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1.push(3, 4)와 같다.</span></span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li>splice : 기존의 배열에 다른 배열의 요소들을 삽입.</li>
<li>slice: 기존의 배열을 복사.</li>
<li>유사 배열 객체를 배열로 변환 : slice 메소드를 apply 함수로 호출한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 유사 배열 객체인 arguments를 배열로 변환</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3.객체 리터럴 내부에서 사용</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/20/js0320/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/js0320/" class="post-title-link" itemprop="url">배열(array)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-20T11:55:30+09:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 19:03:35" itemprop="dateModified" datetime="2020-03-25T19:03:35+09:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란?"></a>배열이란?</h1><ul>
<li>배열은 여러 개의 값을 순차적으로 나열한 자료 구조이다.</li>
<li>요소에 접근할 때는 대괄호 표기법을 사용한다. </li>
<li>배열은 타입이 아니라 객체이다.</li>
<li>배열은 배열 리터럴 또는 Array 생성자 함수로 생성할 수 있다.</li>
</ul>
<h1 id="일반-객체와-배열-객체-의-차이점"><a href="#일반-객체와-배열-객체-의-차이점" class="headerlink" title="일반 객체와 배열(객체)의 차이점."></a>일반 객체와 배열(객체)의 차이점.</h1><ul>
<li>일반 객체는 값의 순서,length 프로퍼티가 없지만 배열은 가지고 있다. 따라서 배열은 반복문을 통해 순차적으로 값을 접근하기 적합한 자료구조이다.</li>
</ul>
<p>자바스크립트의 배열은 일반적인 배열처럼 밀집 배열이 아니라 배열의 요소가 연속적으로 이어져 있지 않는 희소 배열이다.</p>
<h1 id="일반적인-배열과-자바스크립트-배열의-장단점"><a href="#일반적인-배열과-자바스크립트-배열의-장단점" class="headerlink" title="일반적인 배열과 자바스크립트 배열의 장단점."></a>일반적인 배열과 자바스크립트 배열의 장단점.</h1><ul>
<li>자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열보다 느리지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.</li>
</ul>
<h1 id="length-프로퍼티와-희소-배열"><a href="#length-프로퍼티와-희소-배열" class="headerlink" title="length 프로퍼티와 희소 배열."></a>length 프로퍼티와 희소 배열.</h1><ul>
<li>length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 정수를 값으로 갖는다.</li>
<li>배열에는 요소를 최대 232 – 1(4,294,967,295)개가질수있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 희소 배열: 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 배열을 희소 배열이라 한다.(만들지 않는게 좋다.)</span></span><br><span class="line"><span class="keyword">const</span> sparse = [, <span class="number">2</span>, , <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="배열생성하는방법-4가지"><a href="#배열생성하는방법-4가지" class="headerlink" title="배열생성하는방법 4가지."></a>배열생성하는방법 4가지.</h1><p>1.배열 리터럴.</p>
<ul>
<li>배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호([])로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 이름이 없고 값만이 존재한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = []; <span class="comment">//length 프로퍼티 값이 0인 빈 배열,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, , <span class="number">3</span>]; <span class="comment">// 희소 배열</span></span><br><span class="line"><span class="comment">// 희소 배열은 length는 배열의 실제 요소 개수보다 언제나 크다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>Array 생성자 함수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.of</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">Array</span>.of 메소드는 전달된 인수를 요소로 갖는 배열을 생성</span><br><span class="line"><span class="comment">// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.from<br>Array.from 메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 변환하여 새로운 배열을 생성한다.<br>유사 배열 객체:배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.<br>이터러블 객체: Symbol.iterator 메소드를 구현하여 for…of 문으로 순회할 수 있으며 스프레드 문법의 대상으로 사용할 수 있는 객체를 말한다.</p>
</li>
</ol>
<p>배열 요소의 참조.</p>
<ul>
<li>배열 요소를 참조할 때에는 대괄호([]) 표기법을 사용한다.</li>
<li>존재하지 않는 요소에 접근하면 undefined가 반환된다.(희소 배열도 마찬가지)</li>
</ul>
<p>배열 요소의 삭제.</p>
<ul>
<li>배열 삭제는 delete 연산자로 한다.</li>
<li>희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메소드를 사용한다.</li>
</ul>
<h1 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드."></a>배열 메소드.</h1><p>배열 메소드의 결과물을 반환하는 패턴 2가지.<br>1.원본 배열(배열 메소드를 호출한 배열, 즉 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method).<br>2. 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method).</p>
<p>Array.prototype가 제공하는 메소드 중에서 사용 빈도가 높은 메소드들.</p>
<ol>
<li><p>Array.isArray<br>Array.isArray는 Array 생성자 함수의 정적 메소드이다.주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다.</p>
</li>
<li><p>Array.prototype.indexOf<br>원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.</p>
</li>
</ol>
<ul>
<li>중복되는 요소가 있는 경우, 첫번째 인덱스를 반환한다.</li>
<li>해당하는 요소가 없는 경우, -1을 반환한다.</li>
<li>배열에 요소가 있는지 확인할때 쓰인다.</li>
</ul>
<ol start="3">
<li>Array.prototype.push</li>
</ol>
<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다.</li>
</ul>
<ol start="4">
<li>Array.prototype.pop</li>
</ol>
<ul>
<li>원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. </li>
<li>빈 배열이면 undefined를 반환한다.</li>
</ul>
<ol start="5">
<li>Array.prototype.unshift</li>
</ol>
<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.</li>
</ul>
<ol start="6">
<li>Array.prototype.shift </li>
</ol>
<ul>
<li>shift 메소드는 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다.</li>
</ul>
<ol start="7">
<li>Array.prototype.concat</li>
</ol>
<ul>
<li>인수로 전달된 값들(배열 또는 값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다.</li>
</ul>
<ol start="8">
<li>Array.prototype.splice</li>
</ol>
<ul>
<li>배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는데 쓰인다.</li>
</ul>
<ol start="9">
<li>Array.prototype.slice</li>
</ol>
<ul>
<li>인수로 전달된 범위의 요소들을 복사하여 반환한다. 원본 배열은 변경되지 않는다. </li>
</ul>
<ol start="10">
<li>Array.prototype.join</li>
</ol>
<ul>
<li>원본 배열의 모든 요소를 문자열로 변환한 후, 구분자(separator)로 연결한 문자열을 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환</span></span><br><span class="line">result = arr.join(<span class="string">':'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// '1:2:3:4'</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li>Array.prototype.reverse</li>
</ol>
<ul>
<li>원본 배열의 요소 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.</li>
</ul>
<ol start="12">
<li>Array.prototype.fill</li>
</ol>
<ul>
<li>인수로 전달 받은 값을 요소로 배열의 처음부터 끝까지 채운다. 이때 원본 배열이 변경된다.</li>
</ul>
<ol start="13">
<li>Array.prototype.includes</li>
</ol>
<ul>
<li>배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.</li>
</ul>
<ol start="14">
<li>Array.prototype.flat</li>
</ol>
<ul>
<li>인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]].flat()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h1 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수."></a>배열 고차 함수.</h1></li>
<li>인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다.</li>
</ul>
<ol>
<li>Array.prototype.sort</li>
</ol>
<ul>
<li>배열의 요소를 적절하게(오름차순) 정렬한다.</li>
<li>내림차순으로 바꾸고 싶으면 reverse 메소드 사용.</li>
</ul>
<ol start="2">
<li>Array.prototype.forEach</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.(for문을 대체하는 함수.)</li>
<li>배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.</li>
<li>forEach 메소드 내부에서 this로 사용될 객체를 전달할 수 있다. </li>
</ul>
<ol start="3">
<li>Array.prototype.map</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.<br>그리고 콜백 함수의 반환값들이 요소로서 추가된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>map 메소드가 생성하여 반환하는 새로운 배열의 length는 반드시 this의 length와 일치(맵핑)한다.</li>
</ul>
<ol start="4">
<li>Array.prototype.filter</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다. 콜백 함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>filter 메소드가 생성하여 반환하는 새로운 배열의 length는 filter 메소드를 호출한 배열, 즉 this의 length와 같거나 작다.</li>
</ul>
<ol start="5">
<li>Array.prototype.reduce</li>
</ol>
<ul>
<li>배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 하나의 결과값을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>첫번째 인수로 콜백 함수, 두번째 인수로 초기값을 전달</li>
<li>reduce 메소드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, 요소값, 인덱스, reduce 메소드를 호출한 배열, 즉 this가 전달된다.</li>
<li>reduce 메소드는 하나의 결과값을 반환한다.</li>
</ul>
<ol start="6">
<li>Array.prototype.some</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 하나라도 참이라면 true, 모두 거짓이라면 false를 반환한다.</li>
</ul>
<ol start="7">
<li>Array.prototype.every</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 모두 참이라면 true, 하나라도 거짓이라면 false를 반환한다.</li>
</ul>
<ol start="8">
<li>Array.prototype.find</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. </li>
<li>참인 요소가 존재하지 않는다면 undefined를 반환한다.</li>
</ul>
<ol start="9">
<li>Array.prototype.findIndex</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. </li>
<li>참인 요소가 존재하지 않는다면 -1를 반환한다.</li>
</ul>
<ol start="10">
<li>Array.prototype.flatMap</li>
</ol>
<ul>
<li>map을 통해 생성된 새로운 배열을 평탄화한다. 즉, map 메소드와 flat 메소드를 순차적으로 실행한다.</li>
<li>평탄화 깊이를 지정할 수는 없고 1단계만 평탄화한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/16/js0316/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/js0316/" class="post-title-link" itemprop="url">실행 컨텍스트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-16T11:55:30+09:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 00:29:25" itemprop="dateModified" datetime="2020-03-17T00:29:25+09:00">2020-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.소스 코드의 타입.<br>4가지 타입으로 구분하는데 이유는 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.<br>1.전역 코드: 전역에 존재하는 소스 코드. 전역에 정의된 함수,클래스 등의 내부 코드는 포함되지 않는다. 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야한다.<br>var 키워드로 선언된 전역 변수, 함수 선언문으로 정의돈 전역 함수 전역 객체의 프로퍼티와 메소드로 바인딩하고 참조하기 위해 전여 객체와 연결되어야한다.<br>전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.<br>2.함수 코드:함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.<br>함수 코드는 지역 스코프를 생성하고 지역 변수와 매개 변수를 관리.<br>생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결<br>함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.<br>eval 코드:빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드.<br>엄격 모드(strict mode)에서 자신만의 독자적인 스코프를 생성하고, eval 코드가 평가되면 eval 실행 컨텍스트가 생성.<br>모듈 코드: 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.<br>모듈 별로 독립적인 스코프를 생성.<br>모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성.<br>2. 소스 코드의 평가와 실행<br>소스 코드를 2개의 과정, 즉 소스 코드의 평가와 소스 코드의 실행.<br>소스 코드 평과 과정에서는  실행 컨텍스트를 생성하고 변수, 함수 등의 선언문 만을 먼저 실행  생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.<br>평가 과정이 끝나면 비로소 선언문을 제외한 소스 코드가 순차적으로 실행.<br>소스 코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득.<br>변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.<br>-소스코드1-</p>
<ol start="3">
<li>실행 컨텍스트의 역할</li>
<li>전역 코드 평가<br>1-1.전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드 실행을 위한 준비.<br>1-2. 평가 과정에서는 선언문 만을 먼저 실행<br>1-3. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록<br>1-4. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 전역 객체의 프로퍼티와 메소드가 된다.</li>
<li>전역 코드 실행<br>2-1. 평가가 끝나면 전역 코드가 순차적으로 실행.<br>2-2. 전역 변수에 값이 할당되고 함수가 호출<br>2-3. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.</li>
<li>함수 코드 평가<br>3-1. 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정,  함수 코드 실행을 위한 준비<br>3-2.매개 변수와 지역 변수 선언문이 먼저 실행되고 그 결과 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록<br>3-3.함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록.</li>
<li>함수 코드 실행<br>4-1.함수 코드의 평가가 끝나면 함수 코드가 순차적으로 실행.<br>이때 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다.<br>4-2.console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색.<br>함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다.<br>식별자 console은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재.<br>전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프에서 검색 가능해야 한다는 것을 의미.<br>4-3. log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색.<br>4-4. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가<br>4-5. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가.<br>4-6. console.log 메소드의 실행이 종료되면 함수 코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.<br>이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다.  중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.<br>함수 호출이 종료하면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리.<br>이처럼 코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</li>
</ol>
<p>1.선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.<br>2.스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.<br>3.현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</p>
<p>-실행 컨텍스트(Execution context)는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
<p>-실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.<br>-식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다</p>
<ol start="4">
<li>실행 컨텍스트 스택.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.<br>이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 이를 실행 컨텍스트 스택(Execution context stack)라고 부른다.<br>실행 컨텍스트 스택을 콜 스택(Call stack)이라고 부르기도 한다.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/15/js0315-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/js0315-2/" class="post-title-link" itemprop="url">this</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-15T11:55:30+09:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 01:11:05" itemprop="dateModified" datetime="2020-03-16T01:11:05+09:00">2020-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>this 키워드<br>객체는 상태를 나타내느 프로퍼티와 동작을 나타내는 메소드를 하나의 논리적인 단위로 묶은것인데, this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다.<br>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 코드 어디에서든지 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.<br>strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.</li>
<li>함수 호출 방식과 this 바인딩<br>this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.<br>렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.<br>함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. this에 바인딩될 객체는 함수 호출 시점에 결정된다.</li>
</ol>
<p>함수를 호출하는 4가지 방식.<br>1.일반 함수 호출<br>2.메소드 호출<br>3.생성자 함수 호출<br>4.Function.prototype.apply/call/bind 메소드에 의한 간접 호출</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this에 바인딩될 객체는 함수 호출 방식에 따라 동적으로 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 동일한 함수도 다양한 방식으로 호출할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 일반 함수 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 일반적인 방식으로 호출</span></span><br><span class="line"><span class="comment">// this는 전역 객체 window를 가리킨다.</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 메소드 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 프로퍼티의 값으로 할당하여 호출</span></span><br><span class="line"><span class="comment">// this는 메소드를 호출한 객체 obj를 가리킨다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 생성자 함수 호출</span></span><br><span class="line"><span class="comment">// foo 함수를 new 연산자와 함께 생성자 함수로 호출</span></span><br><span class="line"><span class="comment">// this는 생성자 함수가 생성한 인스턴스를 가리킨다.</span></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">// foo &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출</span></span><br><span class="line"><span class="comment">// this는 인수에 의해 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"></span><br><span class="line">foo.call(bar);   <span class="comment">// bar</span></span><br><span class="line">foo.apply(bar);  <span class="comment">// bar</span></span><br><span class="line">foo.bind(bar)(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>2.1. 일반 함수 호출<br>기본적으로 this에는 전역 객체(Global object)가 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// window</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 <span class="keyword">this</span>에는 전역 객체가 바인딩된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">객체를 생성하지 않는 일반 함수에서 <span class="keyword">this</span>는 의미가 없기 때문에 strict mode가 적용된 일반 함수 내부의 <span class="keyword">this</span>에는 <span class="literal">undefined</span>가 바인딩된다.</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// undefined</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 변수 value는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const 키워드로 선언한 변수 value는 전역 객체의 프로퍼티가 아니다.</span></span><br><span class="line"><span class="comment">// const value = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>);  <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 내에서 정의한 중첩 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"bar's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"bar's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면</span></span><br><span class="line">    <span class="comment">// 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">콜백 함수 내부의 <span class="keyword">this</span>에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 <span class="keyword">this</span>에 전역 객체가 바인딩된다.</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo's this: "</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="comment">// 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"callback's this: "</span>, <span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"callback's this.value: "</span>, <span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>
<p>일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.</p>
<p>2.2. 메소드 호출<br>메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체에 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// 메소드의 this는 메소드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 getName을 호출한 객체는 person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName());</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">메소드 내부의 <span class="keyword">this</span>는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다.</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// 메소드의 this는 메소드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 getName을 호출한 객체는 person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>
<p>2.3. 생성자 함수 호출<br>생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>2.4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출<br>Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply와 call 메소드는 Function.prototype의 메소드이다. 즉, apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다.<br><img src="https://user-images.githubusercontent.com/56964928/76704933-aea64200-671f-11ea-9467-23b1ee729597.png" alt="메소드1"></p>
<p>apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.</p>
<p><img src="https://user-images.githubusercontent.com/56964928/76704985-fb8a1880-671f-11ea-8e07-94b02edd1c18.png" alt="캡처_2020_03_16_00_49_02_135"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/15/js03-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/js03-19/" class="post-title-link" itemprop="url">ES6 함수의 추가 기능</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-15T11:55:30+09:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-19 23:52:35" itemprop="dateModified" datetime="2020-03-19T23:52:35+09:00">2020-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>함수의 구분.<br>-함수는 일반적인 함수로서 호출,new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출, 객체에 바인딩되어 메소드로서 호출이 있다.<br>-호출할 수 있는 함수 객체를 callable,인스턴스를 생성할 수 있는 함수 객체를 constructor, 인스턴스를 생성할 수 없는 함수 객체를 있는 non-constructor라고 부른다.<br>-일반 함수는 constructor이지만 ES6의 메소드와 화살표 함수는 non-constructor이다.</p>
<p>메소드<br>-ES6 사양에서 메소드는 메소드 축약 표현으로 정의된 함수 만을 의미한다.<br>-메소드(이하 ES6 메소드)는 인스턴스를 생성할 없는 non-constructor이다. 따라서 ES6 메소드는 생성자 함수로서 호출할 수 없다.<br>-ES6 메소드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.</p>
<ul>
<li>표준 빌드인 객체의 메소드는 모두 non-constructor이다.</li>
<li>ES6 메소드는 메소드가 바인딩된 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖고있는데 이러한 매소들만이 super키워드를 사용할 수 있다.</li>
</ul>
<p>화살표 함수.<br>function 키워드 대신 화살표(=&gt;, fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의하는 방법. 내부 동작도 기존의 함수보다 간략하다.  콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.</p>
<p>화살표 함수 정의<br>매개 변수가 여러 개인 경우, 소괄호 () 안에 매개 변수를 선언.<br>매개 변수가 한 개인 경우, 소괄호 ()를 생략할 수 있다.<br>매개 변수가 없는 경우, 소괄호 ()를 생략할 수 없다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pkt0831.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="My Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="pkt0831&#39;s Blog">
<meta property="og:url" content="https://pkt0831.github.io/index.html">
<meta property="og:site_name" content="pkt0831&#39;s Blog">
<meta property="og:description" content="My Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ki Tae Park">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pkt0831.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>pkt0831's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pkt0831's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/05/08/mibi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/mibi/" class="post-title-link" itemprop="url">자바스크립트 개념.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-08 05:55:30" itemprop="dateCreated datePublished" datetime="2020-05-08T05:55:30+09:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-09 13:43:25" itemprop="dateModified" datetime="2020-05-09T13:43:25+09:00">2020-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>비동기 처리란?<br>현재 실행중인 태스크가 종료되지 않은 상태라 하더라도 다음 태스크를 곧바로 실행하는 방식을 비동기식 처리 모델이이라고 하고, 현재 실행중인 태스크가 종료할 때까지 다음 실행될 태스크가 대기하는 방식을 동기식 처리 모델이라고 한다.<br>자바스크립트의 타이머 함수,HTTP요청이 비동기식 처리 모델이다.</p>
</li>
<li><p>ES6에서 새로 생긴 기능들은?<br>let, const, class, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, Symbol, Promise, Map/Set, iterator, for…of, generator, Proxy, module import/export</p>
</li>
<li><p>Ajax란?<br>자바스크립트를 이용해서 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신 기능.</p>
</li>
<li><p>JavaScript와 ECMAScript 란?<br>ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 표준 빌트인 객체(standard built-in object) 등 핵심 문법(core syntax)을 규정한다<br>자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다.</p>
</li>
<li><p>자바스크립트의 특징.<br>자바스크립트는 웹 브라우저에서 동작하기위해 탄생한 프로그래밍 언어로써, 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다. 또한,  명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 프로토타입 기반의 객체지향 언어이다.</p>
</li>
<li><p>변수란?<br>변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.<br>변수에 값을 저장하는 것을 할당, 읽어들이는 것을 참조라고한다.</p>
</li>
<li><p>식별자란?<br>어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다.또한, 식별자는 값이 아니라 메모리 주소를 기억하고 있다.</p>
</li>
<li><p>변수 호이스팅이란?<br>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)이라 한다.</p>
</li>
<li><p>값이 할당되는 시점은?<br>변수 선언은 런타임 이전에 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 런타임에 실행된다.</p>
</li>
<li><p>값이란?<br>값(value)은 식(표현식, expression)이 평가(evaluate)되어 생성된 결과를 말한다. </p>
</li>
<li><p>리터럴<br>리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식(notaion)을 말한다. </p>
</li>
<li><p>표현식<br>표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다.</p>
</li>
<li><p>문<br>문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.</p>
</li>
<li><p>토큰<br>토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. </p>
</li>
<li><p>객체란?<br>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조</p>
</li>
<li><p>프로퍼티,메소드란?<br>프로퍼티란 객체의 상태를 나타내는 값, 메소드는 프로퍼티를 참조하고 조작할 수 있는 동작.</p>
</li>
<li><p>객체를 생성하는 방법은?<br>객체 리터럴,Object 생성자 함수,Object.create 메소드,클래스,생성자 함수</p>
</li>
<li><p>값에 의한 전달이란?<br>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 자바스크립트는 값에 의한 전달만이 존재한다.</p>
</li>
<li><p>참조에 의한 전달<br>객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)라 한다.</p>
</li>
<li><p>얕은복사와 깊은 복사<br>얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.</p>
</li>
<li><p>함수란?<br>함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것으로써,코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</p>
</li>
<li><p>함수호이스팅이란?<br>함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라 한다.</p>
</li>
<li><p>콜백함수란?<br>함수의 매개변수를 통해 전달되는 함수를 콜백 함수(callback function)라고 한다.</p>
</li>
<li><p>고차함수란?<br>콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수라고 한다.</p>
</li>
<li><p>스코프란?<br>식별자가 유효한 범위를 말한다.</p>
</li>
<li><p>스코프체인이란?<br>스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 부른다.</p>
</li>
<li><p>블록레벨 스코프와 함수 레벨 스코프<br>함수 몸체 만이 아니라 모든 코드 블록이 지역스코프를 만드는것을 블록레벨스코프, var 키워드같이 오로지 함수의 코드 블록 만을 지역 스코프로 인정하는것을 함수 레벨 스코프라고한다.</p>
</li>
<li><p>동적 스코프와 렉시컬 스코프(정적 스코프)란?<br>함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하는것을 동적 스코프라하고, 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는것을 렉시컬 스코프라한다.</p>
</li>
<li><p>전역 변수의 문제점<br>모든 코드가 전역 변수를 참조하고 변경할수있는 암묵적 결합과 생명 주기가 길기 때문에 메모리 리소스 관리에 비효율 적이다.또한, 스코프 체인 상 종점에 존재해 검색 속도가 느리고 파일이 분리되어있어도 하나의 전역 스코프를 공유하기때문에 네임 스페이스 오염을 가져올 수 있다.</p>
</li>
<li><p>일급 객체<br>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.<br>변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.<br>함수의 매개 변수에게 전달할 수 있다.<br>함수의 결과값으로 반환할 수 있다.</p>
</li>
<li><p>객체지향 프로그래밍<br>절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.</p>
</li>
<li><p>프로토타입 체인이란?<br>자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다.</p>
</li>
<li><p>this<br>this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다.</p>
</li>
<li><p>렉시컬 환경<br>식별자와 식별자에 바인딩된 값 그리고 상위 스코프에 대한 참조를 기록하는 환경</p>
</li>
<li><p>클래스와 생성자 함수의 차이점.</p>
</li>
<li><p>클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발행한다. 하지만 생성자 함수는 new 연산자를 사용하지 않고 호출하면 일반 함수로서 호출된다.</p>
</li>
</ol>
<p>2.클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 extends와 super 키워드를 지원하지 않는다.</p>
<p>3.클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.</p>
<p>4.클래스 내의 모든 코드에는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 하지만 생성자 함수는 암묵적으로 strict 모드가 지정되지 않는다.</p>
<p>5.클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시 말해, 열거되지 않는다.<br>36. 화살표 함수와 일반 함수의 차이점.<br>화살표 함수는 함수 자체의 this 바인딩이 없다. 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 참조한다.<br>37. 디스트럭처리 할당이란?<br>구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.<br>38. Promise<br>콜백헬과 에러처리의 한계때문에 생긴 비동기 처리에 사용되는 객체.<br>39. 제너레이터란?<br>ES6에서 도입된 제너레이터(Generator) 함수는 이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다.<br>40. 클로저<br> 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/05/04/DataBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/DataBase/" class="post-title-link" itemprop="url">DataBase</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-04 21:18:57 / Modified: 21:22:40" itemprop="dateCreated datePublished" datetime="2020-05-04T21:18:57+09:00">2020-05-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>country 테이블에서 중복을 제거한 Continent를 조회하세요.<br>select DISTINCT(continent) as continent<br>from world.country;</li>
</ol>
<ol start="3">
<li><p>한국 도시중에 인구가 100만이 넘는 도시를 조회하여 인구순으로 내림차순하세요.<br>select *<br>from city<br>where countrycode = “kor” and population &gt; 1000000<br>ORDER BY population DESC;</p>
</li>
<li><p>city 테이블에서 population이 800만 ~ 1000만 사이인 도시 데이터를 인구수순으로 내림차순하세요.<br>select *<br>from city<br>where population between 800000 and 10000000<br>order by population desc;</p>
</li>
<li><p>country 테이블에서 1940 ~ 1950년도 사이에 독립한 국가들을 조회하고 독립한 년도 순으로 오름차순하세<br>요.<br>select *<br>from country<br>where indepyear between 1940 and 1950<br>order by indepyear asc;</p>
</li>
<li><p>contrylanguage 테이블에서 스페인어, 한국어, 영어를 95% 이상 사용하는 국가 코드를 Percentage로 내<br>림차순하여 아래와 같이 조회하세요.<br>select *<br>from countrylanguage<br>where language in(“english”,”korean”,”spanish”) and percentage &gt; 95<br>order by percentage desc;</p>
</li>
<li><p>country 테이블에서 Code가 A로 시작하고 GovernmentForm에 Republic이 포함되는 데이터를 아래와<br>같이 조회하세요.<br>select *<br>from country<br>where governmentform like “%republic”<br>order by code asc</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/04/15/Module(04.15)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/Module(04.15)/" class="post-title-link" itemprop="url">Module</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-15 09:55:30" itemprop="dateCreated datePublished" datetime="2020-04-15T09:55:30+09:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-16 11:07:28" itemprop="dateModified" datetime="2020-04-16T11:07:28+09:00">2020-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="모듈이란"><a href="#모듈이란" class="headerlink" title="모듈이란?"></a>모듈이란?</h1><p>모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.<br>script 태그에 type=”module” 어튜리뷰트를 추가하면 모둘로서 동작한다.<br>다만, 여러가지 이유로인해 ES6 모듈보단 Webpack 등의 모듈 번들러를 사용한다.</p>
<ul>
<li><p>모듈 스코프<br>모듈 기능을 사용하지 않으면 독자적인 스코프를 갖지 않고 하나의 전역을 공유하는 문제점이있다.<br>따라서 ES6 모듈을 사용함으로써 독자적인 모듈 스코프를 갖게된다.</p>
</li>
<li><p>export 키워드<br>모듈 안에 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할수있게 해주는 키워드.<br>하나의 객체로 모아서 선언할 수도 있다.<br>ex) export { pi, Person};</p>
</li>
<li><p>inport 키워드<br>모듈에서 공개한 대상을 로드하기위해 사용되는 키워드.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/04/08/Promise(04.08)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Promise(04.08)/" class="post-title-link" itemprop="url">Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-08 09:55:30 / Modified: 21:35:58" itemprop="dateCreated datePublished" datetime="2020-04-08T09:55:30+09:00">2020-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>프로미스란?<br>자바스크립트는 비동기 처리를 위해 콜백 함수를 사용하는데 에러의 예외 처리가 곤란한 단점을 보완하기위해 비동기 처리를 위한 다른 패턴인 프로미스가 생기게 되었다. 이로인해 비동기 처리 시점이 명확하게 표현할수있게되었다.</p>
</li>
<li><p>콜백 패턴의 단점.</p>
</li>
</ul>
<p>1.콜백 헬.<br>비동기 처리를 위해 콜백 패턴을 사용하면 여러개의 콜백 함수가 정칩되어 복잡도가 높아지는 현상.<br>이러한 현상이 생기는 원인은 비동기 처리 모델은 실행 완료를 기다리지 않고 즉시 다음 태스크를 실행하기 때문에 기대한 대로 동작하지않게 된다.<br>2.에러 처리의 한계.<br>비동기 처리 함수의 콜백 함수 실행 순서는.<br>1.이벤트 발생 -&gt; 태스트 큐 이동 -&gt; 호출 스택이 비어졌을때 호출 스택으로 이동후 실행.</p>
<ul>
<li><p>프로미스의 생성.<br>프로미스는 Promise 생성자 함수를 통해 인스턴스화하고 resolve와 reject  함수를 인자로 전달받는다.<br>Promise는 비동기 처리가 성공(fulfilled)하였는지 또는 실패(rejected)하였는지 등의 상태(state) 정보를 갖는다.<br>fullfilled (성공), rejected(실패), settled(성공 또는 실패), pending(수행 안됨).</p>
</li>
<li><p>프로미스의 후속 처리 메소드<br>Promise로 구현된 비동기 함수는 Promise 객체를 반환한다. Promise 객체의 후속 처리 메소드(then, catch)를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다.<br>then: 두 개의 콜백 함수를 인자로 전달 받는다. 첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 두 번째 함수는 실패.<br>then 메소드는 Promise를 반환.<br>catch: 예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출.</p>
</li>
<li><p>프로미스의 에러 처리.<br>catch 메소드는 비동기 처리에서 발생한 에러뿐만 아니라 then메소드 내부에서 발생한 에러도 캐치한다. 에러처리는 catch메소드를 사용하는 편이 효율적이다.</p>
</li>
<li><p>프로미스 체이닝<br>프로미스는 후속 처리 메소드를 체이닝하여 여러 개의 프로미스를 연결하여 사용하여 콜백 헬을 해결한다.</p>
</li>
<li><p>프로미스의 정적 메소드.<br>4가지 정적 메소드를 제공한다.</p>
</li>
</ul>
<ol>
<li><p>Promise.resolve/Promise.reject<br>Promise.resolve 메소드는 인자로 전달된 값을 resolve하는 Promise를 생성.<br>Promise.reject 인자로 전달된 값을 reject하는 프로미스를 생성.</p>
</li>
<li><p>Promise.all<br>프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다.</p>
</li>
<li><p>Promise.race<br>Promise.all처럼 배열,이터러블을 인자로 전달 받지만 차이점은 병렬로 처리하는것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 반환한다.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/04/04/TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/TIL/" class="post-title-link" itemprop="url">하루 정리.</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-04 11:55:30" itemprop="dateCreated datePublished" datetime="2020-04-04T11:55:30+09:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-10 19:08:06" itemprop="dateModified" datetime="2020-06-10T19:08:06+09:00">2020-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>04.07<br>todo 리스트를 JSON을 이용해서 가상의 백엔드 서버를 설정하고 서버 호출 실습.</li>
<li>04.08<br>todo 리스트 미비한거 공부 및 Promise 예습. 비동기 처리의 어려움을 느낌.</li>
<li>04.09<br>Promise 실습 및 이력서 보완점 고침. Todo 리스트 반복 학습.</li>
<li>04.11<br>Todo 리스트 실습 및 다음 수업 예제들 예습.</li>
<li>04 13<br>Ajax,Promise 등 통신 수업 및 복습.</li>
<li>04.14<br>StopWatch 등 각종 예제 풀이.</li>
<li>04.15<br>ajax통신 복습 및 stopWatch 보완.</li>
<li>04.18<br>프로젝트 기능구현 공부.</li>
<li>04.20~24<br>프로젝트 기간.</li>
<li>04.26<br>json서버,Promise 등 통신 미비된 부분 복습.</li>
<li>04.27<br>데이타 베이스 설정 및 각종 명령어 실습.</li>
<li>04.28<br>데이터 베이스 문제풀이</li>
<li>04.29<br>데이터 베이스 mysql,mongodb.</li>
<li>04.30<br>mongodb, 데이터 베이스 문제풀이.</li>
<li>05.04<br>React porps,조건부 렌더링.</li>
<li>05.11<br>React Props 및 로그인 실습.</li>
<li>05.12<br>React Recycle 및 실습. 네트워크 운영체제 기초 이론.</li>
<li>05.13<br>React Hook useEffect, useMemo, useCallback, React.memo.</li>
<li>05.14<br>React Use Reducer</li>
<li>05.15<br>React use Reducer 전화번호부.</li>
<li>05.18<br>Rest Api 연동.</li>
<li>05.19<br>React Router.</li>
<li>05.21<br>React Code Splite.</li>
<li>05.22<br>React js스타일,Movie 실습.</li>
<li>05.23<br>React Todo,Tic 다시 만들어보기.</li>
<li>05.25<br>API를 이용한 연동.</li>
<li>05.28<br>React Redux.</li>
<li>05.31<br>React 복습.</li>
<li>06.01<br>운영체제/네트워크, React Reducer.</li>
<li>06.02<br>React Redux Saga.</li>
<li>06.03<br>React useReducer 복습.</li>
<li>06.04<br>알고리즘 기본개념. 프로그래머스 1레벨.</li>
<li>06.08<br>React 총 복습.</li>
<li>06.09<br>React Movie, TypeScript.</li>
<li>06.10<br>Node J.s</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/26/js0326/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/js0326/" class="post-title-link" itemprop="url">수학 상수와 함수를 위한 Math 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 05:55:30" itemprop="dateCreated datePublished" datetime="2020-03-26T05:55:30+09:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-30 21:46:04" itemprop="dateModified" datetime="2020-03-30T21:46:04+09:00">2020-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Math-Property"><a href="#Math-Property" class="headerlink" title="Math Property"></a>Math Property</h1><p>1.Math.Pi<br>Pi값 = 3.14… 반환.</p>
<h1 id="Math-Method"><a href="#Math-Method" class="headerlink" title="Math Method"></a>Math Method</h1><p>1.Math.abs(x: number): number<br>인수의 절댓값 반환. 반드시 0또는 양수이어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">'-1'</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">null</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">undefined</span>);<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>2 Math.round(x: number): number</p>
<p>인수의 소수점 이하를 반올림한 정수 반환.</p>
<p>3 Math.ceil(x: number): number<br>인수의 소수점 이하를 올림한 정수를 반환.</p>
<p>4 Math.floor(x: number): number<br>인수의 소수점 이하를 내림한 정수 반환.</p>
<ul>
<li>양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환</li>
<li>음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환.</li>
</ul>
<p>5 Math.sqrt(x: number): number<br>인수의 제곱근 반환.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">9</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-9</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>6 Math.random(): number<br>임의의 부동 소수점 0 ~ 1 미만 반환.</p>
<p>7 Math.pow(x: number, y: number): number<br>첫번째 인수 밑, 두번째 인수를 지수로하여 거듭제곱.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">8</span>);  <span class="comment">// 256</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>);     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>8 Math.max(…values: number[]): number<br>인수 중에서 가장 큰 수 반환.</p>
<p>9 Math.min(…values: number[]): number<br>인수 중에서 가장 작은 수 반환.</p>
<p>10.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/23/js0323/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/js0323/" class="post-title-link" itemprop="url">디스트럭처링 할당(Destructuring assignment)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-23 11:55:30 / Modified: 19:40:15" itemprop="dateCreated datePublished" datetime="2020-03-23T11:55:30+09:00">2020-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>디스트럭처링 할당이란?</p>
<ul>
<li>구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</li>
<li>ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다. 할당 기준은 배열의 인덱스이다.</li>
<li>배열에서 필요한 요소만 추출하여 변수에 할당하고싶을때 유용하다.</li>
</ul>
<p>객체 디스트럭처링 할당</p>
<ul>
<li>ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용.</li>
<li>ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/22/js0322/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/js0322/" class="post-title-link" itemprop="url">스프레드 문법(Spread syntax)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-22 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-22T11:55:30+09:00">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 19:02:50" itemprop="dateModified" datetime="2020-03-25T19:02:50+09:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스프레드-문법-Spread-syntax-이란"><a href="#스프레드-문법-Spread-syntax-이란" class="headerlink" title="스프레드 문법(Spread syntax)이란?"></a>스프레드 문법(Spread syntax)이란?</h1><ul>
<li>하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개, 분산하여, spread) 개별적인 값들의 목록으로 만드는것.</li>
<li>사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), Arguments와 같이 for…of 문으로 순회할 수 있는 이터러블에 한정된다.</li>
</ul>
<h1 id="스프레드-문법-사용-3가지"><a href="#스프레드-문법-사용-3가지" class="headerlink" title="스프레드 문법 사용 3가지."></a>스프레드 문법 사용 3가지.</h1><ol>
<li>함수 호출문의 인수 목록</li>
</ol>
<ul>
<li>요소값들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우</li>
</ul>
<ol start="2">
<li>배열 리터럴 내부에서 사용</li>
</ol>
<ul>
<li>concat:배열 요소들을 새로운 배열의 일부로 만들고 싶은 경우, 배열 리터럴 만으로 해결할 수 없고 concat 메소드를 사용해야 한다.</li>
<li>push: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1.push(3, 4)와 같다.</span></span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li>splice : 기존의 배열에 다른 배열의 요소들을 삽입.</li>
<li>slice: 기존의 배열을 복사.</li>
<li>유사 배열 객체를 배열로 변환 : slice 메소드를 apply 함수로 호출한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 유사 배열 객체인 arguments를 배열로 변환</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3.객체 리터럴 내부에서 사용</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/20/js0320/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/js0320/" class="post-title-link" itemprop="url">배열(array)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-20T11:55:30+09:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 19:03:35" itemprop="dateModified" datetime="2020-03-25T19:03:35+09:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열이란"><a href="#배열이란" class="headerlink" title="배열이란?"></a>배열이란?</h1><ul>
<li>배열은 여러 개의 값을 순차적으로 나열한 자료 구조이다.</li>
<li>요소에 접근할 때는 대괄호 표기법을 사용한다. </li>
<li>배열은 타입이 아니라 객체이다.</li>
<li>배열은 배열 리터럴 또는 Array 생성자 함수로 생성할 수 있다.</li>
</ul>
<h1 id="일반-객체와-배열-객체-의-차이점"><a href="#일반-객체와-배열-객체-의-차이점" class="headerlink" title="일반 객체와 배열(객체)의 차이점."></a>일반 객체와 배열(객체)의 차이점.</h1><ul>
<li>일반 객체는 값의 순서,length 프로퍼티가 없지만 배열은 가지고 있다. 따라서 배열은 반복문을 통해 순차적으로 값을 접근하기 적합한 자료구조이다.</li>
</ul>
<p>자바스크립트의 배열은 일반적인 배열처럼 밀집 배열이 아니라 배열의 요소가 연속적으로 이어져 있지 않는 희소 배열이다.</p>
<h1 id="일반적인-배열과-자바스크립트-배열의-장단점"><a href="#일반적인-배열과-자바스크립트-배열의-장단점" class="headerlink" title="일반적인 배열과 자바스크립트 배열의 장단점."></a>일반적인 배열과 자바스크립트 배열의 장단점.</h1><ul>
<li>자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열보다 느리지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.</li>
</ul>
<h1 id="length-프로퍼티와-희소-배열"><a href="#length-프로퍼티와-희소-배열" class="headerlink" title="length 프로퍼티와 희소 배열."></a>length 프로퍼티와 희소 배열.</h1><ul>
<li>length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 정수를 값으로 갖는다.</li>
<li>배열에는 요소를 최대 232 – 1(4,294,967,295)개가질수있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 희소 배열: 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 배열을 희소 배열이라 한다.(만들지 않는게 좋다.)</span></span><br><span class="line"><span class="keyword">const</span> sparse = [, <span class="number">2</span>, , <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="배열생성하는방법-4가지"><a href="#배열생성하는방법-4가지" class="headerlink" title="배열생성하는방법 4가지."></a>배열생성하는방법 4가지.</h1><p>1.배열 리터럴.</p>
<ul>
<li>배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호([])로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 이름이 없고 값만이 존재한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = []; <span class="comment">//length 프로퍼티 값이 0인 빈 배열,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, , <span class="number">3</span>]; <span class="comment">// 희소 배열</span></span><br><span class="line"><span class="comment">// 희소 배열은 length는 배열의 실제 요소 개수보다 언제나 크다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>Array 생성자 함수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.of</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">Array</span>.of 메소드는 전달된 인수를 요소로 갖는 배열을 생성</span><br><span class="line"><span class="comment">// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.from<br>Array.from 메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 변환하여 새로운 배열을 생성한다.<br>유사 배열 객체:배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.<br>이터러블 객체: Symbol.iterator 메소드를 구현하여 for…of 문으로 순회할 수 있으며 스프레드 문법의 대상으로 사용할 수 있는 객체를 말한다.</p>
</li>
</ol>
<p>배열 요소의 참조.</p>
<ul>
<li>배열 요소를 참조할 때에는 대괄호([]) 표기법을 사용한다.</li>
<li>존재하지 않는 요소에 접근하면 undefined가 반환된다.(희소 배열도 마찬가지)</li>
</ul>
<p>배열 요소의 삭제.</p>
<ul>
<li>배열 삭제는 delete 연산자로 한다.</li>
<li>희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메소드를 사용한다.</li>
</ul>
<h1 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드."></a>배열 메소드.</h1><p>배열 메소드의 결과물을 반환하는 패턴 2가지.<br>1.원본 배열(배열 메소드를 호출한 배열, 즉 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method).<br>2. 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method).</p>
<p>Array.prototype가 제공하는 메소드 중에서 사용 빈도가 높은 메소드들.</p>
<ol>
<li><p>Array.isArray<br>Array.isArray는 Array 생성자 함수의 정적 메소드이다.주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다.</p>
</li>
<li><p>Array.prototype.indexOf<br>원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.</p>
</li>
</ol>
<ul>
<li>중복되는 요소가 있는 경우, 첫번째 인덱스를 반환한다.</li>
<li>해당하는 요소가 없는 경우, -1을 반환한다.</li>
<li>배열에 요소가 있는지 확인할때 쓰인다.</li>
</ul>
<ol start="3">
<li>Array.prototype.push</li>
</ol>
<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다.</li>
</ul>
<ol start="4">
<li>Array.prototype.pop</li>
</ol>
<ul>
<li>원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. </li>
<li>빈 배열이면 undefined를 반환한다.</li>
</ul>
<ol start="5">
<li>Array.prototype.unshift</li>
</ol>
<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.</li>
</ul>
<ol start="6">
<li>Array.prototype.shift </li>
</ol>
<ul>
<li>shift 메소드는 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다.</li>
</ul>
<ol start="7">
<li>Array.prototype.concat</li>
</ol>
<ul>
<li>인수로 전달된 값들(배열 또는 값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다.</li>
</ul>
<ol start="8">
<li>Array.prototype.splice</li>
</ol>
<ul>
<li>배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는데 쓰인다.</li>
</ul>
<ol start="9">
<li>Array.prototype.slice</li>
</ol>
<ul>
<li>인수로 전달된 범위의 요소들을 복사하여 반환한다. 원본 배열은 변경되지 않는다. </li>
</ul>
<ol start="10">
<li>Array.prototype.join</li>
</ol>
<ul>
<li>원본 배열의 모든 요소를 문자열로 변환한 후, 구분자(separator)로 연결한 문자열을 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환</span></span><br><span class="line">result = arr.join(<span class="string">':'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// '1:2:3:4'</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li>Array.prototype.reverse</li>
</ol>
<ul>
<li>원본 배열의 요소 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.</li>
</ul>
<ol start="12">
<li>Array.prototype.fill</li>
</ol>
<ul>
<li>인수로 전달 받은 값을 요소로 배열의 처음부터 끝까지 채운다. 이때 원본 배열이 변경된다.</li>
</ul>
<ol start="13">
<li>Array.prototype.includes</li>
</ol>
<ul>
<li>배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.</li>
</ul>
<ol start="14">
<li>Array.prototype.flat</li>
</ol>
<ul>
<li>인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]].flat()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h1 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수."></a>배열 고차 함수.</h1></li>
<li>인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다.</li>
</ul>
<ol>
<li>Array.prototype.sort</li>
</ol>
<ul>
<li>배열의 요소를 적절하게(오름차순) 정렬한다.</li>
<li>내림차순으로 바꾸고 싶으면 reverse 메소드 사용.</li>
</ul>
<ol start="2">
<li>Array.prototype.forEach</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.(for문을 대체하는 함수.)</li>
<li>배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.</li>
<li>forEach 메소드 내부에서 this로 사용될 객체를 전달할 수 있다. </li>
</ul>
<ol start="3">
<li>Array.prototype.map</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.<br>그리고 콜백 함수의 반환값들이 요소로서 추가된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>map 메소드가 생성하여 반환하는 새로운 배열의 length는 반드시 this의 length와 일치(맵핑)한다.</li>
</ul>
<ol start="4">
<li>Array.prototype.filter</li>
</ol>
<ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다. 콜백 함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>filter 메소드가 생성하여 반환하는 새로운 배열의 length는 filter 메소드를 호출한 배열, 즉 this의 length와 같거나 작다.</li>
</ul>
<ol start="5">
<li>Array.prototype.reduce</li>
</ol>
<ul>
<li>배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 하나의 결과값을 반환한다. 이때 원본 배열은 변경되지 않는다.</li>
<li>첫번째 인수로 콜백 함수, 두번째 인수로 초기값을 전달</li>
<li>reduce 메소드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, 요소값, 인덱스, reduce 메소드를 호출한 배열, 즉 this가 전달된다.</li>
<li>reduce 메소드는 하나의 결과값을 반환한다.</li>
</ul>
<ol start="6">
<li>Array.prototype.some</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 하나라도 참이라면 true, 모두 거짓이라면 false를 반환한다.</li>
</ul>
<ol start="7">
<li>Array.prototype.every</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 모두 참이라면 true, 하나라도 거짓이라면 false를 반환한다.</li>
</ul>
<ol start="8">
<li>Array.prototype.find</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. </li>
<li>참인 요소가 존재하지 않는다면 undefined를 반환한다.</li>
</ul>
<ol start="9">
<li>Array.prototype.findIndex</li>
</ol>
<ul>
<li>배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. </li>
<li>참인 요소가 존재하지 않는다면 -1를 반환한다.</li>
</ul>
<ol start="10">
<li>Array.prototype.flatMap</li>
</ol>
<ul>
<li>map을 통해 생성된 새로운 배열을 평탄화한다. 즉, map 메소드와 flat 메소드를 순차적으로 실행한다.</li>
<li>평탄화 깊이를 지정할 수는 없고 1단계만 평탄화한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pkt0831.github.io/2020/03/16/js0316/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ki Tae Park">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pkt0831's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/js0316/" class="post-title-link" itemprop="url">실행 컨텍스트(Execution context)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 11:55:30" itemprop="dateCreated datePublished" datetime="2020-03-16T11:55:30+09:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-04 21:33:25" itemprop="dateModified" datetime="2020-05-04T21:33:25+09:00">2020-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.소스 코드의 타입.<br>4가지 타입으로 구분하는데 이유는 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.<br>1.전역 코드: 전역에 존재하는 소스 코드. 전역에 정의된 함수,클래스 등의 내부 코드는 포함되지 않는다. 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야한다.<br>var 키워드로 선언된 전역 변수, 함수 선언문으로 정의돈 전역 함수 전역 객체의 프로퍼티와 메소드로 바인딩하고 참조하기 위해 전여 객체와 연결되어야한다.<br>전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.<br>2.함수 코드:함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.<br>함수 코드는 지역 스코프를 생성하고 지역 변수와 매개 변수를 관리.<br>생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결<br>함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.<br>eval 코드:빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드.<br>엄격 모드(strict mode)에서 자신만의 독자적인 스코프를 생성하고, eval 코드가 평가되면 eval 실행 컨텍스트가 생성.<br>모듈 코드: 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.<br>모듈 별로 독립적인 스코프를 생성.<br>모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성.<br>2. 소스 코드의 평가와 실행<br>소스 코드를 2개의 과정, 즉 소스 코드의 평가와 소스 코드의 실행.<br>소스 코드 평과 과정에서는  실행 컨텍스트를 생성하고 변수, 함수 등의 선언문 만을 먼저 실행  생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.<br>평가 과정이 끝나면 비로소 선언문을 제외한 소스 코드가 순차적으로 실행.<br>소스 코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득.<br>변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.<br>-소스코드1-</p>
<ol start="3">
<li>실행 컨텍스트의 역할</li>
<li>전역 코드 평가<br>1-1.전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드 실행을 위한 준비.<br>1-2. 평가 과정에서는 선언문 만을 먼저 실행<br>1-3. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록<br>1-4. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 전역 객체의 프로퍼티와 메소드가 된다.</li>
<li>전역 코드 실행<br>2-1. 평가가 끝나면 전역 코드가 순차적으로 실행.<br>2-2. 전역 변수에 값이 할당되고 함수가 호출<br>2-3. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.</li>
<li>함수 코드 평가<br>3-1. 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정,  함수 코드 실행을 위한 준비<br>3-2.매개 변수와 지역 변수 선언문이 먼저 실행되고 그 결과 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록<br>3-3.함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록.</li>
<li>함수 코드 실행<br>4-1.함수 코드의 평가가 끝나면 함수 코드가 순차적으로 실행.<br>이때 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다.<br>4-2.console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색.<br>함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다.<br>식별자 console은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재.<br>전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프에서 검색 가능해야 한다는 것을 의미.<br>4-3. log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색.<br>4-4. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가<br>4-5. console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가.<br>4-6. console.log 메소드의 실행이 종료되면 함수 코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.<br>이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다.  중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.<br>함수 호출이 종료하면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리.<br>이처럼 코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</li>
</ol>
<p>1.선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.<br>2.스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.<br>3.현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</p>
<p>-실행 컨텍스트(Execution context)는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
<p>-실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.<br>-식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다</p>
<ol start="4">
<li>실행 컨텍스트 스택.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.<br>이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 이를 실행 컨텍스트 스택(Execution context stack)라고 부른다.<br>실행 컨텍스트 스택을 콜 스택(Call stack)이라고 부르기도 한다.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ki Tae Park</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ki Tae Park</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
